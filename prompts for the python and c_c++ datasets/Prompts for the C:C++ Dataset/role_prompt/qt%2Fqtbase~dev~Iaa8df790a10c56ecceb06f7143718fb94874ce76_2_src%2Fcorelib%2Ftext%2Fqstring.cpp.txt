I want you to act as a code reviewer of Qt Base in Qt. Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 /****************************************************************************
2 **
3 ** Copyright (C) 2020 The Qt Company Ltd.
4 ** Copyright (C) 2020 Intel Corporation.
5 ** Copyright (C) 2019 Mail.ru Group.
6 ** Contact: https://www.qt.io/licensing/
7 **
8 ** This file is part of the QtCore module of the Qt Toolkit.
9 **
10 ** $QT_BEGIN_LICENSE:LGPL$
11 ** Commercial License Usage
12 ** Licensees holding valid commercial Qt licenses may use this file in
13 ** accordance with the commercial license agreement provided with the
14 ** Software or, alternatively, in accordance with the terms contained in
15 ** a written agreement between you and The Qt Company. For licensing terms
16 ** and conditions see https://www.qt.io/terms-conditions. For further
17 ** information use the contact form at https://www.qt.io/contact-us.
18 **
19 ** GNU Lesser General Public License Usage
20 ** Alternatively, this file may be used under the terms of the GNU Lesser
21 ** General Public License version 3 as published by the Free Software
22 ** Foundation and appearing in the file LICENSE.LGPL3 included in the
23 ** packaging of this file. Please review the following information to
24 ** ensure the GNU Lesser General Public License version 3 requirements
25 ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.
26 **
27 ** GNU General Public License Usage
28 ** Alternatively, this file may be used under the terms of the GNU
29 ** General Public License version 2.0 or (at your option) the GNU General
30 ** Public license version 3 or any later version approved by the KDE Free
31 ** Qt Foundation. The licenses are as published by the Free Software
32 ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3
33 ** included in the packaging of this file. Please review the following
34 ** information to ensure the GNU General Public License requirements will
35 ** be met: https://www.gnu.org/licenses/gpl-2.0.html and
36 ** https://www.gnu.org/licenses/gpl-3.0.html.
37 **
38 ** $QT_END_LICENSE$
39 **
40 ****************************************************************************/
41 
42 #include "qstringlist.h"
43 #if QT_CONFIG(regularexpression)
44 #include "qregularexpression.h"
45 #endif
46 #include "qunicodetables_p.h"
47 #include <private/qstringconverter_p.h>
48 #include "qlocale_tools_p.h"
49 #include "private/qsimd_p.h"
50 #include <qnumeric.h>
51 #include <qdatastream.h>
52 #include <qlist.h>
53 #include "qlocale.h"
54 #include "qlocale_p.h"
55 #include "qstringbuilder.h"
56 #include "qstringmatcher.h"
57 #include "qvarlengtharray.h"
58 #include "qdebug.h"
59 #include "qendian.h"
60 #include "qcollator.h"
61 
62 #ifdef Q_OS_MAC
63 #include <private/qcore_mac_p.h>
64 #endif
65 
66 #include <private/qfunctions_p.h>
67 
68 #include <limits.h>
69 #include <string.h>
70 #include <stdlib.h>
71 #include <stdio.h>
72 #include <stdarg.h>
73 #include <wchar.h>
74 
75 #include "qchar.cpp"
76 #include "qstringmatcher.cpp"
77 #include "qstringiterator_p.h"
78 #include "qstringalgorithms_p.h"
79 #include "qthreadstorage.h"
80 
81 #ifdef Q_OS_WIN
82 #  include <qt_windows.h>
83 #endif
84 
85 #ifdef truncate
86 #  undef truncate
87 #endif
88 
89 #ifndef LLONG_MAX
90 #define LLONG_MAX qint64_C(9223372036854775807)
91 #endif
92 #ifndef LLONG_MIN
93 #define LLONG_MIN (-LLONG_MAX - qint64_C(1))
94 #endif
95 #ifndef ULLONG_MAX
96 #define ULLONG_MAX quint64_C(18446744073709551615)
97 #endif
98 
99 #define IS_RAW_DATA(d) ((d.d)->flags & QArrayData::RawDataType)
100 
101 QT_BEGIN_NAMESPACE
102 
103 template <typename T, typename Cmp = std::less<>>
104 static constexpr bool points_into_range(const T *p, const T *b, const T *e, Cmp less = {}) noexcept
105 {
106     return !less(p, b) && less(p, e);
107 }
108 
109 const char16_t QString::_empty = 0;
110 
111 /*
112  * Note on the use of SIMD in qstring.cpp:
113  *
114  * Several operations with strings are improved with the use of SIMD code,
115  * since they are repetitive. For MIPS, we have hand-written assembly code
116  * outside of qstring.cpp targeting MIPS DSP and MIPS DSPr2. For ARM and for
117  * x86, we can only use intrinsics and therefore everything is contained in
118  * qstring.cpp. We need to use intrinsics only for those platforms due to the
119  * different compilers and toolchains used, which have different syntax for
120  * assembly sources.
121  *
122  * ** SSE notes: **
123  *
124  * Whenever multiple alternatives are equivalent or near so, we prefer the one
125  * using instructions from SSE2, since SSE2 is guaranteed to be enabled for all
126  * 64-bit builds and we enable it for 32-bit builds by default. Use of higher
127  * SSE versions should be done when there is a clear performance benefit and
128  * requires fallback code to SSE2, if it exists.
129  *
130  * Performance measurement in the past shows that most strings are short in
131  * size and, therefore, do not benefit from alignment prologues. That is,
132  * trying to find a 16-byte-aligned boundary to operate on is often more
133  * expensive than executing the unaligned operation directly. In addition, note
134  * that the QString private data is designed so that the data is stored on
135  * 16-byte boundaries if the system malloc() returns 16-byte aligned pointers
136  * on its own (64-bit glibc on Linux does; 32-bit glibc on Linux returns them
137  * 50% of the time), so skipping the alignment prologue is actually optimizing
138  * for the common case.
139  */
140 
141 #if defined(__mips_dsp)
142 // From qstring_mips_dsp_asm.S
143 extern "C" void qt_fromlatin1_mips_asm_unroll4 (char16_t*, const char*, uint);
144 extern "C" void qt_fromlatin1_mips_asm_unroll8 (char16_t*, const char*, uint);
145 extern "C" void qt_toLatin1_mips_dsp_asm(uchar *dst, const char16_t *src, int length);
146 #endif
147 
148 // internal
149 qsizetype qFindStringBoyerMoore(QStringView haystack, qsizetype from, QStringView needle, Qt::CaseSensitivity cs);
150 static inline qsizetype qFindChar(QStringView str, QChar ch, qsizetype from, Qt::CaseSensitivity cs) noexcept;
151 template <typename Haystack>
152 static inline qsizetype qLastIndexOf(Haystack haystack, QChar needle, qsizetype from, Qt::CaseSensitivity cs) noexcept;
153 template <>
154 inline qsizetype qLastIndexOf(QString haystack, QChar needle,
155                               qsizetype from, Qt::CaseSensitivity cs) noexcept = delete; // unwanted, would detach
156 
157 static inline bool qt_starts_with(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs);
158 static inline bool qt_starts_with(QStringView haystack, QLatin1String needle, Qt::CaseSensitivity cs);
159 static inline bool qt_starts_with(QStringView haystack, QChar needle, Qt::CaseSensitivity cs);
160 static inline bool qt_ends_with(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs);
161 static inline bool qt_ends_with(QStringView haystack, QLatin1String needle, Qt::CaseSensitivity cs);
162 static inline bool qt_ends_with(QStringView haystack, QChar needle, Qt::CaseSensitivity cs);
163 
164 #if defined(__SSE2__) && defined(Q_CC_GNU) && !defined(Q_CC_INTEL)
165 #  if defined(__SANITIZE_ADDRESS__) && Q_CC_GNU < 800 && !defined(Q_CC_CLANG)
166 #     warning "The __attribute__ on below will likely cause a build failure with your GCC version. Your choices are:"
167 #     warning "1) disable ASan;"
168 #     warning "2) disable the optimized code in qustrlen (change __SSE2__ to anything else);"
169 #     warning "3) upgrade your compiler (preferred)."
170 #  endif
171 
172 // We may overrun the buffer, but that's a false positive:
173 // this won't crash nor produce incorrect results
174 __attribute__((__no_sanitize_address__))
175 #endif
176 qsizetype QtPrivate::qustrlen(const char16_t *str) noexcept
177 {
178     qsizetype result = 0;
179 
180 #if defined(__SSE2__) && !(defined(__SANITIZE_ADDRESS__) || QT_HAS_FEATURE(address_sanitizer))
181     // find the 16-byte alignment immediately prior or equal to str
182     quintptr misalignment = quintptr(str) & 0xf;
183     Q_ASSERT((misalignment & 1) == 0);
184     const char16_t *ptr = str - (misalignment / 2);
185 
186     // load 16 bytes and see if we have a null
187     // (aligned loads can never segfault)
188     const __m128i zeroes = _mm_setzero_si128();
189     __m128i data = _mm_load_si128(reinterpret_cast<const __m128i *>(ptr));
190     __m128i comparison = _mm_cmpeq_epi16(data, zeroes);
191     quint32 mask = _mm_movemask_epi8(comparison);
192 
193     // ignore the result prior to the beginning of str
194     mask >>= misalignment;
195 
196     // Have we found something in the first block? Need to handle it now
197     // because of the left shift above.
198     if (mask)
199         return qCountTrailingZeroBits(quint32(mask)) / 2;
200 
201     do {
202         ptr += 8;
203         data = _mm_load_si128(reinterpret_cast<const __m128i *>(ptr));
204 
205         comparison = _mm_cmpeq_epi16(data, zeroes);
206         mask = _mm_movemask_epi8(comparison);
207     } while (mask == 0);
208 
209     // found a null
210     uint idx = qCountTrailingZeroBits(quint32(mask));
211     return ptr - str + idx / 2;
212 #endif
213 
214     if (sizeof(wchar_t) == sizeof(char16_t))
215         return wcslen(reinterpret_cast<const wchar_t *>(str));
216 
217     while (*str++)
218         ++result;
219     return result;
220 }
221 
222 #if !defined(__OPTIMIZE_SIZE__)
223 namespace {
224 template <uint MaxCount> struct UnrollTailLoop
225 {
226     template <typename RetType, typename Functor1, typename Functor2, typename Number>
227     static inline RetType exec(Number count, RetType returnIfExited, Functor1 loopCheck, Functor2 returnIfFailed, Number i = 0)
228     {
229         /* equivalent to:
230          *   while (count--) {
231          *       if (loopCheck(i))
232          *           return returnIfFailed(i);
233          *   }
234          *   return returnIfExited;
235          */
236 
237         if (!count)
238             return returnIfExited;
239 
240         bool check = loopCheck(i);
241         if (check)
242             return returnIfFailed(i);
243 
244         return UnrollTailLoop<MaxCount - 1>::exec(count - 1, returnIfExited, loopCheck, returnIfFailed, i + 1);
245     }
246 
247     template <typename Functor, typename Number>
248     static inline void exec(Number count, Functor code)
249     {
250         /* equivalent to:
251          *   for (Number i = 0; i < count; ++i)
252          *       code(i);
253          */
254         exec(count, 0, [=](Number i) -> bool { code(i); return false; }, [](Number) { return 0; });
255     }
256 };
257 template <> template <typename RetType, typename Functor1, typename Functor2, typename Number>
258 inline RetType UnrollTailLoop<0>::exec(Number, RetType returnIfExited, Functor1, Functor2, Number)
259 {
260     return returnIfExited;
261 }
262 }
263 #endif
264 
265 /*!
266  * \internal
267  *
268  * Searches for character \a c in the string \a str and returns a pointer to
269  * it. Unlike strchr() and wcschr() (but like glibc's strchrnul()), if the
270  * character is not found, this function returns a pointer to the end of the
271  * string -- that is, \c{str.end()}.
272  */
273 const char16_t *QtPrivate::qustrchr(QStringView str, char16_t c) noexcept
274 {
275     const char16_t *n = str.utf16();
276     const char16_t *e = n + str.size();
277 
278 #ifdef __SSE2__
279     bool loops = true;
280     // Using the PMOVMSKB instruction, we get two bits for each character
281     // we compare.
282 #  if defined(__AVX2__) && !defined(__OPTIMIZE_SIZE__)
283     // we're going to read n[0..15] (32 bytes)
284     __m256i mch256 = _mm256_set1_epi32(c | (c << 16));
285     for (const char16_t *next = n + 16; next <= e; n = next, next += 16) {
286         __m256i data = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(n));
287         __m256i result = _mm256_cmpeq_epi16(data, mch256);
288         uint mask = uint(_mm256_movemask_epi8(result));
289         if (mask) {
290             uint idx = qCountTrailingZeroBits(mask);
291             return n + idx / 2;
292         }
293     }
294     loops = false;
295     __m128i mch = _mm256_castsi256_si128(mch256);
296 #  else
297     __m128i mch = _mm_set1_epi32(c | (c << 16));
298 #  endif
299 
300     auto hasMatch = [mch, &n](__m128i data, ushort validityMask) {
301         __m128i result = _mm_cmpeq_epi16(data, mch);
302         uint mask = uint(_mm_movemask_epi8(result));
303         if ((mask & validityMask) == 0)
304             return false;
305         uint idx = qCountTrailingZeroBits(mask);
306         n += idx / 2;
307         return true;
308     };
309 
310     // we're going to read n[0..7] (16 bytes)
311     for (const char16_t *next = n + 8; next <= e; n = next, next += 8) {
312         __m128i data = _mm_loadu_si128(reinterpret_cast<const __m128i *>(n));
313         if (hasMatch(data, 0xffff))
314             return n;
315 
316         if (!loops) {
317             n += 8;
318             break;
319         }
320     }
321 
322 #  if !defined(__OPTIMIZE_SIZE__)
323     // we're going to read n[0..3] (8 bytes)
324     if (e - n > 3) {
325         __m128i data = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(n));
326         if (hasMatch(data, 0xff))
327             return n;
328 
329         n += 4;
330     }
331 
332     return UnrollTailLoop<3>::exec(e - n, e,
333                                    [=](int i) { return n[i] == c; },
334                                    [=](int i) { return n + i; });
335 #  endif
336 #elif defined(__ARM_NEON__) && defined(Q_PROCESSOR_ARM_64) // vaddv is only available on Aarch64
337     const uint16x8_t vmask = { 1, 1 << 1, 1 << 2, 1 << 3, 1 << 4, 1 << 5, 1 << 6, 1 << 7 };
338     const uint16x8_t ch_vec = vdupq_n_u16(c);
339     for (const char16_t *next = n + 8; next <= e; n = next, next += 8) {
340         uint16x8_t data = vld1q_u16(reinterpret_cast<const uint16_t *>(n));
341         uint mask = vaddvq_u16(vandq_u16(vceqq_u16(data, ch_vec), vmask));
342         if (ushort(mask)) {
343             // found a match
344             return n + qCountTrailingZeroBits(mask);
345         }
346     }
347 #endif // aarch64
348 
349     --n;
350     while (++n != e)
351         if (*n == c)
352             return n;
353 
354     return n;
355 }
356 
357 #ifdef __SSE2__
358 // Scans from \a ptr to \a end until \a maskval is non-zero. Returns true if
359 // the no non-zero was found. Returns false and updates \a ptr to point to the
360 // first 16-bit word that has any bit set (note: if the input is 8-bit, \a ptr
361 // may be updated to one byte short).
362 static bool simdTestMask(const char *&ptr, const char *end, quint32 maskval)
363 {
364     auto updatePtr = [&](uint result) {
365         // found a character matching the mask
366         uint idx = qCountTrailingZeroBits(~result);
367         ptr += idx;
368         return false;
369     };
370 
371 #  if defined(__SSE4_1__)
372     __m128i mask;
373     auto updatePtrSimd = [&](__m128i data) {
374         __m128i masked = _mm_and_si128(mask, data);
375         __m128i comparison = _mm_cmpeq_epi16(masked, _mm_setzero_si128());
376         uint result = _mm_movemask_epi8(comparison);
377         return updatePtr(result);
378     };
379 
380 #    if defined(__AVX2__)
381     // AVX2 implementation: test 32 bytes at a time
382     const __m256i mask256 = _mm256_broadcastd_epi32(_mm_cvtsi32_si128(maskval));
383     while (ptr + 32 <= end) {
384         __m256i data = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(ptr));
385         if (!_mm256_testz_si256(mask256, data)) {
386             // found a character matching the mask
387             __m256i masked256 = _mm256_and_si256(mask256, data);
388             __m256i comparison256 = _mm256_cmpeq_epi16(masked256, _mm256_setzero_si256());
389             return updatePtr(_mm256_movemask_epi8(comparison256));
390         }
391         ptr += 32;
392     }
393 
394     mask = _mm256_castsi256_si128(mask256);
395 #    else
396     // SSE 4.1 implementation: test 32 bytes at a time (two 16-byte
397     // comparisons, unrolled)
398     mask = _mm_set1_epi32(maskval);
399     while (ptr + 32 <= end) {
400         __m128i data1 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(ptr));
401         __m128i data2 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(ptr + 16));
402         if (!_mm_testz_si128(mask, data1))
403             return updatePtrSimd(data1);
404 
405         ptr += 16;
406         if (!_mm_testz_si128(mask, data2))
407             return updatePtrSimd(data2);
408         ptr += 16;
409     }
410 #    endif
411 
412     // AVX2 and SSE4.1: final 16-byte comparison
413     if (ptr + 16 <= end) {
414         __m128i data1 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(ptr));
415         if (!_mm_testz_si128(mask, data1))
416             return updatePtrSimd(data1);
417         ptr += 16;
418     }
419 
420     // and final 8-byte comparison
421     if (ptr + 8 <= end) {
422         __m128i data1 = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(ptr));
423         if (!_mm_testz_si128(mask, data1))
424             return updatePtrSimd(data1);
425         ptr += 8;
426     }
427 
428 #  else
429     // SSE2 implementation: test 16 bytes at a time.
430     const __m128i mask = _mm_set1_epi32(maskval);
431     while (ptr + 16 <= end) {
432         __m128i data = _mm_loadu_si128(reinterpret_cast<const __m128i *>(ptr));
433         __m128i masked = _mm_and_si128(mask, data);
434         __m128i comparison = _mm_cmpeq_epi16(masked, _mm_setzero_si128());
435         quint16 result = _mm_movemask_epi8(comparison);
436         if (result != 0xffff)
437             return updatePtr(result);
438         ptr += 16;
439     }
440 
441     // and one 8-byte comparison
442     if (ptr + 8 <= end) {
443         __m128i data = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(ptr));
444         __m128i masked = _mm_and_si128(mask, data);
445         __m128i comparison = _mm_cmpeq_epi16(masked, _mm_setzero_si128());
446         quint8 result = _mm_movemask_epi8(comparison);
447         if (result != 0xff)
448             return updatePtr(result);
449         ptr += 8;
450     }
451 #  endif
452 
453     return true;
454 }
455 
456 static Q_ALWAYS_INLINE __m128i mm_load8_zero_extend(const void *ptr)
457 {
458     const __m128i *dataptr = static_cast<const __m128i *>(ptr);
459 #if defined(__SSE4_1__)
460     // use a MOVQ followed by PMOVZXBW
461     // if AVX2 is present, these should combine into a single VPMOVZXBW instruction
462     __m128i data = _mm_loadl_epi64(dataptr);
463     return _mm_cvtepu8_epi16(data);
464 #  else
465     // use MOVQ followed by PUNPCKLBW
466     __m128i data = _mm_loadl_epi64(dataptr);
467     return _mm_unpacklo_epi8(data, _mm_setzero_si128());
468 #  endif
469 }
470 #endif
471 
472 // Note: ptr on output may be off by one and point to a preceding US-ASCII
473 // character. Usually harmless.
474 bool qt_is_ascii(const char *&ptr, const char *end) noexcept
475 {
476 #if defined(__SSE2__)
477     // Testing for the high bit can be done efficiently with just PMOVMSKB
478 #  if defined(__AVX2__)
479     while (ptr + 32 <= end) {
480         __m256i data = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(ptr));
481         quint32 mask = _mm256_movemask_epi8(data);
482         if (mask) {
483             uint idx = qCountTrailingZeroBits(mask);
484             ptr += idx;
485             return false;
486         }
487         ptr += 32;
488     }
489 #  endif
490     while (ptr + 16 <= end) {
491         __m128i data = _mm_loadu_si128(reinterpret_cast<const __m128i *>(ptr));
492         quint32 mask = _mm_movemask_epi8(data);
493         if (mask) {
494             uint idx = qCountTrailingZeroBits(mask);
495             ptr += idx;
496             return false;
497         }
498         ptr += 16;
499     }
500     if (ptr + 8 <= end) {
501         __m128i data = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(ptr));
502         quint8 mask = _mm_movemask_epi8(data);
503         if (mask) {
504             uint idx = qCountTrailingZeroBits(mask);
505             ptr += idx;
506             return false;
507         }
508         ptr += 8;
509     }
510 #endif
511 
512     while (ptr + 4 <= end) {
513         quint32 data = qFromUnaligned<quint32>(ptr);
514         if (data &= 0x80808080U) {
515 #if Q_BYTE_ORDER == Q_BIG_ENDIAN
516             uint idx = qCountLeadingZeroBits(data);
517 #else
518             uint idx = qCountTrailingZeroBits(data);
519 #endif
520             ptr += idx / 8;
521             return false;
522         }
523         ptr += 4;
524     }
525 
526     while (ptr != end) {
527         if (quint8(*ptr) & 0x80)
528             return false;
529         ++ptr;
530     }
531     return true;
532 }
533 
534 bool QtPrivate::isAscii(QLatin1String s) noexcept
535 {
536     const char *ptr = s.begin();
537     const char *end = s.end();
538 
539     return qt_is_ascii(ptr, end);
540 }
541 
542 static bool isAscii(const QChar *&ptr, const QChar *end)
543 {
544 #ifdef __SSE2__
545     const char *ptr8 = reinterpret_cast<const char *>(ptr);
546     const char *end8 = reinterpret_cast<const char *>(end);
547     bool ok = simdTestMask(ptr8, end8, 0xff80ff80);
548     ptr = reinterpret_cast<const QChar *>(ptr8);
549     if (!ok)
550         return false;
551 #endif
552 
553     while (ptr != end) {
554         if (ptr->unicode() & 0xff80)
555             return false;
556         ++ptr;
557     }
558     return true;
559 }
560 
561 bool QtPrivate::isAscii(QStringView s) noexcept
562 {
563     const QChar *ptr = s.begin();
564     const QChar *end = s.end();
565 
566     return isAscii(ptr, end);
567 }
568 
569 bool QtPrivate::isLatin1(QStringView s) noexcept
570 {
571     const QChar *ptr = s.begin();
572     const QChar *end = s.end();
573 
574 #ifdef __SSE2__
575     const char *ptr8 = reinterpret_cast<const char *>(ptr);
576     const char *end8 = reinterpret_cast<const char *>(end);
577     if (!simdTestMask(ptr8, end8, 0xff00ff00))
578         return false;
579     ptr = reinterpret_cast<const QChar *>(ptr8);
580 #endif
581 
582     while (ptr != end) {
583         if ((*ptr++).unicode() > 0xff)
584             return false;
585     }
586     return true;
587 }
588 
589 bool QtPrivate::isValidUtf16(QStringView s) noexcept
590 {
591     constexpr char32_t InvalidCodePoint = UINT_MAX;
592 
593     QStringIterator i(s);
594     while (i.hasNext()) {
595         const char32_t c = i.next(InvalidCodePoint);
596         if (c == InvalidCodePoint)
597             return false;
598     }
599 
600     return true;
601 }
602 
603 // conversion between Latin 1 and UTF-16
604 Q_CORE_EXPORT void qt_from_latin1(char16_t *dst, const char *str, size_t size) noexcept
605 {
606     /* SIMD:
607      * Unpacking with SSE has been shown to improve performance on recent CPUs
608      * The same method gives no improvement with NEON. On Aarch64, clang will do the vectorization
609      * itself in exactly the same way as one would do it with intrinsics.
610      */
611 #if defined(__SSE2__)
612     const char *e = str + size;
613     qptrdiff offset = 0;
614 
615     // we're going to read str[offset..offset+15] (16 bytes)
616     for ( ; str + offset + 15 < e; offset += 16) {
617         const __m128i chunk = _mm_loadu_si128((const __m128i*)(str + offset)); // load
618 #ifdef __AVX2__
619         // zero extend to an YMM register
620         const __m256i extended = _mm256_cvtepu8_epi16(chunk);
621 
622         // store
623         _mm256_storeu_si256((__m256i*)(dst + offset), extended);
624 #else
625         const __m128i nullMask = _mm_set1_epi32(0);
626 
627         // unpack the first 8 bytes, padding with zeros
628         const __m128i firstHalf = _mm_unpacklo_epi8(chunk, nullMask);
629         _mm_storeu_si128((__m128i*)(dst + offset), firstHalf); // store
630 
631         // unpack the last 8 bytes, padding with zeros
632         const __m128i secondHalf = _mm_unpackhi_epi8 (chunk, nullMask);
633         _mm_storeu_si128((__m128i*)(dst + offset + 8), secondHalf); // store
634 #endif
635     }
636 
637     // we're going to read str[offset..offset+7] (8 bytes)
638     if (str + offset + 7 < e) {
639         const __m128i unpacked = mm_load8_zero_extend(str + offset);
640         _mm_storeu_si128(reinterpret_cast<__m128i *>(dst + offset), unpacked);
641         offset += 8;
642     }
643 
644     size = size % 8;
645     dst += offset;
646     str += offset;
647 #  if !defined(__OPTIMIZE_SIZE__)
648     return UnrollTailLoop<7>::exec(int(size), [=](int i) { dst[i] = (uchar)str[i]; });
649 #  endif
650 #endif
651 #if defined(__mips_dsp)
652     if (size > 20)
653         qt_fromlatin1_mips_asm_unroll8(dst, str, size);
654     else
655         qt_fromlatin1_mips_asm_unroll4(dst, str, size);
656 #else
657     while (size--)
658         *dst++ = (uchar)*str++;
659 #endif
660 }
661 
662 template <bool Checked>
663 static void qt_to_latin1_internal(uchar *dst, const char16_t *src, qsizetype length)
664 {
665 #if defined(__SSE2__)
666     uchar *e = dst + length;
667     qptrdiff offset = 0;
668 
669 #  ifdef __AVX2__
670     const __m256i questionMark256 = _mm256_broadcastw_epi16(_mm_cvtsi32_si128('?'));
671     const __m256i outOfRange256 = _mm256_broadcastw_epi16(_mm_cvtsi32_si128(0x100));
672     const __m128i questionMark = _mm256_castsi256_si128(questionMark256);
673     const __m128i outOfRange = _mm256_castsi256_si128(outOfRange256);
674 #  else
675     const __m128i questionMark = _mm_set1_epi16('?');
676     const __m128i outOfRange = _mm_set1_epi16(0x100);
677 #  endif
678 
679     auto mergeQuestionMarks = [=](__m128i chunk) {
680         // SSE has no compare instruction for unsigned comparison.
681 # ifdef __SSE4_1__
682         // We use an unsigned uc = qMin(uc, 0x100) and then compare for equality.
683         chunk = _mm_min_epu16(chunk, outOfRange);
684         const __m128i offLimitMask = _mm_cmpeq_epi16(chunk, outOfRange);
685         chunk = _mm_blendv_epi8(chunk, questionMark, offLimitMask);
686 # else
687         // The variables must be shiffted + 0x8000 to be compared
688         const __m128i signedBitOffset = _mm_set1_epi16(short(0x8000));
689         const __m128i thresholdMask = _mm_set1_epi16(short(0xff + 0x8000));
690 
691         const __m128i signedChunk = _mm_add_epi16(chunk, signedBitOffset);
692         const __m128i offLimitMask = _mm_cmpgt_epi16(signedChunk, thresholdMask);
693 
694         // offLimitQuestionMark contains '?' for each 16 bits that was off-limit
695         // the 16 bits that were correct contains zeros
696         const __m128i offLimitQuestionMark = _mm_and_si128(offLimitMask, questionMark);
697 
698         // correctBytes contains the bytes that were in limit
699         // the 16 bits that were off limits contains zeros
700         const __m128i correctBytes = _mm_andnot_si128(offLimitMask, chunk);
701 
702         // merge offLimitQuestionMark and correctBytes to have the result
703         chunk = _mm_or_si128(correctBytes, offLimitQuestionMark);
704 
705         Q_UNUSED(outOfRange);
706 # endif
707         return chunk;
708     };
709 
710     // we're going to write to dst[offset..offset+15] (16 bytes)
711     for ( ; dst + offset + 15 < e; offset += 16) {
712 #  if defined(__AVX2__)
713         __m256i chunk = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(src + offset));
714         if (Checked) {
715             // See mergeQuestionMarks lambda above for details
716             chunk = _mm256_min_epu16(chunk, outOfRange256);
717             const __m256i offLimitMask = _mm256_cmpeq_epi16(chunk, outOfRange256);
718             chunk = _mm256_blendv_epi8(chunk, questionMark256, offLimitMask);
719         }
720 
721         const __m128i chunk2 = _mm256_extracti128_si256(chunk, 1);
722         const __m128i chunk1 = _mm256_castsi256_si128(chunk);
723 #  else
724         __m128i chunk1 = _mm_loadu_si128((const __m128i*)(src + offset)); // load
725         if (Checked)
726             chunk1 = mergeQuestionMarks(chunk1);
727 
728         __m128i chunk2 = _mm_loadu_si128((const __m128i*)(src + offset + 8)); // load
729         if (Checked)
730             chunk2 = mergeQuestionMarks(chunk2);
731 #  endif
732 
733         // pack the two vector to 16 x 8bits elements
734         const __m128i result = _mm_packus_epi16(chunk1, chunk2);
735         _mm_storeu_si128((__m128i*)(dst + offset), result); // store
736     }
737 
738 #  if !defined(__OPTIMIZE_SIZE__)
739     // we're going to write to dst[offset..offset+7] (8 bytes)
740     if (dst + offset + 7 < e) {
741         __m128i chunk = _mm_loadu_si128(reinterpret_cast<const __m128i *>(src + offset));
742         if (Checked)
743             chunk = mergeQuestionMarks(chunk);
744 
745         // pack, where the upper half is ignored
746         const __m128i result = _mm_packus_epi16(chunk, chunk);
747         _mm_storel_epi64(reinterpret_cast<__m128i *>(dst + offset), result);
748         offset += 8;
749     }
750 
751     // we're going to write to dst[offset..offset+3] (4 bytes)
752     if (dst + offset + 3 < e) {
753         __m128i chunk = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(src + offset));
754         if (Checked)
755             chunk = mergeQuestionMarks(chunk);
756 
757         // pack, we'll the upper three quarters
758         const __m128i result = _mm_packus_epi16(chunk, chunk);
759         qToUnaligned(_mm_cvtsi128_si32(result), dst + offset);
760         offset += 4;
761     }
762 
763     length = length % 4;
764 #  else
765     length = length % 16;
766 #  endif // optimize size
767 
768     // advance dst, src for tail processing
769     dst += offset;
770     src += offset;
771 
772 #  if !defined(__OPTIMIZE_SIZE__)
773     return UnrollTailLoop<3>::exec(length, [=](int i) {
774         if (Checked)
775             dst[i] = (src[i]>0xff) ? '?' : (uchar) src[i];
776         else
777             dst[i] = src[i];
778     });
779 #  endif
780 #elif defined(__ARM_NEON__)
781     // Refer to the documentation of the SSE2 implementation
782     // this use eactly the same method as for SSE except:
783     // 1) neon has unsigned comparison
784     // 2) packing is done to 64 bits (8 x 8bits component).
785     if (length >= 16) {
786         const int chunkCount = length >> 3; // divided by 8
787         const uint16x8_t questionMark = vdupq_n_u16('?'); // set
788         const uint16x8_t thresholdMask = vdupq_n_u16(0xff); // set
789         for (int i = 0; i < chunkCount; ++i) {
790             uint16x8_t chunk = vld1q_u16((uint16_t *)src); // load
791             src += 8;
792 
793             if (Checked) {
794                 const uint16x8_t offLimitMask = vcgtq_u16(chunk, thresholdMask); // chunk > thresholdMask
795                 const uint16x8_t offLimitQuestionMark = vandq_u16(offLimitMask, questionMark); // offLimitMask & questionMark
796                 const uint16x8_t correctBytes = vbicq_u16(chunk, offLimitMask); // !offLimitMask & chunk
797                 chunk = vorrq_u16(correctBytes, offLimitQuestionMark); // correctBytes | offLimitQuestionMark
798             }
799             const uint8x8_t result = vmovn_u16(chunk); // narrowing move->packing
800             vst1_u8(dst, result); // store
801             dst += 8;
802         }
803         length = length % 8;
804     }
805 #endif
806 #if defined(__mips_dsp)
807     qt_toLatin1_mips_dsp_asm(dst, src, length);
808 #else
809     while (length--) {
810         if (Checked)
811             *dst++ = (*src>0xff) ? '?' : (uchar) *src;
812         else
813             *dst++ = *src;
814         ++src;
815     }
816 #endif
817 }
818 
819 static void qt_to_latin1(uchar *dst, const char16_t *src, qsizetype length)
820 {
821     qt_to_latin1_internal<true>(dst, src, length);
822 }
823 
824 void qt_to_latin1_unchecked(uchar *dst, const char16_t *src, qsizetype length)
825 {
826     qt_to_latin1_internal<false>(dst, src, length);
827 }
828 
829 // Unicode case-insensitive comparison
830 static int ucstricmp(const QChar *a, const QChar *ae, const QChar *b, const QChar *be)
831 {
832     if (a == b)
833         return (ae - be);
834 
835     const QChar *e = ae;
836     if (be - b < ae - a)
837         e = a + (be - b);
838 
839     char32_t alast = 0;
840     char32_t blast = 0;
841     while (a < e) {
842 //         qDebug() << Qt::hex << alast << blast;
843 //         qDebug() << Qt::hex << "*a=" << *a << "alast=" << alast << "folded=" << foldCase (*a, alast);
844 //         qDebug() << Qt::hex << "*b=" << *b << "blast=" << blast << "folded=" << foldCase (*b, blast);
845         int diff = foldCase(a->unicode(), alast) - foldCase(b->unicode(), blast);
846         if ((diff))
847             return diff;
848         ++a;
849         ++b;
850     }
851     if (a == ae) {
852         if (b == be)
853             return 0;
854         return -1;
855     }
856     return 1;
857 }
858 
859 // Case-insensitive comparison between a Unicode string and a QLatin1String
860 static int ucstricmp(const QChar *a, const QChar *ae, const char *b, const char *be)
861 {
862     auto e = ae;
863     if (be - b < ae - a)
864         e = a + (be - b);
865 
866     while (a < e) {
867         int diff = foldCase(a->unicode()) - foldCase(char16_t{uchar(*b)});
868         if ((diff))
869             return diff;
870         ++a;
871         ++b;
872     }
873     if (a == ae) {
874         if (b == be)
875             return 0;
876         return -1;
877     }
878     return 1;
879 }
880 
881 // Case-insensitive comparison between a Unicode string and a UTF-8 string
882 static int ucstricmp8(const char *utf8, const char *utf8end, const QChar *utf16, const QChar *utf16end)
883 {
884     auto src1 = reinterpret_cast<const uchar *>(utf8);
885     auto end1 = reinterpret_cast<const uchar *>(utf8end);
886     QStringIterator src2(utf16, utf16end);
887 
888     while (src1 < end1 && src2.hasNext()) {
889         uint uc1;
890         uint *output = &uc1;
891         uchar b = *src1++;
892         int res = QUtf8Functions::fromUtf8<QUtf8BaseTraits>(b, output, src1, end1);
893         if (res < 0) {
894             // decoding error
895             uc1 = QChar::ReplacementCharacter;
896         } else {
897             uc1 = QChar::toCaseFolded(uc1);
898         }
899 
900         uint uc2 = QChar::toCaseFolded(src2.next());
901         int diff = uc1 - uc2;   // can't underflow
902         if (diff)
903             return diff;
904     }
905 
906     // the shorter string sorts first
907     return (end1 > src1) - int(src2.hasNext());
908 }
909 
910 #if defined(__mips_dsp)
911 // From qstring_mips_dsp_asm.S
912 extern "C" int qt_ucstrncmp_mips_dsp_asm(const char16_t *a,
913                                          const char16_t *b,
914                                          unsigned len);
915 #endif
916 
917 // Unicode case-sensitive compare two same-sized strings
918 static int ucstrncmp(const QChar *a, const QChar *b, size_t l)
919 {
920 #ifdef __OPTIMIZE_SIZE__
921     const QChar *end = a + l;
922     while (a < end) {
923         if (int diff = (int)a->unicode() - (int)b->unicode())
924             return diff;
925         ++a;
926         ++b;
927     }
928     return 0;
929 #else
930 #if defined(__mips_dsp)
931     static_assert(sizeof(uint) == sizeof(size_t));
932     if (l >= 8) {
933         return qt_ucstrncmp_mips_dsp_asm(reinterpret_cast<const char16_t*>(a),
934                                          reinterpret_cast<const char16_t*>(b),
935                                          l);
936     }
937 #endif // __mips_dsp
938 #ifdef __SSE2__
939     const QChar *end = a + l;
940     qptrdiff offset = 0;
941 
942     // Using the PMOVMSKB instruction, we get two bits for each character
943     // we compare.
944     int retval;
945     auto isDifferent = [a, b, &offset, &retval](__m128i a_data, __m128i b_data) {
946         __m128i result = _mm_cmpeq_epi16(a_data, b_data);
947         uint mask = ~uint(_mm_movemask_epi8(result));
948         if (ushort(mask) == 0)
949             return false;
950         uint idx = qCountTrailingZeroBits(mask);
951         retval = a[offset + idx / 2].unicode() - b[offset + idx / 2].unicode();
952         return true;
953     };
954 
955     // we're going to read a[0..15] and b[0..15] (32 bytes)
956     for ( ; end - a >= offset + 16; offset += 16) {
957 #ifdef __AVX2__
958         __m256i a_data = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(a + offset));
959         __m256i b_data = _mm256_loadu_si256(reinterpret_cast<const __m256i *>(b + offset));
960         __m256i result = _mm256_cmpeq_epi16(a_data, b_data);
961         uint mask = _mm256_movemask_epi8(result);
962 #else
963         __m128i a_data1 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(a + offset));
964         __m128i a_data2 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(a + offset + 8));
965         __m128i b_data1 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(b + offset));
966         __m128i b_data2 = _mm_loadu_si128(reinterpret_cast<const __m128i *>(b + offset + 8));
967         __m128i result1 = _mm_cmpeq_epi16(a_data1, b_data1);
968         __m128i result2 = _mm_cmpeq_epi16(a_data2, b_data2);
969         uint mask = _mm_movemask_epi8(result1) | (_mm_movemask_epi8(result2) << 16);
970 #endif
971         mask = ~mask;
972         if (mask) {
973             // found a different character
974             uint idx = qCountTrailingZeroBits(mask);
975             return a[offset + idx / 2].unicode() - b[offset + idx / 2].unicode();
976         }
977     }
978 
979     // we're going to read a[0..7] and b[0..7] (16 bytes)
980     if (end - a >= offset + 8) {
981         __m128i a_data = _mm_loadu_si128(reinterpret_cast<const __m128i *>(a + offset));
982         __m128i b_data = _mm_loadu_si128(reinterpret_cast<const __m128i *>(b + offset));
983         if (isDifferent(a_data, b_data))
984             return retval;
985 
986         offset += 8;
987     }
988 
989     // we're going to read a[0..3] and b[0..3] (8 bytes)
990     if (end - a >= offset + 4) {
991         __m128i a_data = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(a + offset));
992         __m128i b_data = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(b + offset));
993         if (isDifferent(a_data, b_data))
994             return retval;
995 
996         offset += 4;
997     }
998 
999     // reset l
1000     l &= 3;
1001 
1002     const auto lambda = [=](size_t i) -> int {
1003         return a[offset + i].unicode() - b[offset + i].unicode();
1004     };
1005     return UnrollTailLoop<3>::exec(l, 0, lambda, lambda);
1006 #endif
1007 #if defined(__ARM_NEON__) && defined(Q_PROCESSOR_ARM_64) // vaddv is only available on Aarch64
1008     if (l >= 8) {
1009         const QChar *end = a + l;
1010         const uint16x8_t mask = { 1, 1 << 1, 1 << 2, 1 << 3, 1 << 4, 1 << 5, 1 << 6, 1 << 7 };
1011         while (end - a > 7) {
1012             uint16x8_t da = vld1q_u16(reinterpret_cast<const uint16_t *>(a));
1013             uint16x8_t db = vld1q_u16(reinterpret_cast<const uint16_t *>(b));
1014 
1015             uint8_t r = ~(uint8_t)vaddvq_u16(vandq_u16(vceqq_u16(da, db), mask));
1016             if (r) {
1017                 // found a different QChar
1018                 uint idx = qCountTrailingZeroBits(r);
1019                 return (int)a[idx].unicode() - (int)b[idx].unicode();
1020             }
1021             a += 8;
1022             b += 8;
1023         }
1024         l &= 7;
1025     }
1026     const auto lambda = [=](size_t i) -> int {
1027         return a[i].unicode() - b[i].unicode();
1028     };
1029     return UnrollTailLoop<7>::exec(l, 0, lambda, lambda);
1030 #endif // __ARM_NEON__
1031     if (!l)
1032         return 0;
1033 
1034     // check alignment
1035     if ((reinterpret_cast<quintptr>(a) & 2) == (reinterpret_cast<quintptr>(b) & 2)) {
1036         // both addresses have the same alignment
1037         if (reinterpret_cast<quintptr>(a) & 2) {
1038             // both addresses are not aligned to 4-bytes boundaries
1039             // compare the first character
1040             if (*a != *b)
1041                 return a->unicode() - b->unicode();
1042             --l;
1043             ++a;
1044             ++b;
1045 
1046             // now both addresses are 4-bytes aligned
1047         }
1048 
1049         // both addresses are 4-bytes aligned
1050         // do a fast 32-bit comparison
1051         const quint32 *da = reinterpret_cast<const quint32 *>(a);
1052         const quint32 *db = reinterpret_cast<const quint32 *>(b);
1053         const quint32 *e = da + (l >> 1);
1054         for ( ; da != e; ++da, ++db) {
1055             if (*da != *db) {
1056                 a = reinterpret_cast<const QChar *>(da);
1057                 b = reinterpret_cast<const QChar *>(db);
1058                 if (*a != *b)
1059                     return a->unicode() - b->unicode();
1060                 return a[1].unicode() - b[1].unicode();
1061             }
1062         }
1063 
1064         // do we have a tail?
1065         a = reinterpret_cast<const QChar *>(da);
1066         b = reinterpret_cast<const QChar *>(db);
1067         return (l & 1) ? a->unicode() - b->unicode() : 0;
1068     } else {
1069         // one of the addresses isn't 4-byte aligned but the other is
1070         const QChar *e = a + l;
1071         for ( ; a != e; ++a, ++b) {
1072             if (*a != *b)
1073                 return a->unicode() - b->unicode();
1074         }
1075     }
1076     return 0;
1077 #endif
1078 }
1079 
1080 static int ucstrncmp(const QChar *a, const uchar *c, size_t l)
1081 {
1082     const char16_t *uc = reinterpret_cast<const char16_t *>(a);
1083     const char16_t *e = uc + l;
1084 
1085 #ifdef __SSE2__
1086     __m128i nullmask = _mm_setzero_si128();
1087     qptrdiff offset = 0;
1088 
1089 #  if !defined(__OPTIMIZE_SIZE__)
1090     // Using the PMOVMSKB instruction, we get two bits for each character
1091     // we compare.
1092     int retval;
1093     auto isDifferent = [uc, c, &offset, &retval](__m128i a_data, __m128i b_data) {
1094         __m128i result = _mm_cmpeq_epi16(a_data, b_data);
1095         uint mask = ~uint(_mm_movemask_epi8(result));
1096         if (ushort(mask) == 0)
1097             return false;
1098         uint idx = qCountTrailingZeroBits(mask);
1099         retval = uc[offset + idx / 2] - c[offset + idx / 2];
1100         return true;
1101     };
1102 #  endif
1103 
1104     // we're going to read uc[offset..offset+15] (32 bytes)
1105     // and c[offset..offset+15] (16 bytes)
1106     for ( ; uc + offset + 15 < e; offset += 16) {
1107         // similar to fromLatin1_helper:
1108         // load 16 bytes of Latin 1 data
1109         __m128i chunk = _mm_loadu_si128((const __m128i*)(c + offset));
1110 
1111 #  ifdef __AVX2__
1112         // expand Latin 1 data via zero extension
1113         __m256i ldata = _mm256_cvtepu8_epi16(chunk);
1114 
1115         // load UTF-16 data and compare
1116         __m256i ucdata = _mm256_loadu_si256((const __m256i*)(uc + offset));
1117         __m256i result = _mm256_cmpeq_epi16(ldata, ucdata);
1118 
1119         uint mask = ~_mm256_movemask_epi8(result);
1120 #  else
1121         // expand via unpacking
1122         __m128i firstHalf = _mm_unpacklo_epi8(chunk, nullmask);
1123         __m128i secondHalf = _mm_unpackhi_epi8(chunk, nullmask);
1124 
1125         // load UTF-16 data and compare
1126         __m128i ucdata1 = _mm_loadu_si128((const __m128i*)(uc + offset));
1127         __m128i ucdata2 = _mm_loadu_si128((const __m128i*)(uc + offset + 8));
1128         __m128i result1 = _mm_cmpeq_epi16(firstHalf, ucdata1);
1129         __m128i result2 = _mm_cmpeq_epi16(secondHalf, ucdata2);
1130 
1131         uint mask = ~(_mm_movemask_epi8(result1) | _mm_movemask_epi8(result2) << 16);
1132 #  endif
1133         if (mask) {
1134             // found a different character
1135             uint idx = qCountTrailingZeroBits(mask);
1136             return uc[offset + idx / 2] - c[offset + idx / 2];
1137         }
1138     }
1139 
1140 #  if !defined(__OPTIMIZE_SIZE__)
1141     // we'll read uc[offset..offset+7] (16 bytes) and c[offset..offset+7] (8 bytes)
1142     if (uc + offset + 7 < e) {
1143         // same, but we're using an 8-byte load
1144         __m128i secondHalf = mm_load8_zero_extend(c + offset);
1145 
1146         __m128i ucdata = _mm_loadu_si128((const __m128i*)(uc + offset));
1147         if (isDifferent(ucdata, secondHalf))
1148             return retval;
1149 
1150         // still matched
1151         offset += 8;
1152     }
1153 
1154     enum { MaxTailLength = 3 };
1155     // we'll read uc[offset..offset+3] (8 bytes) and c[offset..offset+3] (4 bytes)
1156     if (uc + offset + 3 < e) {
1157         __m128i chunk = _mm_cvtsi32_si128(qFromUnaligned<int>(c + offset));
1158         __m128i secondHalf = _mm_unpacklo_epi8(chunk, nullmask);
1159 
1160         __m128i ucdata = _mm_loadl_epi64(reinterpret_cast<const __m128i *>(uc + offset));
1161         if (isDifferent(ucdata, secondHalf))
1162             return retval;
1163 
1164         // still matched
1165         offset += 4;
1166     }
1167 #  endif // optimize size
1168 
1169     // reset uc and c
1170     uc += offset;
1171     c += offset;
1172 
1173 #  if !defined(__OPTIMIZE_SIZE__)
1174     const auto lambda = [=](size_t i) { return uc[i] - char16_t(c[i]); };
1175     return UnrollTailLoop<MaxTailLength>::exec(e - uc, 0, lambda, lambda);
1176 #  endif
1177 #endif
1178 
1179     while (uc < e) {
1180         int diff = *uc - *c;
1181         if (diff)
1182             return diff;
1183         uc++, c++;
1184     }
1185 
1186     return 0;
1187 }
1188 
1189 template <typename Number>
1190 constexpr int lencmp(Number lhs, Number rhs) noexcept
1191 {
1192     return lhs == rhs ? 0 :
1193            lhs >  rhs ? 1 :
1194            /* else */  -1 ;
1195 }
1196 
1197 // Unicode case-sensitive comparison
1198 static int ucstrcmp(const QChar *a, size_t alen, const QChar *b, size_t blen)
1199 {
1200     if (a == b && alen == blen)
1201         return 0;
1202     const size_t l = qMin(alen, blen);
1203     int cmp = ucstrncmp(a, b, l);
1204     return cmp ? cmp : lencmp(alen, blen);
1205 }
1206 
1207 static int ucstrcmp(const QChar *a, size_t alen, const char *b, size_t blen)
1208 {
1209     const size_t l = qMin(alen, blen);
1210     const int cmp = ucstrncmp(a, reinterpret_cast<const uchar*>(b), l);
1211     return cmp ? cmp : lencmp(alen, blen);
1212 }
1213 
1214 static int latin1nicmp(const char *lhsChar, qsizetype lSize, const char *rhsChar, qsizetype rSize)
1215 {
1216     constexpr uchar latin1Lower[256] = {
1217         0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
1218         0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
1219         0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
1220         0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
1221         0x40,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
1222         0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x5b,0x5c,0x5d,0x5e,0x5f,
1223         0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
1224         0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
1225         0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
1226         0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
1227         0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
1228         0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
1229         // 0xd7 (multiplication sign) and 0xdf (sz ligature) complicate life
1230         0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
1231         0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xd7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xdf,
1232         0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
1233         0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff
1234     };
1235     // We're called with QLatin1String's .data() and .size():
1236     Q_ASSERT(lSize >= 0 && rSize >= 0);
1237     if (!lSize)
1238         return rSize ? -1 : 0;
1239     if (!rSize)
1240         return 1;
1241     const qsizetype size = std::min(lSize, rSize);
1242 
1243     const uchar *lhs = reinterpret_cast<const uchar *>(lhsChar);
1244     const uchar *rhs = reinterpret_cast<const uchar *>(rhsChar);
1245     Q_ASSERT(lhs && rhs); // since both lSize and rSize are positive
1246     for (qsizetype i = 0; i < size; i++) {
1247         Q_ASSERT(lhs[i] && rhs[i]);
1248         if (int res = latin1Lower[lhs[i]] - latin1Lower[rhs[i]])
1249             return res;
1250     }
1251     return lencmp(lSize, rSize);
1252 }
1253 
1254 static int qt_compare_strings(QStringView lhs, QStringView rhs, Qt::CaseSensitivity cs) noexcept
1255 {
1256     if (cs == Qt::CaseSensitive)
1257         return ucstrcmp(lhs.begin(), lhs.size(), rhs.begin(), rhs.size());
1258     else
1259         return ucstricmp(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());
1260 }
1261 
1262 static int qt_compare_strings(QStringView lhs, QLatin1String rhs, Qt::CaseSensitivity cs) noexcept
1263 {
1264     if (cs == Qt::CaseSensitive)
1265         return ucstrcmp(lhs.begin(), lhs.size(), rhs.begin(), rhs.size());
1266     else
1267         return ucstricmp(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());
1268 }
1269 
1270 static int qt_compare_strings(QLatin1String lhs, QStringView rhs, Qt::CaseSensitivity cs) noexcept
1271 {
1272     return -qt_compare_strings(rhs, lhs, cs);
1273 }
1274 
1275 static int qt_compare_strings(QLatin1String lhs, QLatin1String rhs, Qt::CaseSensitivity cs) noexcept
1276 {
1277     if (lhs.isEmpty())
1278         return lencmp(0, rhs.size());
1279     if (cs == Qt::CaseInsensitive)
1280         return latin1nicmp(lhs.data(), lhs.size(), rhs.data(), rhs.size());
1281     const auto l = std::min(lhs.size(), rhs.size());
1282     int r = qstrncmp(lhs.data(), rhs.data(), l);
1283     return r ? r : lencmp(lhs.size(), rhs.size());
1284 }
1285 
1286 /*!
1287     \relates QStringView
1288     \internal
1289     \since 5.10
1290 
1291     Returns an integer that compares to 0 as \a lhs compares to \a rhs.
1292 
1293     If \a cs is Qt::CaseSensitive (the default), the comparison is case-sensitive;
1294     otherwise the comparison is case-insensitive.
1295 
1296     Case-sensitive comparison is based exclusively on the numeric Unicode values
1297     of the characters and is very fast, but is not what a human would expect.
1298     Consider sorting user-visible strings with QString::localeAwareCompare().
1299 
1300     \sa {Comparing Strings}
1301 */
1302 int QtPrivate::compareStrings(QStringView lhs, QStringView rhs, Qt::CaseSensitivity cs) noexcept
1303 {
1304     return qt_compare_strings(lhs, rhs, cs);
1305 }
1306 
1307 /*!
1308     \relates QStringView
1309     \internal
1310     \since 5.10
1311     \overload
1312 
1313     Returns an integer that compares to 0 as \a lhs compares to \a rhs.
1314 
1315     If \a cs is Qt::CaseSensitive (the default), the comparison is case-sensitive;
1316     otherwise the comparison is case-insensitive.
1317 
1318     Case-sensitive comparison is based exclusively on the numeric Unicode values
1319     of the characters and is very fast, but is not what a human would expect.
1320     Consider sorting user-visible strings with QString::localeAwareCompare().
1321 
1322     \sa {Comparing Strings}
1323 */
1324 int QtPrivate::compareStrings(QStringView lhs, QLatin1String rhs, Qt::CaseSensitivity cs) noexcept
1325 {
1326     return qt_compare_strings(lhs, rhs, cs);
1327 }
1328 
1329 /*!
1330     \relates QStringView
1331     \internal
1332     \since 5.10
1333     \overload
1334 
1335     Returns an integer that compares to 0 as \a lhs compares to \a rhs.
1336 
1337     If \a cs is Qt::CaseSensitive (the default), the comparison is case-sensitive;
1338     otherwise the comparison is case-insensitive.
1339 
1340     Case-sensitive comparison is based exclusively on the numeric Unicode values
1341     of the characters and is very fast, but is not what a human would expect.
1342     Consider sorting user-visible strings with QString::localeAwareCompare().
1343 
1344     \sa {Comparing Strings}
1345 */
1346 int QtPrivate::compareStrings(QLatin1String lhs, QStringView rhs, Qt::CaseSensitivity cs) noexcept
1347 {
1348     return qt_compare_strings(lhs, rhs, cs);
1349 }
1350 
1351 /*!
1352     \relates QStringView
1353     \internal
1354     \since 5.10
1355     \overload
1356 
1357     Returns an integer that compares to 0 as \a lhs compares to \a rhs.
1358 
1359     If \a cs is Qt::CaseSensitive (the default), the comparison is case-sensitive;
1360     otherwise the comparison is case-insensitive.
1361 
1362     Case-sensitive comparison is based exclusively on the numeric Latin-1 values
1363     of the characters and is very fast, but is not what a human would expect.
1364     Consider sorting user-visible strings with QString::localeAwareCompare().
1365 
1366     \sa {Comparing Strings}
1367 */
1368 int QtPrivate::compareStrings(QLatin1String lhs, QLatin1String rhs, Qt::CaseSensitivity cs) noexcept
1369 {
1370     return qt_compare_strings(lhs, rhs, cs);
1371 }
1372 
1373 /*!
1374     \relates QStringView
1375     \internal
1376     \since 6.0
1377     \overload
1378 
1379     Returns an integer that compares to 0 as \a lhs compares to \a rhs.
1380 
1381     If \a cs is Qt::CaseSensitive (the default), the comparison is case-sensitive;
1382     otherwise the comparison is case-insensitive.
1383 
1384     Case-sensitive comparison is based exclusively on the numeric values of the
1385     decoded Unicode code points and is very fast, but is not what a human would
1386     expect. Consider sorting user-visible strings with
1387     QString::localeAwareCompare().
1388 */
1389 int QtPrivate::compareStringsUtf8(const char *u8str, qsizetype u8len, QStringView rhs, Qt::CaseSensitivity cs) noexcept
1390 {
1391     if (cs == Qt::CaseSensitive)
1392         return QUtf8::compareUtf8(u8str, u8len, rhs.data(), rhs.size());
1393     else
1394         return ucstricmp8(u8str, u8str + u8len, rhs.begin(), rhs.end());
1395 }
1396 
1397 #define REHASH(a) \
1398     if (sl_minus_1 < sizeof(std::size_t) * CHAR_BIT)  \
1399         hashHaystack -= std::size_t(a) << sl_minus_1; \
1400     hashHaystack <<= 1
1401 
1402 inline bool qIsUpper(char ch)
1403 {
1404     return ch >= 'A' && ch <= 'Z';
1405 }
1406 
1407 inline bool qIsDigit(char ch)
1408 {
1409     return ch >= '0' && ch <= '9';
1410 }
1411 
1412 inline char qToLower(char ch)
1413 {
1414     if (ch >= 'A' && ch <= 'Z')
1415         return ch - 'A' + 'a';
1416     else
1417         return ch;
1418 }
1419 
1420 
1421 /*!
1422   \macro QT_RESTRICTED_CAST_FROM_ASCII
1423   \relates QString
1424 
1425   Defining this macro disables most automatic conversions from source
1426   literals and 8-bit data to unicode QStrings, but allows the use of
1427   the \c{QChar(char)} and \c{QString(const char (&ch)[N]} constructors,
1428   and the \c{QString::operator=(const char (&ch)[N])} assignment operator
1429   giving most of the type-safety benefits of \c QT_NO_CAST_FROM_ASCII
1430   but does not require user code to wrap character and string literals
1431   with QLatin1Char, QLatin1String or similar.
1432 
1433   Using this macro together with source strings outside the 7-bit range,
1434   non-literals, or literals with embedded NUL characters is undefined.
1435 
1436   \sa QT_NO_CAST_FROM_ASCII, QT_NO_CAST_TO_ASCII
1437 */
1438 
1439 /*!
1440   \macro QT_NO_CAST_FROM_ASCII
1441   \relates QString
1442 
1443   Disables automatic conversions from 8-bit strings (char *) to unicode QStrings
1444 
1445   \sa QT_NO_CAST_TO_ASCII, QT_RESTRICTED_CAST_FROM_ASCII, QT_NO_CAST_FROM_BYTEARRAY
1446 */
1447 
1448 /*!
1449   \macro QT_NO_CAST_TO_ASCII
1450   \relates QString
1451 
1452   disables automatic conversion from QString to 8-bit strings (char *)
1453 
1454   \sa QT_NO_CAST_FROM_ASCII, QT_RESTRICTED_CAST_FROM_ASCII, QT_NO_CAST_FROM_BYTEARRAY
1455 */
1456 
1457 /*!
1458   \macro QT_ASCII_CAST_WARNINGS
1459   \internal
1460   \relates QString
1461 
1462   This macro can be defined to force a warning whenever a function is
1463   called that automatically converts between unicode and 8-bit encodings.
1464 
1465   Note: This only works for compilers that support warnings for
1466   deprecated API.
1467 
1468   \sa QT_NO_CAST_TO_ASCII, QT_NO_CAST_FROM_ASCII, QT_RESTRICTED_CAST_FROM_ASCII
1469 */
1470 
1471 /*!
1472     \class QString
1473     \inmodule QtCore
1474     \reentrant
1475 
1476     \brief The QString class provides a Unicode character string.
1477 
1478     \ingroup tools
1479     \ingroup shared
1480     \ingroup string-processing
1481 
1482     QString stores a string of 16-bit \l{QChar}s, where each QChar
1483     corresponds to one UTF-16 code unit. (Unicode characters
1484     with code values above 65535 are stored using surrogate pairs,
1485     i.e., two consecutive \l{QChar}s.)
1486 
1487     \l{Unicode} is an international standard that supports most of the
1488     writing systems in use today. It is a superset of US-ASCII (ANSI
1489     X3.4-1986) and Latin-1 (ISO 8859-1), and all the US-ASCII/Latin-1
1490     characters are available at the same code positions.
1491 
1492     Behind the scenes, QString uses \l{implicit sharing}
1493     (copy-on-write) to reduce memory usage and to avoid the needless
1494     copying of data. This also helps reduce the inherent overhead of
1495     storing 16-bit characters instead of 8-bit characters.
1496 
1497     In addition to QString, Qt also provides the QByteArray class to
1498     store raw bytes and traditional 8-bit '\\0'-terminated strings.
1499     For most purposes, QString is the class you want to use. It is
1500     used throughout the Qt API, and the Unicode support ensures that
1501     your applications will be easy to translate if you want to expand
1502     your application's market at some point. The two main cases where
1503     QByteArray is appropriate are when you need to store raw binary
1504     data, and when memory conservation is critical (like in embedded
1505     systems).
1506 
1507     \tableofcontents
1508 
1509     \section1 Initializing a String
1510 
1511     One way to initialize a QString is simply to pass a \c{const char
1512     *} to its constructor. For example, the following code creates a
1513     QString of size 5 containing the data "Hello":
1514 
1515     \snippet qstring/main.cpp 0
1516 
1517     QString converts the \c{const char *} data into Unicode using the
1518     fromUtf8() function.
1519 
1520     In all of the QString functions that take \c{const char *}
1521     parameters, the \c{const char *} is interpreted as a classic
1522     C-style '\\0'-terminated string encoded in UTF-8. It is legal for
1523     the \c{const char *} parameter to be \nullptr.
1524 
1525     You can also provide string data as an array of \l{QChar}s:
1526 
1527     \snippet qstring/main.cpp 1
1528 
1529     QString makes a deep copy of the QChar data, so you can modify it
1530     later without experiencing side effects. (If for performance
1531     reasons you don't want to take a deep copy of the character data,
1532     use QString::fromRawData() instead.)
1533 
1534     Another approach is to set the size of the string using resize()
1535     and to initialize the data character per character. QString uses
1536     0-based indexes, just like C++ arrays. To access the character at
1537     a particular index position, you can use \l operator[](). On
1538     non-const strings, \l operator[]() returns a reference to a
1539     character that can be used on the left side of an assignment. For
1540     example:
1541 
1542     \snippet qstring/main.cpp 2
1543 
1544     For read-only access, an alternative syntax is to use the at()
1545     function:
1546 
1547     \snippet qstring/main.cpp 3
1548 
1549     The at() function can be faster than \l operator[](), because it
1550     never causes a \l{deep copy} to occur. Alternatively, use the
1551     left(), right(), or mid() functions to extract several characters
1552     at a time.
1553 
1554     A QString can embed '\\0' characters (QChar::Null). The size()
1555     function always returns the size of the whole string, including
1556     embedded '\\0' characters.
1557 
1558     After a call to the resize() function, newly allocated characters
1559     have undefined values. To set all the characters in the string to
1560     a particular value, use the fill() function.
1561 
1562     QString provides dozens of overloads designed to simplify string
1563     usage. For example, if you want to compare a QString with a string
1564     literal, you can write code like this and it will work as expected:
1565 
1566     \snippet qstring/main.cpp 4
1567 
1568     You can also pass string literals to functions that take QStrings
1569     as arguments, invoking the QString(const char *)
1570     constructor. Similarly, you can pass a QString to a function that
1571     takes a \c{const char *} argument using the \l qPrintable() macro
1572     which returns the given QString as a \c{const char *}. This is
1573     equivalent to calling <QString>.toLocal8Bit().constData().
1574 
1575     \section1 Manipulating String Data
1576 
1577     QString provides the following basic functions for modifying the
1578     character data: append(), prepend(), insert(), replace(), and
1579     remove(). For example:
1580 
1581     \snippet qstring/main.cpp 5
1582 
1583     If you are building a QString gradually and know in advance
1584     approximately how many characters the QString will contain, you
1585     can call reserve(), asking QString to preallocate a certain amount
1586     of memory. You can also call capacity() to find out how much
1587     memory QString actually allocated.
1588 
1589     The replace() and remove() functions' first two arguments are the
1590     position from which to start erasing and the number of characters
1591     that should be erased.  If you want to replace all occurrences of
1592     a particular substring with another, use one of the two-parameter
1593     replace() overloads.
1594 
1595     A frequent requirement is to remove whitespace characters from a
1596     string ('\\n', '\\t', ' ', etc.). If you want to remove whitespace
1597     from both ends of a QString, use the trimmed() function. If you
1598     want to remove whitespace from both ends and replace multiple
1599     consecutive whitespaces with a single space character within the
1600     string, use simplified().
1601 
1602     If you want to find all occurrences of a particular character or
1603     substring in a QString, use the indexOf() or lastIndexOf()
1604     functions. The former searches forward starting from a given index
1605     position, the latter searches backward. Both return the index
1606     position of the character or substring if they find it; otherwise,
1607     they return -1.  For example, here is a typical loop that finds all
1608     occurrences of a particular substring:
1609 
1610     \snippet qstring/main.cpp 6
1611 
1612     QString provides many functions for converting numbers into
1613     strings and strings into numbers. See the arg() functions, the
1614     setNum() functions, the number() static functions, and the
1615     toInt(), toDouble(), and similar functions.
1616 
1617     To get an upper- or lowercase version of a string use toUpper() or
1618     toLower().
1619 
1620     Lists of strings are handled by the QStringList class. You can
1621     split a string into a list of strings using the split() function,
1622     and join a list of strings into a single string with an optional
1623     separator using QStringList::join(). You can obtain a list of
1624     strings from a string list that contain a particular substring or
1625     that match a particular QRegularExpression using the QStringList::filter()
1626     function.
1627 
1628     \section1 Querying String Data
1629 
1630     If you want to see if a QString starts or ends with a particular
1631     substring use startsWith() or endsWith(). If you simply want to
1632     check whether a QString contains a particular character or
1633     substring, use the contains() function. If you want to find out
1634     how many times a particular character or substring occurs in the
1635     string, use count().
1636 
1637     To obtain a pointer to the actual character data, call data() or
1638     constData(). These functions return a pointer to the beginning of
1639     the QChar data. The pointer is guaranteed to remain valid until a
1640     non-const function is called on the QString.
1641 
1642     \section2 Comparing Strings
1643 
1644     QStrings can be compared using overloaded operators such as \l
1645     operator<(), \l operator<=(), \l operator==(), \l operator>=(),
1646     and so on.  Note that the comparison is based exclusively on the
1647     numeric Unicode values of the characters. It is very fast, but is
1648     not what a human would expect; the QString::localeAwareCompare()
1649     function is usually a better choice for sorting user-interface
1650     strings, when such a comparison is available.
1651 
1652     On Unix-like platforms (including Linux, \macos and iOS), when Qt
1653     is linked with the ICU library (which it usually is), its
1654     locale-aware sorting is used.  Otherwise, on \macos and iOS, \l
1655     localeAwareCompare() compares according the "Order for sorted
1656     lists" setting in the International preferences panel. On other
1657     Unix-like systems without ICU, the comparison falls back to the
1658     system library's \c strcoll(), falling back when it considers
1659     strings equal to QString's (locale-unaware) comparison, described
1660     above,
1661 
1662     \section1 Converting Between encoded strings data and QString
1663 
1664     QString provides the following three functions that return a
1665     \c{const char *} version of the string as QByteArray: toUtf8(),
1666     toLatin1(), and toLocal8Bit().
1667 
1668     \list
1669     \li toLatin1() returns a Latin-1 (ISO 8859-1) encoded 8-bit string.
1670     \li toUtf8() returns a UTF-8 encoded 8-bit string. UTF-8 is a
1671        superset of US-ASCII (ANSI X3.4-1986) that supports the entire
1672        Unicode character set through multibyte sequences.
1673     \li toLocal8Bit() returns an 8-bit string using the system's local
1674        encoding. This is the same as toUtf8() on Unix systems.
1675     \endlist
1676 
1677     To convert from one of these encodings, QString provides
1678     fromLatin1(), fromUtf8(), and fromLocal8Bit(). Other
1679     encodings are supported through the QStringEncoder and QStringDecoder
1680     classes.
1681 
1682     As mentioned above, QString provides a lot of functions and
1683     operators that make it easy to interoperate with \c{const char *}
1684     strings. But this functionality is a double-edged sword: It makes
1685     QString more convenient to use if all strings are US-ASCII or
1686     Latin-1, but there is always the risk that an implicit conversion
1687     from or to \c{const char *} is done using the wrong 8-bit
1688     encoding. To minimize these risks, you can turn off these implicit
1689     conversions by defining the following two preprocessor symbols:
1690 
1691     \list
1692     \li \c QT_NO_CAST_FROM_ASCII disables automatic conversions from
1693        C string literals and pointers to Unicode.
1694     \li \c QT_RESTRICTED_CAST_FROM_ASCII allows automatic conversions
1695        from C characters and character arrays, but disables automatic
1696        conversions from character pointers to Unicode.
1697     \li \c QT_NO_CAST_TO_ASCII disables automatic conversion from QString
1698        to C strings.
1699     \endlist
1700 
1701     One way to define these preprocessor symbols globally for your
1702     application is to add the following entry to your \l {Creating Project Files}{qmake project file}:
1703 
1704     \snippet code/src_corelib_text_qstring.cpp 0
1705 
1706     You then need to explicitly call fromUtf8(), fromLatin1(),
1707     or fromLocal8Bit() to construct a QString from an
1708     8-bit string, or use the lightweight QLatin1String class, for
1709     example:
1710 
1711     \snippet code/src_corelib_text_qstring.cpp 1
1712 
1713     Similarly, you must call toLatin1(), toUtf8(), or
1714     toLocal8Bit() explicitly to convert the QString to an 8-bit
1715     string.
1716 
1717     \table 100 %
1718     \header
1719     \li Note for C Programmers
1720 
1721     \row
1722     \li
1723     Due to C++'s type system and the fact that QString is
1724     \l{implicitly shared}, QStrings may be treated like \c{int}s or
1725     other basic types. For example:
1726 
1727     \snippet qstring/main.cpp 7
1728 
1729     The \c result variable, is a normal variable allocated on the
1730     stack. When \c return is called, and because we're returning by
1731     value, the copy constructor is called and a copy of the string is
1732     returned. No actual copying takes place thanks to the implicit
1733     sharing.
1734 
1735     \endtable
1736 
1737     \section1 Distinction Between Null and Empty Strings
1738 
1739     For historical reasons, QString distinguishes between a null
1740     string and an empty string. A \e null string is a string that is
1741     initialized using QString's default constructor or by passing
1742     (const char *)0 to the constructor. An \e empty string is any
1743     string with size 0. A null string is always empty, but an empty
1744     string isn't necessarily null:
1745 
1746     \snippet qstring/main.cpp 8
1747 
1748     All functions except isNull() treat null strings the same as empty
1749     strings. For example, toUtf8().constData() returns a valid pointer
1750     (\e not nullptr) to a '\\0' character for a null string. We
1751     recommend that you always use the isEmpty() function and avoid isNull().
1752 
1753     \section1 Argument Formats
1754 
1755     In member functions where an argument \e format can be specified
1756     (e.g., arg(), number()), the argument \e format can be one of the
1757     following:
1758 
1759     \table
1760     \header \li Format \li Meaning
1761     \row \li \c e \li format as [-]9.9e[+|-]999
1762     \row \li \c E \li format as [-]9.9E[+|-]999
1763     \row \li \c f \li format as [-]9.9
1764     \row \li \c g \li use \c e or \c f format, whichever is the most concise
1765     \row \li \c G \li use \c E or \c f format, whichever is the most concise
1766     \endtable
1767 
1768     A \e precision is also specified with the argument \e format. For
1769     the 'e', 'E', and 'f' formats, the \e precision represents the
1770     number of digits \e after the decimal point. For the 'g' and 'G'
1771     formats, the \e precision represents the maximum number of
1772     significant digits (trailing zeroes are omitted).
1773 
1774     \section1 More Efficient String Construction
1775 
1776     Many strings are known at compile time. But the trivial
1777     constructor QString("Hello"), will copy the contents of the string,
1778     treating the contents as Latin-1. To avoid this one can use the
1779     QStringLiteral macro to directly create the required data at compile
1780     time. Constructing a QString out of the literal does then not cause
1781     any overhead at runtime.
1782 
1783     A slightly less efficient way is to use QLatin1String. This class wraps
1784     a C string literal, precalculates it length at compile time and can
1785     then be used for faster comparison with QStrings and conversion to
1786     QStrings than a regular C string literal.
1787 
1788     Using the QString \c{'+'} operator, it is easy to construct a
1789     complex string from multiple substrings. You will often write code
1790     like this:
1791 
1792     \snippet qstring/stringbuilder.cpp 0
1793 
1794     There is nothing wrong with either of these string constructions,
1795     but there are a few hidden inefficiencies. Beginning with Qt 4.6,
1796     you can eliminate them.
1797 
1798     First, multiple uses of the \c{'+'} operator usually means
1799     multiple memory allocations. When concatenating \e{n} substrings,
1800     where \e{n > 2}, there can be as many as \e{n - 1} calls to the
1801     memory allocator.
1802 
1803     In 4.6, an internal template class \c{QStringBuilder} has been
1804     added along with a few helper functions. This class is marked
1805     internal and does not appear in the documentation, because you
1806     aren't meant to instantiate it in your code. Its use will be
1807     automatic, as described below. The class is found in
1808     \c {src/corelib/tools/qstringbuilder.cpp} if you want to have a
1809     look at it.
1810 
1811     \c{QStringBuilder} uses expression templates and reimplements the
1812     \c{'%'} operator so that when you use \c{'%'} for string
1813     concatenation instead of \c{'+'}, multiple substring
1814     concatenations will be postponed until the final result is about
1815     to be assigned to a QString. At this point, the amount of memory
1816     required for the final result is known. The memory allocator is
1817     then called \e{once} to get the required space, and the substrings
1818     are copied into it one by one.
1819 
1820     Additional efficiency is gained by inlining and reduced reference
1821     counting (the QString created from a \c{QStringBuilder} typically
1822     has a ref count of 1, whereas QString::append() needs an extra
1823     test).
1824 
1825     There are two ways you can access this improved method of string
1826     construction. The straightforward way is to include
1827     \c{QStringBuilder} wherever you want to use it, and use the
1828     \c{'%'} operator instead of \c{'+'} when concatenating strings:
1829 
1830     \snippet qstring/stringbuilder.cpp 5
1831 
1832     A more global approach which is the most convenient but
1833     not entirely source compatible, is to this define in your
1834     .pro file:
1835 
1836     \snippet qstring/stringbuilder.cpp 3
1837 
1838     and the \c{'+'} will automatically be performed as the
1839     \c{QStringBuilder} \c{'%'} everywhere.
1840 
1841     \section1 Maximum size and out-of-memory conditions
1842 
1843     In case memory allocation fails, QString will throw a \c std::bad_alloc
1844     exception. Out of memory conditions in the Qt containers are the only case
1845     where Qt will throw exceptions.
1846 
1847     Note that the operating system may impose further limits on applications
1848     holding a lot of allocated memory, especially large, contiguous blocks.
1849     Such considerations, the configuration of such behavior or any mitigation
1850     are outside the scope of the Qt API.
1851 
1852     \sa fromRawData(), QChar, QLatin1String, QByteArray
1853 */
1854 
1855 /*! \typedef QString::ConstIterator
1856 
1857     Qt-style synonym for QString::const_iterator.
1858 */
1859 
1860 /*! \typedef QString::Iterator
1861 
1862     Qt-style synonym for QString::iterator.
1863 */
1864 
1865 /*! \typedef QString::const_iterator
1866 
1867     \sa QString::iterator
1868 */
1869 
1870 /*! \typedef QString::iterator
1871 
1872     \sa QString::const_iterator
1873 */
1874 
1875 /*! \typedef QString::const_reverse_iterator
1876     \since 5.6
1877 
1878     \sa QString::reverse_iterator, QString::const_iterator
1879 */
1880 
1881 /*! \typedef QString::reverse_iterator
1882     \since 5.6
1883 
1884     \sa QString::const_reverse_iterator, QString::iterator
1885 */
1886 
1887 /*!
1888     \typedef QString::size_type
1889 */
1890 
1891 /*!
1892     \typedef QString::difference_type
1893 */
1894 
1895 /*!
1896     \typedef QString::const_reference
1897 */
1898 /*!
1899     \typedef QString::reference
1900 */
1901 
1902 /*!
1903     \typedef QString::const_pointer
1904 
1905     The QString::const_pointer typedef provides an STL-style
1906     const pointer to a QString element (QChar).
1907 */
1908 /*!
1909     \typedef QString::pointer
1910 
1911     The QString::const_pointer typedef provides an STL-style
1912     pointer to a QString element (QChar).
1913 */
1914 
1915 /*!
1916     \typedef QString::value_type
1917 */
1918 
1919 /*! \fn QString::iterator QString::begin()
1920 
1921     Returns an \l{STL-style iterators}{STL-style iterator} pointing to the first character in
1922     the string.
1923 
1924     \sa constBegin(), end()
1925 */
1926 
1927 /*! \fn QString::const_iterator QString::begin() const
1928 
1929     \overload begin()
1930 */
1931 
1932 /*! \fn QString::const_iterator QString::cbegin() const
1933     \since 5.0
1934 
1935     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the first character
1936     in the string.
1937 
1938     \sa begin(), cend()
1939 */
1940 
1941 /*! \fn QString::const_iterator QString::constBegin() const
1942 
1943     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the first character
1944     in the string.
1945 
1946     \sa begin(), constEnd()
1947 */
1948 
1949 /*! \fn QString::iterator QString::end()
1950 
1951     Returns an \l{STL-style iterators}{STL-style iterator} pointing to the imaginary character
1952     after the last character in the string.
1953 
1954     \sa begin(), constEnd()
1955 */
1956 
1957 /*! \fn QString::const_iterator QString::end() const
1958 
1959     \overload end()
1960 */
1961 
1962 /*! \fn QString::const_iterator QString::cend() const
1963     \since 5.0
1964 
1965     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the imaginary
1966     character after the last character in the list.
1967 
1968     \sa cbegin(), end()
1969 */
1970 
1971 /*! \fn QString::const_iterator QString::constEnd() const
1972 
1973     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the imaginary
1974     character after the last character in the list.
1975 
1976     \sa constBegin(), end()
1977 */
1978 
1979 /*! \fn QString::reverse_iterator QString::rbegin()
1980     \since 5.6
1981 
1982     Returns a \l{STL-style iterators}{STL-style} reverse iterator pointing to the first
1983     character in the string, in reverse order.
1984 
1985     \sa begin(), crbegin(), rend()
1986 */
1987 
1988 /*! \fn QString::const_reverse_iterator QString::rbegin() const
1989     \since 5.6
1990     \overload
1991 */
1992 
1993 /*! \fn QString::const_reverse_iterator QString::crbegin() const
1994     \since 5.6
1995 
1996     Returns a const \l{STL-style iterators}{STL-style} reverse iterator pointing to the first
1997     character in the string, in reverse order.
1998 
1999     \sa begin(), rbegin(), rend()
2000 */
2001 
2002 /*! \fn QString::reverse_iterator QString::rend()
2003     \since 5.6
2004 
2005     Returns a \l{STL-style iterators}{STL-style} reverse iterator pointing to one past
2006     the last character in the string, in reverse order.
2007 
2008     \sa end(), crend(), rbegin()
2009 */
2010 
2011 /*! \fn QString::const_reverse_iterator QString::rend() const
2012     \since 5.6
2013     \overload
2014 */
2015 
2016 /*! \fn QString::const_reverse_iterator QString::crend() const
2017     \since 5.6
2018 
2019     Returns a const \l{STL-style iterators}{STL-style} reverse iterator pointing to one
2020     past the last character in the string, in reverse order.
2021 
2022     \sa end(), rend(), rbegin()
2023 */
2024 
2025 /*!
2026     \fn QString::QString()
2027 
2028     Constructs a null string. Null strings are also empty.
2029 
2030     \sa isEmpty()
2031 */
2032 
2033 /*!
2034     \fn QString::QString(QString &&other)
2035 
2036     Move-constructs a QString instance, making it point at the same
2037     object that \a other was pointing to.
2038 
2039     \since 5.2
2040 */
2041 
2042 /*! \fn QString::QString(const char *str)
2043 
2044     Constructs a string initialized with the 8-bit string \a str. The
2045     given const char pointer is converted to Unicode using the
2046     fromUtf8() function.
2047 
2048     You can disable this constructor by defining \c
2049     QT_NO_CAST_FROM_ASCII when you compile your applications. This
2050     can be useful if you want to ensure that all user-visible strings
2051     go through QObject::tr(), for example.
2052 
2053     \note Defining \c QT_RESTRICTED_CAST_FROM_ASCII also disables
2054     this constructor, but enables a \c{QString(const char (&ch)[N])}
2055     constructor instead. Using non-literal input, or input with
2056     embedded NUL characters, or non-7-bit characters is undefined
2057     in this case.
2058 
2059     \sa fromLatin1(), fromLocal8Bit(), fromUtf8(), QT_NO_CAST_FROM_ASCII, QT_RESTRICTED_CAST_FROM_ASCII
2060 */
2061 
2062 /*! \fn QString QString::fromStdString(const std::string &str)
2063 
2064     Returns a copy of the \a str string. The given string is converted
2065     to Unicode using the fromUtf8() function.
2066 
2067     \sa fromLatin1(), fromLocal8Bit(), fromUtf8(), QByteArray::fromStdString()
2068 */
2069 
2070 /*! \fn QString QString::fromStdWString(const std::wstring &str)
2071 
2072     Returns a copy of the \a str string. The given string is assumed
2073     to be encoded in utf16 if the size of wchar_t is 2 bytes (e.g. on
2074     windows) and ucs4 if the size of wchar_t is 4 bytes (most Unix
2075     systems).
2076 
2077     \sa fromUtf16(), fromLatin1(), fromLocal8Bit(), fromUtf8(), fromUcs4(), fromStdU16String(), fromStdU32String()
2078 */
2079 
2080 /*! \fn QString QString::fromWCharArray(const wchar_t *string, qsizetype size)
2081     \since 4.2
2082 
2083     Returns a copy of the \a string, where the encoding of \a string depends on
2084     the size of wchar. If wchar is 4 bytes, the \a string is interpreted as UCS-4,
2085     if wchar is 2 bytes it is interpreted as UTF-16.
2086 
2087     If \a size is -1 (default), the \a string has to be \\0'-terminated.
2088 
2089     \sa fromUtf16(), fromLatin1(), fromLocal8Bit(), fromUtf8(), fromUcs4(), fromStdWString()
2090 */
2091 
2092 /*! \fn std::wstring QString::toStdWString() const
2093 
2094     Returns a std::wstring object with the data contained in this
2095     QString. The std::wstring is encoded in utf16 on platforms where
2096     wchar_t is 2 bytes wide (e.g. windows) and in ucs4 on platforms
2097     where wchar_t is 4 bytes wide (most Unix systems).
2098 
2099     This method is mostly useful to pass a QString to a function
2100     that accepts a std::wstring object.
2101 
2102     \sa utf16(), toLatin1(), toUtf8(), toLocal8Bit(), toStdU16String(), toStdU32String()
2103 */
2104 
2105 qsizetype QString::toUcs4_helper(const ushort *uc, qsizetype length, uint *out)
2106 {
2107     qsizetype count = 0;
2108 
2109     QStringIterator i(QStringView(uc, length));
2110     while (i.hasNext())
2111         out[count++] = i.next();
2112 
2113     return count;
2114 }
2115 
2116 /*! \fn QString::toWCharArray(wchar_t *array) const
2117   \since 4.2
2118 
2119   Fills the \a array with the data contained in this QString object.
2120   The array is encoded in UTF-16 on platforms where
2121   wchar_t is 2 bytes wide (e.g. windows) and in UCS-4 on platforms
2122   where wchar_t is 4 bytes wide (most Unix systems).
2123 
2124   \a array has to be allocated by the caller and contain enough space to
2125   hold the complete string (allocating the array with the same length as the
2126   string is always sufficient).
2127 
2128   This function returns the actual length of the string in \a array.
2129 
2130   \note This function does not append a null character to the array.
2131 
2132   \sa utf16(), toUcs4(), toLatin1(), toUtf8(), toLocal8Bit(), toStdWString(), QStringView::toWCharArray()
2133 */
2134 
2135 /*! \fn QString::QString(const QString &other)
2136 
2137     Constructs a copy of \a other.
2138 
2139     This operation takes \l{constant time}, because QString is
2140     \l{implicitly shared}. This makes returning a QString from a
2141     function very fast. If a shared instance is modified, it will be
2142     copied (copy-on-write), and that takes \l{linear time}.
2143 
2144     \sa operator=()
2145 */
2146 
2147 /*!
2148     Constructs a string initialized with the first \a size characters
2149     of the QChar array \a unicode.
2150 
2151     If \a unicode is 0, a null string is constructed.
2152 
2153     If \a size is negative, \a unicode is assumed to point to a \\0'-terminated
2154     array and its length is determined dynamically. The terminating
2155     null character is not considered part of the string.
2156 
2157     QString makes a deep copy of the string data. The unicode data is copied as
2158     is and the Byte Order Mark is preserved if present.
2159 
2160     \sa fromRawData()
2161 */
2162 QString::QString(const QChar *unicode, qsizetype size)
2163 {
2164     if (!unicode) {
2165         d.clear();
2166     } else {
2167         if (size < 0) {
2168             size = 0;
2169             while (!unicode[size].isNull())
2170                 ++size;
2171         }
2172         if (!size) {
2173             d = DataPointer::fromRawData(&_empty, 0);
2174         } else {
2175             d = DataPointer(Data::allocate(size + 1), size);
2176             memcpy(d.data(), unicode, size * sizeof(QChar));
2177             d.data()[size] = '\0';
2178         }
2179     }
2180 }
2181 
2182 /*!
2183     Constructs a string of the given \a size with every character set
2184     to \a ch.
2185 
2186     \sa fill()
2187 */
2188 QString::QString(qsizetype size, QChar ch)
2189 {
2190     if (size <= 0) {
2191         d = DataPointer::fromRawData(&_empty, 0);
2192     } else {
2193         d = DataPointer(Data::allocate(size + 1), size);
2194         d.data()[size] = '\0';
2195         char16_t *i = d.data() + size;
2196         char16_t *b = d.data();
2197         const char16_t value = ch.unicode();
2198         while (i != b)
2199            *--i = value;
2200     }
2201 }
2202 
2203 /*! \fn QString::QString(qsizetype size, Qt::Initialization)
2204   \internal
2205 
2206   Constructs a string of the given \a size without initializing the
2207   characters. This is only used in \c QStringBuilder::toString().
2208 */
2209 QString::QString(qsizetype size, Qt::Initialization)
2210 {
2211     d = DataPointer(Data::allocate(size + 1), size);
2212     d.data()[size] = '\0';
2213 }
2214 
2215 /*! \fn QString::QString(QLatin1String str)
2216 
2217     Constructs a copy of the Latin-1 string \a str.
2218 
2219     \sa fromLatin1()
2220 */
2221 
2222 /*!
2223     Constructs a string of size 1 containing the character \a ch.
2224 */
2225 QString::QString(QChar ch)
2226 {
2227     d = DataPointer(Data::allocate(2), 1);
2228     d.data()[0] = ch.unicode();
2229     d.data()[1] = '\0';
2230 }
2231 
2232 /*! \fn QString::QString(const QByteArray &ba)
2233 
2234     Constructs a string initialized with the byte array \a ba. The
2235     given byte array is converted to Unicode using fromUtf8(). Stops
2236     copying at the first 0 character, otherwise copies the entire byte
2237     array.
2238 
2239     You can disable this constructor by defining \c
2240     QT_NO_CAST_FROM_ASCII when you compile your applications. This
2241     can be useful if you want to ensure that all user-visible strings
2242     go through QObject::tr(), for example.
2243 
2244     \sa fromLatin1(), fromLocal8Bit(), fromUtf8(), QT_NO_CAST_FROM_ASCII
2245 */
2246 
2247 /*! \fn QString::QString(const Null &)
2248     \internal
2249 */
2250 
2251 /*! \fn QString::QString(QStringPrivate)
2252     \internal
2253 */
2254 
2255 /*! \fn QString &QString::operator=(const QString::Null &)
2256     \internal
2257 */
2258 
2259 /*!
2260   \fn QString::~QString()
2261 
2262     Destroys the string.
2263 */
2264 
2265 
2266 /*! \fn void QString::swap(QString &other)
2267     \since 4.8
2268 
2269     Swaps string \a other with this string. This operation is very fast and
2270     never fails.
2271 */
2272 
2273 /*! \fn void QString::detach()
2274 
2275     \internal
2276 */
2277 
2278 /*! \fn bool QString::isDetached() const
2279 
2280     \internal
2281 */
2282 
2283 /*! \fn bool QString::isSharedWith(const QString &other) const
2284 
2285     \internal
2286 */
2287 
2288 /*!
2289     Sets the size of the string to \a size characters.
2290 
2291     If \a size is greater than the current size, the string is
2292     extended to make it \a size characters long with the extra
2293     characters added to the end. The new characters are uninitialized.
2294 
2295     If \a size is less than the current size, characters are removed
2296     from the end.
2297 
2298     Example:
2299 
2300     \snippet qstring/main.cpp 45
2301 
2302     If you want to append a certain number of identical characters to
2303     the string, use the \l {QString::}{resize(int, QChar)} overload.
2304 
2305     If you want to expand the string so that it reaches a certain
2306     width and fill the new positions with a particular character, use
2307     the leftJustified() function:
2308 
2309     If \a size is negative, it is equivalent to passing zero.
2310 
2311     \snippet qstring/main.cpp 47
2312 
2313     \sa truncate(), reserve()
2314 */
2315 
2316 void QString::resize(qsizetype size)
2317 {
2318     if (size < 0)
2319         size = 0;
2320 
2321     const auto capacityAtEnd = capacity() - d.freeSpaceAtBegin();
2322     if (d->needsDetach() || size > capacityAtEnd)
2323         reallocData(size_t(size) + 1u, d->detachFlags() | Data::GrowsForward);
2324     d.size = size;
2325     if (d->allocatedCapacity())
2326         d.data()[size] = 0;
2327 }
2328 
2329 /*!
2330     \overload
2331     \since 5.7
2332 
2333     Unlike \l {QString::}{resize(int)}, this overload
2334     initializes the new characters to \a fillChar:
2335 
2336     \snippet qstring/main.cpp 46
2337 */
2338 
2339 void QString::resize(qsizetype size, QChar fillChar)
2340 {
2341     const qsizetype oldSize = length();
2342     resize(size);
2343     const qsizetype difference = length() - oldSize;
2344     if (difference > 0)
2345         std::fill_n(d.data() + oldSize, difference, fillChar.unicode());
2346 }
2347 
2348 /*! \fn qsizetype QString::capacity() const
2349 
2350     Returns the maximum number of characters that can be stored in
2351     the string without forcing a reallocation.
2352 
2353     The sole purpose of this function is to provide a means of fine
2354     tuning QString's memory usage. In general, you will rarely ever
2355     need to call this function. If you want to know how many
2356     characters are in the string, call size().
2357 
2358     \note a statically allocated string will report a capacity of 0,
2359     even if it's not empty.
2360 
2361     \sa reserve(), squeeze()
2362 */
2363 
2364 /*!
2365     \fn void QString::reserve(qsizetype size)
2366 
2367     Attempts to allocate memory for at least \a size characters. If
2368     you know in advance how large the string will be, you can call
2369     this function, and if you resize the string often you are likely
2370     to get better performance. If \a size is an underestimate, the
2371     worst that will happen is that the QString will be a bit slower.
2372 
2373     The sole purpose of this function is to provide a means of fine
2374     tuning QString's memory usage. In general, you will rarely ever
2375     need to call this function. If you want to change the size of the
2376     string, call resize().
2377 
2378     This function is useful for code that needs to build up a long
2379     string and wants to avoid repeated reallocation. In this example,
2380     we want to add to the string until some condition is \c true, and
2381     we're fairly sure that size is large enough to make a call to
2382     reserve() worthwhile:
2383 
2384     \snippet qstring/main.cpp 44
2385 
2386     \sa squeeze(), capacity()
2387 */
2388 
2389 /*!
2390     \fn void QString::squeeze()
2391 
2392     Releases any memory not required to store the character data.
2393 
2394     The sole purpose of this function is to provide a means of fine
2395     tuning QString's memory usage. In general, you will rarely ever
2396     need to call this function.
2397 
2398     \sa reserve(), capacity()
2399 */
2400 
2401 void QString::reallocData(size_t alloc, Data::ArrayOptions allocOptions)
2402 {
2403     // there's a case of slow reallocate path where we need to memmove the data
2404     // before a call to ::realloc(), meaning that there's an extra "heavy"
2405     // operation. just prefer ::malloc() branch in this case
2406     const bool slowReallocatePath = d.freeSpaceAtBegin() > 0;
2407 
2408     if (d->needsDetach() || slowReallocatePath) {
2409         DataPointer dd(Data::allocate(alloc, allocOptions), qMin(qsizetype(alloc) - 1, d.size));
2410         if (dd.size > 0)
2411             ::memcpy(dd.data(), d.data(), dd.size * sizeof(QChar));
2412         dd.data()[dd.size] = 0;
2413         d = dd;
2414     } else {
2415         d->reallocate(alloc, allocOptions);
2416     }
2417 }
2418 
2419 void QString::reallocGrowData(size_t alloc, Data::ArrayOptions options)
2420 {
2421     if (d->needsDetach()) {
2422         const auto newSize = qMin(qsizetype(alloc) - 1, d.size);
2423         DataPointer dd(DataPointer::allocateGrow(d, alloc, newSize, options));
2424         dd->copyAppend(d.data(), d.data() + newSize);
2425         dd.data()[dd.size] = 0;
2426         d = dd;
2427     } else {
2428         d->reallocate(alloc, options);
2429     }
2430 }
2431 
2432 /*! \fn void QString::clear()
2433 
2434     Clears the contents of the string and makes it null.
2435 
2436     \sa resize(), isNull()
2437 */
2438 
2439 /*! \fn QString &QString::operator=(const QString &other)
2440 
2441     Assigns \a other to this string and returns a reference to this
2442     string.
2443 */
2444 
2445 QString &QString::operator=(const QString &other) noexcept
2446 {
2447     d = other.d;
2448     return *this;
2449 }
2450 
2451 /*!
2452     \fn QString &QString::operator=(QString &&other)
2453 
2454     Move-assigns \a other to this QString instance.
2455 
2456     \since 5.2
2457 */
2458 
2459 /*! \fn QString &QString::operator=(QLatin1String str)
2460 
2461     \overload operator=()
2462 
2463     Assigns the Latin-1 string \a str to this string.
2464 */
2465 QString &QString::operator=(QLatin1String other)
2466 {
2467     // TODO: check that it is tested
2468     const qsizetype capacityAtEnd = capacity() - d.freeSpaceAtBegin();
2469     if (isDetached() && other.size() <= capacityAtEnd) { // assumes d->alloc == 0 -> !isDetached() (sharedNull)
2470         d.size = other.size();
2471         d.data()[other.size()] = 0;
2472         qt_from_latin1(d.data(), other.latin1(), other.size());
2473     } else {
2474         *this = fromLatin1(other.latin1(), other.size());
2475     }
2476     return *this;
2477 }
2478 
2479 /*! \fn QString &QString::operator=(const QByteArray &ba)
2480 
2481     \overload operator=()
2482 
2483     Assigns \a ba to this string. The byte array is converted to Unicode
2484     using the fromUtf8() function. This function stops conversion at the
2485     first NUL character found, or the end of the \a ba byte array.
2486 
2487     You can disable this operator by defining \c
2488     QT_NO_CAST_FROM_ASCII when you compile your applications. This
2489     can be useful if you want to ensure that all user-visible strings
2490     go through QObject::tr(), for example.
2491 
2492     \sa QT_NO_CAST_FROM_ASCII
2493 */
2494 
2495 /*! \fn QString &QString::operator=(const char *str)
2496 
2497     \overload operator=()
2498 
2499     Assigns \a str to this string. The const char pointer is converted
2500     to Unicode using the fromUtf8() function.
2501 
2502     You can disable this operator by defining \c QT_NO_CAST_FROM_ASCII
2503     or \c QT_RESTRICTED_CAST_FROM_ASCII when you compile your applications.
2504     This can be useful if you want to ensure that all user-visible strings
2505     go through QObject::tr(), for example.
2506 
2507     \sa QT_NO_CAST_FROM_ASCII, QT_RESTRICTED_CAST_FROM_ASCII
2508 */
2509 
2510 /*!
2511     \overload operator=()
2512 
2513     Sets the string to contain the single character \a ch.
2514 */
2515 QString &QString::operator=(QChar ch)
2516 {
2517     const qsizetype capacityAtEnd = capacity() - d.freeSpaceAtBegin();
2518     if (isDetached() && capacityAtEnd >= 1) { // assumes d->alloc == 0 -> !isDetached() (sharedNull)
2519         // re-use existing capacity:
2520         d.data()[0] = ch.unicode();
2521         d.data()[1] = 0;
2522         d.size = 1;
2523     } else {
2524         operator=(QString(ch));
2525     }
2526     return *this;
2527 }
2528 
2529 /*!
2530      \fn QString& QString::insert(qsizetype position, const QString &str)
2531 
2532     Inserts the string \a str at the given index \a position and
2533     returns a reference to this string.
2534 
2535     Example:
2536 
2537     \snippet qstring/main.cpp 26
2538 
2539     If the given \a position is greater than size(), this string is extended.
2540 
2541     \sa append(), prepend(), replace(), remove()
2542 */
2543 
2544 /*!
2545     \fn QString& QString::insert(qsizetype position, QStringView str)
2546     \since 6.0
2547     \overload insert()
2548 
2549     Inserts the string view \a str at the given index \a position and
2550     returns a reference to this string.
2551 
2552     If the given \a position is greater than size(), this string is extended.
2553 */
2554 
2555 
2556 /*!
2557     \fn QString& QString::insert(qsizetype position, const char *str)
2558     \since 5.5
2559     \overload insert()
2560 
2561     Inserts the C string \a str at the given index \a position and
2562     returns a reference to this string.
2563 
2564     If the given \a position is greater than size(), this string is extended.
2565 
2566     This function is not available when \c QT_NO_CAST_FROM_ASCII is
2567     defined.
2568 
2569     \sa QT_NO_CAST_FROM_ASCII
2570 */
2571 
2572 
2573 /*!
2574     \fn QString& QString::insert(qsizetype position, const QByteArray &str)
2575     \since 5.5
2576     \overload insert()
2577 
2578     Inserts the byte array \a str at the given index \a position and
2579     returns a reference to this string.
2580 
2581     If the given \a position is greater than size(), this string is extended.
2582 
2583     This function is not available when \c QT_NO_CAST_FROM_ASCII is
2584     defined.
2585 
2586     \sa QT_NO_CAST_FROM_ASCII
2587 */
2588 
2589 
2590 /*!
2591     \fn QString &QString::insert(qsizetype position, QLatin1String str)
2592     \overload insert()
2593 
2594     Inserts the Latin-1 string \a str at the given index \a position.
2595 */
2596 QString &QString::insert(qsizetype i, QLatin1String str)
2597 {
2598     const char *s = str.latin1();
2599     if (i < 0 || !s || !(*s))
2600         return *this;
2601 
2602     const qsizetype len = str.size();
2603 
2604     // due to the nature of the branch, slow path would only be triggered if
2605     // some other prepend or insert is called - in a scenario with insertions of
2606     // Latin-1 strings only, fast path is always chosen.
2607     if (d.freeSpaceAtBegin() == 0) {  // fast path
2608         if (Q_UNLIKELY(i > size()))
2609             resize(i + len, QLatin1Char(' '));
2610         else
2611             resize(size() + len);
2612 
2613         ::memmove(d.data() + i + len, d.data() + i, (d.size - i - len) * sizeof(QChar));
2614         qt_from_latin1(d.data() + i, s, uint(len));
2615     } else {  // slow path
2616         const auto oldSize = size();
2617         const auto newSize = qMax(i, oldSize) + len;
2618         const bool shouldGrow = d->shouldGrowBeforeInsert(d.begin() + qMin(i, oldSize), len);
2619 
2620         auto flags = d->detachFlags() | Data::GrowsForward;
2621         if (i <= (size() + len) / 4)
2622             flags |= Data::GrowsBackwards;
2623 
2624         // ### optimize me
2625         if (d->needsDetach() || newSize > capacity() || shouldGrow)
2626             reallocGrowData(newSize + 1, flags);
2627 
2628         if (i > oldSize)  // set spaces in the uninitialized gap
2629             d->copyAppend(i - oldSize, u' ');
2630 
2631         d->insert(d.begin() + i, s, s + len);
2632         d.data()[d.size] = '\0';
2633     }
2634     return *this;
2635 }
2636 
2637 /*!
2638     \fn QString& QString::insert(qsizetype position, const QChar *unicode, qsizetype size)
2639     \overload insert()
2640 
2641     Inserts the first \a size characters of the QChar array \a unicode
2642     at the given index \a position in the string.
2643 */
2644 QString& QString::insert(qsizetype i, const QChar *unicode, qsizetype size)
2645 {
2646     if (i < 0 || size <= 0)
2647         return *this;
2648 
2649     const auto s = reinterpret_cast<const char16_t *>(unicode);
2650     if (points_into_range(s, d.data(), d.data() + d.size))
2651         return insert(i, QStringView{QVarLengthArray(s, s + size)});
2652 
2653     const auto oldSize = this->size();
2654     const auto newSize = qMax(i, oldSize) + size;
2655     const bool shouldGrow = d->shouldGrowBeforeInsert(d.begin() + qMin(i, oldSize), size);
2656 
2657     auto flags = d->detachFlags() | Data::GrowsForward;
2658     if (i <= newSize / 4)
2659         flags |= Data::GrowsBackwards;
2660 
2661     // ### optimize me
2662     if (d->needsDetach() || newSize > capacity() || shouldGrow)
2663         reallocGrowData(newSize + 1, flags);
2664 
2665     if (i > oldSize)  // set spaces in the uninitialized gap
2666         d->copyAppend(i - oldSize, u' ');
2667 
2668     d->insert(d.begin() + i, s, s + size);
2669     d.data()[d.size] = '\0';
2670     return *this;
2671 }
2672 
2673 /*!
2674     \fn QString& QString::insert(qsizetype position, QChar ch)
2675     \overload insert()
2676 
2677     Inserts \a ch at the given index \a position in the string.
2678 */
2679 
2680 QString& QString::insert(qsizetype i, QChar ch)
2681 {
2682     if (i < 0)
2683         i += d.size;
2684     if (i < 0)
2685         return *this;
2686 
2687     const auto oldSize = size();
2688     const auto newSize = qMax(i, oldSize) + 1;
2689     const bool shouldGrow = d->shouldGrowBeforeInsert(d.begin() + qMin(i, oldSize), 1);
2690 
2691     auto flags = d->detachFlags() | Data::GrowsForward;
2692     if (i <= newSize / 4)
2693         flags |= Data::GrowsBackwards;
2694 
2695     // ### optimize me
2696     if (d->needsDetach() || newSize > capacity() || shouldGrow)
2697         reallocGrowData(newSize + 1, flags);
2698 
2699     if (i > oldSize)  // set spaces in the uninitialized gap
2700         d->copyAppend(i - oldSize, u' ');
2701 
2702     d->insert(d.begin() + i, 1, ch.unicode());
2703     d.data()[d.size] = '\0';
2704     return *this;
2705 }
2706 
2707 /*!
2708     Appends the string \a str onto the end of this string.
2709 
2710     Example:
2711 
2712     \snippet qstring/main.cpp 9
2713 
2714     This is the same as using the insert() function:
2715 
2716     \snippet qstring/main.cpp 10
2717 
2718     The append() function is typically very fast (\l{constant time}),
2719     because QString preallocates extra space at the end of the string
2720     data so it can grow without reallocating the entire string each
2721     time.
2722 
2723     \sa operator+=(), prepend(), insert()
2724 */
2725 QString &QString::append(const QString &str)
2726 {
2727     if (!str.isNull()) {
2728         if (isNull()) {
2729             operator=(str);
2730         } else {
2731             const bool shouldGrow = d->shouldGrowBeforeInsert(d.end(), str.d.size);
2732             if (d->needsDetach() || size() + str.size() > capacity() || shouldGrow)
2733                 reallocGrowData(uint(size() + str.size()) + 1u,
2734                                 d->detachFlags() | Data::GrowsForward);
2735             d->copyAppend(str.d.data(), str.d.data() + str.d.size);
2736             d.data()[d.size] = '\0';
2737         }
2738     }
2739     return *this;
2740 }
2741 
2742 /*!
2743   \overload append()
2744   \since 5.0
2745 
2746   Appends \a len characters from the QChar array \a str to this string.
2747 */
2748 QString &QString::append(const QChar *str, qsizetype len)
2749 {
2750     if (str && len > 0) {
2751         const bool shouldGrow = d->shouldGrowBeforeInsert(d.end(), len);
2752         if (d->needsDetach() || size() + len > capacity() || shouldGrow)
2753             reallocGrowData(uint(size() + len) + 1u, d->detachFlags() | Data::GrowsForward);
2754         static_assert(sizeof(QChar) == sizeof(char16_t), "Unexpected difference in sizes");
2755         // the following should be safe as QChar uses char16_t as underlying data
2756         const char16_t *char16String = reinterpret_cast<const char16_t *>(str);
2757         d->copyAppend(char16String, char16String + len);
2758         d.data()[d.size] = '\0';
2759     }
2760     return *this;
2761 }
2762 
2763 /*!
2764   \overload append()
2765 
2766   Appends the Latin-1 string \a str to this string.
2767 */
2768 QString &QString::append(QLatin1String str)
2769 {
2770     const char *s = str.latin1();
2771     if (s) {
2772         qsizetype len = str.size();
2773         const bool shouldGrow = d->shouldGrowBeforeInsert(d.end(), len);
2774         if (d->needsDetach() || size() + len > capacity() || shouldGrow)
2775             reallocGrowData(uint(size() + len) + 1u, d->detachFlags() | Data::GrowsForward);
2776 
2777         if (d.freeSpaceAtBegin() == 0) {  // fast path
2778             char16_t *i = d.data() + d.size;
2779             qt_from_latin1(i, s, uint(len));
2780             d.size += len;
2781         } else {  // slow path
2782             d->copyAppend(s, s + len);
2783         }
2784         d.data()[d.size] = '\0';
2785     }
2786     return *this;
2787 }
2788 
2789 /*! \fn QString &QString::append(const QByteArray &ba)
2790 
2791     \overload append()
2792 
2793     Appends the byte array \a ba to this string. The given byte array
2794     is converted to Unicode using the fromUtf8() function.
2795 
2796     You can disable this function by defining \c QT_NO_CAST_FROM_ASCII
2797     when you compile your applications. This can be useful if you want
2798     to ensure that all user-visible strings go through QObject::tr(),
2799     for example.
2800 
2801     \sa QT_NO_CAST_FROM_ASCII
2802 */
2803 
2804 /*! \fn QString &QString::append(const char *str)
2805 
2806     \overload append()
2807 
2808     Appends the string \a str to this string. The given const char
2809     pointer is converted to Unicode using the fromUtf8() function.
2810 
2811     You can disable this function by defining \c QT_NO_CAST_FROM_ASCII
2812     when you compile your applications. This can be useful if you want
2813     to ensure that all user-visible strings go through QObject::tr(),
2814     for example.
2815 
2816     \sa QT_NO_CAST_FROM_ASCII
2817 */
2818 
2819 /*!
2820     \overload append()
2821 
2822     Appends the character \a ch to this string.
2823 */
2824 QString &QString::append(QChar ch)
2825 {
2826     const bool shouldGrow = d->shouldGrowBeforeInsert(d.end(), 1);
2827     if (d->needsDetach() || size() + 1 > capacity() || shouldGrow)
2828         reallocGrowData(d.size + 2u, d->detachFlags() | Data::GrowsForward);
2829     d->copyAppend(1, ch.unicode());
2830     d.data()[d.size] = '\0';
2831     return *this;
2832 }
2833 
2834 /*! \fn QString &QString::prepend(const QString &str)
2835 
2836     Prepends the string \a str to the beginning of this string and
2837     returns a reference to this string.
2838 
2839     Example:
2840 
2841     \snippet qstring/main.cpp 36
2842 
2843     \sa append(), insert()
2844 */
2845 
2846 /*! \fn QString &QString::prepend(QLatin1String str)
2847 
2848     \overload prepend()
2849 
2850     Prepends the Latin-1 string \a str to this string.
2851 */
2852 
2853 /*! \fn QString &QString::prepend(const QChar *str, qsizetype len)
2854     \since 5.5
2855     \overload prepend()
2856 
2857     Prepends \a len characters from the QChar array \a str to this string and
2858     returns a reference to this string.
2859 */
2860 
2861 /*! \fn QString &QString::prepend(QStringView str)
2862     \since 6.0
2863     \overload prepend()
2864 
2865     Prepends the string view \a str to the beginning of this string and
2866     returns a reference to this string.
2867 */
2868 
2869 /*! \fn QString &QString::prepend(const QByteArray &ba)
2870 
2871     \overload prepend()
2872 
2873     Prepends the byte array \a ba to this string. The byte array is
2874     converted to Unicode using the fromUtf8() function.
2875 
2876     You can disable this function by defining \c
2877     QT_NO_CAST_FROM_ASCII when you compile your applications. This
2878     can be useful if you want to ensure that all user-visible strings
2879     go through QObject::tr(), for example.
2880 
2881     \sa QT_NO_CAST_FROM_ASCII
2882 */
2883 
2884 /*! \fn QString &QString::prepend(const char *str)
2885 
2886     \overload prepend()
2887 
2888     Prepends the string \a str to this string. The const char pointer
2889     is converted to Unicode using the fromUtf8() function.
2890 
2891     You can disable this function by defining \c
2892     QT_NO_CAST_FROM_ASCII when you compile your applications. This
2893     can be useful if you want to ensure that all user-visible strings
2894     go through QObject::tr(), for example.
2895 
2896     \sa QT_NO_CAST_FROM_ASCII
2897 */
2898 
2899 /*! \fn QString &QString::prepend(QChar ch)
2900 
2901     \overload prepend()
2902 
2903     Prepends the character \a ch to this string.
2904 */
2905 
2906 /*!
2907   \fn QString &QString::remove(qsizetype position, qsizetype n)
2908 
2909   Removes \a n characters from the string, starting at the given \a
2910   position index, and returns a reference to the string.
2911 
2912   If the specified \a position index is within the string, but \a
2913   position + \a n is beyond the end of the string, the string is
2914   truncated at the specified \a position.
2915 
2916   \snippet qstring/main.cpp 37
2917 
2918   \sa insert(), replace()
2919 */
2920 QString &QString::remove(qsizetype pos, qsizetype len)
2921 {
2922     if (pos < 0)  // count from end of string
2923         pos += size();
2924     if (size_t(pos) >= size_t(size())) {
2925         // range problems
2926     } else if (len >= size() - pos) {
2927         resize(pos); // truncate
2928     } else if (len > 0) {
2929         detach();
2930 #if 0
2931         d->erase(d.begin() + pos, d.begin() + pos + len);
2932         d.data()[d.size] = '\0';
2933 #else
2934         memmove(d.data() + pos, d.data() + pos + len,
2935                 (d.size - pos - len + 1) * sizeof(QChar));
2936         d.size -= len;
2937 #endif
2938     }
2939     return *this;
2940 }
2941 
2942 template<typename T>
2943 static void removeStringImpl(QString &s, const T &needle, Qt::CaseSensitivity cs)
2944 {
2945     const auto needleSize = needle.size();
2946     if (!needleSize)
2947         return;
2948 
2949     // avoid detach if nothing to do:
2950     qsizetype i = s.indexOf(needle, 0, cs);
2951     if (i < 0)
2952         return;
2953 
2954     const auto beg = s.begin(); // detaches
2955     auto dst = beg + i;
2956     auto src = beg + i + needleSize;
2957     const auto end = s.end();
2958     // loop invariant: [beg, dst[ is partial result
2959     //                 [src, end[ still to be checked for needles
2960     while (src < end) {
2961         const auto i = s.indexOf(needle, src - beg, cs);
2962         const auto hit = i == -1 ? end : beg + i;
2963         const auto skipped = hit - src;
2964         memmove(dst, src, skipped * sizeof(QChar));
2965         dst += skipped;
2966         src = hit + needleSize;
2967     }
2968     s.truncate(dst - beg);
2969 }
2970 
2971 /*!
2972   Removes every occurrence of the given \a str string in this
2973   string, and returns a reference to this string.
2974 
2975   If \a cs is Qt::CaseSensitive (default), the search is
2976   case sensitive; otherwise the search is case insensitive.
2977 
2978   This is the same as \c replace(str, "", cs).
2979 
2980   \sa replace()
2981 */
2982 QString &QString::remove(const QString &str, Qt::CaseSensitivity cs)
2983 {
2984     const auto s = str.d.data();
2985     if (points_into_range(s, d.data(), d.data() + d.size))
2986         removeStringImpl(*this, QStringView{QVarLengthArray(s, s + str.size())}, cs);
2987     else
2988         removeStringImpl(*this, qToStringViewIgnoringNull(str), cs);
2989     return *this;
2990 }
2991 
2992 /*!
2993   \since 5.11
2994   \overload
2995 
2996   Removes every occurrence of the given \a str string in this
2997   string, and returns a reference to this string.
2998 
2999   If \a cs is Qt::CaseSensitive (default), the search is
3000   case sensitive; otherwise the search is case insensitive.
3001 
3002   This is the same as \c replace(str, "", cs).
3003 
3004   \sa replace()
3005 */
3006 QString &QString::remove(QLatin1String str, Qt::CaseSensitivity cs)
3007 {
3008     removeStringImpl(*this, str, cs);
3009     return *this;
3010 }
3011 
3012 /*!
3013   Removes every occurrence of the character \a ch in this string, and
3014   returns a reference to this string.
3015 
3016   If \a cs is Qt::CaseSensitive (default), the search is case
3017   sensitive; otherwise the search is case insensitive.
3018 
3019   Example:
3020 
3021   \snippet qstring/main.cpp 38
3022 
3023   This is the same as \c replace(ch, "", cs).
3024 
3025   \sa replace()
3026 */
3027 QString &QString::remove(QChar ch, Qt::CaseSensitivity cs)
3028 {
3029     const qsizetype idx = indexOf(ch, 0, cs);
3030     if (idx != -1) {
3031         const auto first = begin(); // implicit detach()
3032         auto last = end();
3033         if (cs == Qt::CaseSensitive) {
3034             last = std::remove(first + idx, last, ch);
3035         } else {
3036             const QChar c = ch.toCaseFolded();
3037             auto caseInsensEqual = [c](QChar x) {
3038                 return c == x.toCaseFolded();
3039             };
3040             last = std::remove_if(first + idx, last, caseInsensEqual);
3041         }
3042         resize(last - first);
3043     }
3044     return *this;
3045 }
3046 
3047 /*!
3048   \fn QString &QString::remove(const QRegularExpression &re)
3049   \since 5.0
3050 
3051   Removes every occurrence of the regular expression \a re in the
3052   string, and returns a reference to the string. For example:
3053 
3054   \snippet qstring/main.cpp 96
3055 
3056   \sa indexOf(), lastIndexOf(), replace()
3057 */
3058 
3059 /*!
3060   \fn QString &QString::replace(qsizetype position, qsizetype n, const QString &after)
3061 
3062   Replaces \a n characters beginning at index \a position with
3063   the string \a after and returns a reference to this string.
3064 
3065   \note If the specified \a position index is within the string,
3066   but \a position + \a n goes outside the strings range,
3067   then \a n will be adjusted to stop at the end of the string.
3068 
3069   Example:
3070 
3071   \snippet qstring/main.cpp 40
3072 
3073   \sa insert(), remove()
3074 */
3075 QString &QString::replace(qsizetype pos, qsizetype len, const QString &after)
3076 {
3077     return replace(pos, len, after.constData(), after.length());
3078 }
3079 
3080 /*!
3081   \fn QString &QString::replace(qsizetype position, qsizetype n, const QChar *unicode, qsizetype size)
3082   \overload replace()
3083   Replaces \a n characters beginning at index \a position with the
3084   first \a size characters of the QChar array \a unicode and returns a
3085   reference to this string.
3086 */
3087 QString &QString::replace(qsizetype pos, qsizetype len, const QChar *unicode, qsizetype size)
3088 {
3089     if (size_t(pos) > size_t(this->size()))
3090         return *this;
3091     if (len > this->size() - pos)
3092         len = this->size() - pos;
3093 
3094     size_t index = pos;
3095     replace_helper(&index, 1, len, unicode, size);
3096     return *this;
3097 }
3098 
3099 /*!
3100   \fn QString &QString::replace(qsizetype position, qsizetype n, QChar after)
3101   \overload replace()
3102 
3103   Replaces \a n characters beginning at index \a position with the
3104   character \a after and returns a reference to this string.
3105 */
3106 QString &QString::replace(qsizetype pos, qsizetype len, QChar after)
3107 {
3108     return replace(pos, len, &after, 1);
3109 }
3110 
3111 /*!
3112   \overload replace()
3113   Replaces every occurrence of the string \a before with the string \a
3114   after and returns a reference to this string.
3115 
3116   If \a cs is Qt::CaseSensitive (default), the search is case
3117   sensitive; otherwise the search is case insensitive.
3118 
3119   Example:
3120 
3121   \snippet qstring/main.cpp 41
3122 
3123   \note The replacement text is not rescanned after it is inserted.
3124 
3125   Example:
3126 
3127   \snippet qstring/main.cpp 86
3128 */
3129 QString &QString::replace(const QString &before, const QString &after, Qt::CaseSensitivity cs)
3130 {
3131     return replace(before.constData(), before.size(), after.constData(), after.size(), cs);
3132 }
3133 
3134 namespace { // helpers for replace and its helper:
3135 QChar *textCopy(const QChar *start, qsizetype len)
3136 {
3137     const size_t size = len * sizeof(QChar);
3138     QChar *const copy = static_cast<QChar *>(::malloc(size));
3139     Q_CHECK_PTR(copy);
3140     ::memcpy(copy, start, size);
3141     return copy;
3142 }
3143 
3144 static bool pointsIntoRange(const QChar *ptr, const char16_t *base, qsizetype len)
3145 {
3146     const QChar *const start = reinterpret_cast<const QChar *>(base);
3147     const std::less<const QChar *> less;
3148     return !less(ptr, start) && less(ptr, start + len);
3149 }
3150 } // end namespace
3151 
3152 /*!
3153   \internal
3154  */
3155 void QString::replace_helper(size_t *indices, qsizetype nIndices, qsizetype blen, const QChar *after, qsizetype alen)
3156 {
3157     // Copy after if it lies inside our own d.b area (which we could
3158     // possibly invalidate via a realloc or modify by replacement).
3159     QChar *afterBuffer = nullptr;
3160     if (pointsIntoRange(after, d.data(), d.size)) // Use copy in place of vulnerable original:
3161         after = afterBuffer = textCopy(after, alen);
3162 
3163     QT_TRY {
3164         if (blen == alen) {
3165             // replace in place
3166             detach();
3167             for (qsizetype i = 0; i < nIndices; ++i)
3168                 memcpy(d.data() + indices[i], after, alen * sizeof(QChar));
3169         } else if (alen < blen) {
3170             // replace from front
3171             detach();
3172             size_t to = indices[0];
3173             if (alen)
3174                 memcpy(d.data()+to, after, alen*sizeof(QChar));
3175             to += alen;
3176             size_t movestart = indices[0] + blen;
3177             for (qsizetype i = 1; i < nIndices; ++i) {
3178                 qsizetype msize = indices[i] - movestart;
3179                 if (msize > 0) {
3180                     memmove(d.data() + to, d.data() + movestart, msize * sizeof(QChar));
3181                     to += msize;
3182                 }
3183                 if (alen) {
3184                     memcpy(d.data() + to, after, alen * sizeof(QChar));
3185                     to += alen;
3186                 }
3187                 movestart = indices[i] + blen;
3188             }
3189             qsizetype msize = d.size - movestart;
3190             if (msize > 0)
3191                 memmove(d.data() + to, d.data() + movestart, msize * sizeof(QChar));
3192             resize(d.size - nIndices*(blen-alen));
3193         } else {
3194             // replace from back
3195             qsizetype adjust = nIndices*(alen-blen);
3196             qsizetype newLen = d.size + adjust;
3197             qsizetype moveend = d.size;
3198             resize(newLen);
3199 
3200             while (nIndices) {
3201                 --nIndices;
3202                 qsizetype movestart = indices[nIndices] + blen;
3203                 qsizetype insertstart = indices[nIndices] + nIndices*(alen-blen);
3204                 qsizetype moveto = insertstart + alen;
3205                 memmove(d.data() + moveto, d.data() + movestart,
3206                         (moveend - movestart)*sizeof(QChar));
3207                 memcpy(d.data() + insertstart, after, alen * sizeof(QChar));
3208                 moveend = movestart-blen;
3209             }
3210         }
3211     } QT_CATCH(const std::bad_alloc &) {
3212         ::free(afterBuffer);
3213         QT_RETHROW;
3214     }
3215     ::free(afterBuffer);
3216 }
3217 
3218 /*!
3219   \since 4.5
3220   \overload replace()
3221 
3222   Replaces each occurrence in this string of the first \a blen
3223   characters of \a before with the first \a alen characters of \a
3224   after and returns a reference to this string.
3225 
3226   If \a cs is Qt::CaseSensitive (default), the search is case
3227   sensitive; otherwise the search is case insensitive.
3228 */
3229 QString &QString::replace(const QChar *before, qsizetype blen,
3230                           const QChar *after, qsizetype alen,
3231                           Qt::CaseSensitivity cs)
3232 {
3233     if (d.size == 0) {
3234         if (blen)
3235             return *this;
3236     } else {
3237         if (cs == Qt::CaseSensitive && before == after && blen == alen)
3238             return *this;
3239     }
3240     if (alen == 0 && blen == 0)
3241         return *this;
3242 
3243     QStringMatcher matcher(before, blen, cs);
3244     QChar *beforeBuffer = nullptr, *afterBuffer = nullptr;
3245 
3246     qsizetype index = 0;
3247     while (1) {
3248         size_t indices[1024];
3249         size_t pos = 0;
3250         while (pos < 1024) {
3251             index = matcher.indexIn(*this, index);
3252             if (index == -1)
3253                 break;
3254             indices[pos++] = index;
3255             if (blen) // Step over before:
3256                 index += blen;
3257             else // Only count one instance of empty between any two characters:
3258                 index++;
3259         }
3260         if (!pos) // Nothing to replace
3261             break;
3262 
3263         if (Q_UNLIKELY(index != -1)) {
3264             /*
3265               We're about to change data, that before and after might point
3266               into, and we'll need that data for our next batch of indices.
3267             */
3268             if (!afterBuffer && pointsIntoRange(after, d.data(), d.size))
3269                 after = afterBuffer = textCopy(after, alen);
3270 
3271             if (!beforeBuffer && pointsIntoRange(before, d.data(), d.size)) {
3272                 beforeBuffer = textCopy(before, blen);
3273                 matcher = QStringMatcher(beforeBuffer, blen, cs);
3274             }
3275         }
3276 
3277         replace_helper(indices, pos, blen, after, alen);
3278 
3279         if (Q_LIKELY(index == -1)) // Nothing left to replace
3280             break;
3281         // The call to replace_helper just moved what index points at:
3282         index += pos*(alen-blen);
3283     }
3284     ::free(afterBuffer);
3285     ::free(beforeBuffer);
3286 
3287     return *this;
3288 }
3289 
3290 /*!
3291   \overload replace()
3292   Replaces every occurrence of the character \a ch in the string with
3293   \a after and returns a reference to this string.
3294 
3295   If \a cs is Qt::CaseSensitive (default), the search is case
3296   sensitive; otherwise the search is case insensitive.
3297 */
3298 QString& QString::replace(QChar ch, const QString &after, Qt::CaseSensitivity cs)
3299 {
3300     if (after.size() == 0)
3301         return remove(ch, cs);
3302 
3303     if (after.size() == 1)
3304         return replace(ch, after.front(), cs);
3305 
3306     if (size() == 0)
3307         return *this;
3308 
3309     char16_t cc = (cs == Qt::CaseSensitive ? ch.unicode() : ch.toCaseFolded().unicode());
3310 
3311     qsizetype index = 0;
3312     while (1) {
3313         size_t indices[1024];
3314         size_t pos = 0;
3315         if (cs == Qt::CaseSensitive) {
3316             while (pos < 1024 && index < size()) {
3317                 if (d.data()[index] == cc)
3318                     indices[pos++] = index;
3319                 index++;
3320             }
3321         } else {
3322             while (pos < 1024 && index < size()) {
3323                 if (QChar::toCaseFolded(d.data()[index]) == cc)
3324                     indices[pos++] = index;
3325                 index++;
3326             }
3327         }
3328         if (!pos) // Nothing to replace
3329             break;
3330 
3331         replace_helper(indices, pos, 1, after.constData(), after.size());
3332 
3333         if (Q_LIKELY(index == -1)) // Nothing left to replace
3334             break;
3335         // The call to replace_helper just moved what index points at:
3336         index += pos*(after.size() - 1);
3337     }
3338     return *this;
3339 }
3340 
3341 /*!
3342   \overload replace()
3343   Replaces every occurrence of the character \a before with the
3344   character \a after and returns a reference to this string.
3345 
3346   If \a cs is Qt::CaseSensitive (default), the search is case
3347   sensitive; otherwise the search is case insensitive.
3348 */
3349 QString& QString::replace(QChar before, QChar after, Qt::CaseSensitivity cs)
3350 {
3351     if (d.size) {
3352         const qsizetype idx = indexOf(before, 0, cs);
3353         if (idx != -1) {
3354             detach();
3355             const char16_t a = after.unicode();
3356             char16_t *i = d.data();
3357             char16_t *const e = i + d.size;
3358             i += idx;
3359             *i = a;
3360             if (cs == Qt::CaseSensitive) {
3361                 const char16_t b = before.unicode();
3362                 while (++i != e) {
3363                     if (*i == b)
3364                         *i = a;
3365                 }
3366             } else {
3367                 const char16_t b = foldCase(before.unicode());
3368                 while (++i != e) {
3369                     if (foldCase(*i) == b)
3370                         *i = a;
3371                 }
3372             }
3373         }
3374     }
3375     return *this;
3376 }
3377 
3378 /*!
3379   \since 4.5
3380   \overload replace()
3381 
3382   Replaces every occurrence of the string \a before with the string \a
3383   after and returns a reference to this string.
3384 
3385   If \a cs is Qt::CaseSensitive (default), the search is case
3386   sensitive; otherwise the search is case insensitive.
3387 
3388   \note The text is not rescanned after a replacement.
3389 */
3390 QString &QString::replace(QLatin1String before, QLatin1String after, Qt::CaseSensitivity cs)
3391 {
3392     qsizetype alen = after.size();
3393     qsizetype blen = before.size();
3394     QVarLengthArray<char16_t> a(alen);
3395     QVarLengthArray<char16_t> b(blen);
3396     qt_from_latin1(a.data(), after.latin1(), alen);
3397     qt_from_latin1(b.data(), before.latin1(), blen);
3398     return replace((const QChar *)b.data(), blen, (const QChar *)a.data(), alen, cs);
3399 }
3400 
3401 /*!
3402   \since 4.5
3403   \overload replace()
3404 
3405   Replaces every occurrence of the string \a before with the string \a
3406   after and returns a reference to this string.
3407 
3408   If \a cs is Qt::CaseSensitive (default), the search is case
3409   sensitive; otherwise the search is case insensitive.
3410 
3411   \note The text is not rescanned after a replacement.
3412 */
3413 QString &QString::replace(QLatin1String before, const QString &after, Qt::CaseSensitivity cs)
3414 {
3415     qsizetype blen = before.size();
3416     QVarLengthArray<char16_t> b(blen);
3417     qt_from_latin1(b.data(), before.latin1(), blen);
3418     return replace((const QChar *)b.data(), blen, after.constData(), after.d.size, cs);
3419 }
3420 
3421 /*!
3422   \since 4.5
3423   \overload replace()
3424 
3425   Replaces every occurrence of the string \a before with the string \a
3426   after and returns a reference to this string.
3427 
3428   If \a cs is Qt::CaseSensitive (default), the search is case
3429   sensitive; otherwise the search is case insensitive.
3430 
3431   \note The text is not rescanned after a replacement.
3432 */
3433 QString &QString::replace(const QString &before, QLatin1String after, Qt::CaseSensitivity cs)
3434 {
3435     qsizetype alen = after.size();
3436     QVarLengthArray<char16_t> a(alen);
3437     qt_from_latin1(a.data(), after.latin1(), alen);
3438     return replace(before.constData(), before.d.size, (const QChar *)a.data(), alen, cs);
3439 }
3440 
3441 /*!
3442   \since 4.5
3443   \overload replace()
3444 
3445   Replaces every occurrence of the character \a c with the string \a
3446   after and returns a reference to this string.
3447 
3448   If \a cs is Qt::CaseSensitive (default), the search is case
3449   sensitive; otherwise the search is case insensitive.
3450 
3451   \note The text is not rescanned after a replacement.
3452 */
3453 QString &QString::replace(QChar c, QLatin1String after, Qt::CaseSensitivity cs)
3454 {
3455     qsizetype alen = after.size();
3456     QVarLengthArray<char16_t> a(alen);
3457     qt_from_latin1(a.data(), after.latin1(), alen);
3458     return replace(&c, 1, (const QChar *)a.data(), alen, cs);
3459 }
3460 
3461 
3462 /*!
3463   \relates QString
3464   Returns \c true if string \a s1 is equal to string \a s2; otherwise
3465   returns \c false.
3466 
3467   \sa {Comparing Strings}
3468 */
3469 bool operator==(const QString &s1, const QString &s2) noexcept
3470 {
3471     if (s1.d.size != s2.d.size)
3472         return false;
3473 
3474     return qt_compare_strings(s1, s2, Qt::CaseSensitive) == 0;
3475 }
3476 
3477 /*!
3478     \overload operator==()
3479     Returns \c true if this string is equal to \a other; otherwise
3480     returns \c false.
3481 */
3482 bool QString::operator==(QLatin1String other) const noexcept
3483 {
3484     if (size() != other.size())
3485         return false;
3486 
3487     return qt_compare_strings(*this, other, Qt::CaseSensitive) == 0;
3488 }
3489 
3490 /*! \fn bool QString::operator==(const QByteArray &other) const
3491 
3492     \overload operator==()
3493 
3494     The \a other byte array is converted to a QString using the
3495     fromUtf8() function. This function stops conversion at the
3496     first NUL character found, or the end of the byte array.
3497 
3498     You can disable this operator by defining \c
3499     QT_NO_CAST_FROM_ASCII when you compile your applications. This
3500     can be useful if you want to ensure that all user-visible strings
3501     go through QObject::tr(), for example.
3502 
3503     Returns \c true if this string is lexically equal to the parameter
3504     string \a other. Otherwise returns \c false.
3505 
3506     \sa QT_NO_CAST_FROM_ASCII
3507 */
3508 
3509 /*! \fn bool QString::operator==(const char *other) const
3510 
3511     \overload operator==()
3512 
3513     The \a other const char pointer is converted to a QString using
3514     the fromUtf8() function.
3515 
3516     You can disable this operator by defining \c
3517     QT_NO_CAST_FROM_ASCII when you compile your applications. This
3518     can be useful if you want to ensure that all user-visible strings
3519     go through QObject::tr(), for example.
3520 
3521     \sa QT_NO_CAST_FROM_ASCII
3522 */
3523 
3524 /*!
3525    \relates QString
3526     Returns \c true if string \a s1 is lexically less than string
3527     \a s2; otherwise returns \c false.
3528 
3529     \sa {Comparing Strings}
3530 */
3531 bool operator<(const QString &s1, const QString &s2) noexcept
3532 {
3533     return qt_compare_strings(s1, s2, Qt::CaseSensitive) < 0;
3534 }
3535 
3536 /*!
3537    \overload operator<()
3538 
3539     Returns \c true if this string is lexically less than the parameter
3540     string called \a other; otherwise returns \c false.
3541 */
3542 bool QString::operator<(QLatin1String other) const noexcept
3543 {
3544     return qt_compare_strings(*this, other, Qt::CaseSensitive) < 0;
3545 }
3546 
3547 /*! \fn bool QString::operator<(const QByteArray &other) const
3548 
3549     \overload operator<()
3550 
3551     The \a other byte array is converted to a QString using the
3552     fromUtf8() function. If any NUL characters ('\\0') are embedded
3553     in the byte array, they will be included in the transformation.
3554 
3555     You can disable this operator by defining \c
3556     QT_NO_CAST_FROM_ASCII when you compile your applications. This
3557     can be useful if you want to ensure that all user-visible strings
3558     go through QObject::tr(), for example.
3559 
3560     \sa QT_NO_CAST_FROM_ASCII
3561 */
3562 
3563 /*! \fn bool QString::operator<(const char *other) const
3564 
3565     Returns \c true if this string is lexically less than string \a other.
3566     Otherwise returns \c false.
3567 
3568     \overload operator<()
3569 
3570     The \a other const char pointer is converted to a QString using
3571     the fromUtf8() function.
3572 
3573     You can disable this operator by defining \c
3574     QT_NO_CAST_FROM_ASCII when you compile your applications. This
3575     can be useful if you want to ensure that all user-visible strings
3576     go through QObject::tr(), for example.
3577 
3578     \sa QT_NO_CAST_FROM_ASCII
3579 */
3580 
3581 /*! \fn bool operator<=(const QString &s1, const QString &s2)
3582 
3583     \relates QString
3584 
3585     Returns \c true if string \a s1 is lexically less than or equal to
3586     string \a s2; otherwise returns \c false.
3587 
3588     \sa {Comparing Strings}
3589 */
3590 
3591 /*! \fn bool QString::operator<=(QLatin1String other) const
3592 
3593     Returns \c true if this string is lexically less than or equal to
3594     parameter string \a other. Otherwise returns \c false.
3595 
3596     \overload operator<=()
3597 */
3598 
3599 /*! \fn bool QString::operator<=(const QByteArray &other) const
3600 
3601     \overload operator<=()
3602 
3603     The \a other byte array is converted to a QString using the
3604     fromUtf8() function. If any NUL characters ('\\0') are embedded
3605     in the byte array, they will be included in the transformation.
3606 
3607     You can disable this operator by defining \c
3608     QT_NO_CAST_FROM_ASCII when you compile your applications. This
3609     can be useful if you want to ensure that all user-visible strings
3610     go through QObject::tr(), for example.
3611 
3612     \sa QT_NO_CAST_FROM_ASCII
3613 */
3614 
3615 /*! \fn bool QString::operator<=(const char *other) const
3616 
3617     \overload operator<=()
3618 
3619     The \a other const char pointer is converted to a QString using
3620     the fromUtf8() function.
3621 
3622     You can disable this operator by defining \c
3623     QT_NO_CAST_FROM_ASCII when you compile your applications. This
3624     can be useful if you want to ensure that all user-visible strings
3625     go through QObject::tr(), for example.
3626 
3627     \sa QT_NO_CAST_FROM_ASCII
3628 */
3629 
3630 /*! \fn bool operator>(const QString &s1, const QString &s2)
3631     \relates QString
3632 
3633     Returns \c true if string \a s1 is lexically greater than string \a s2;
3634     otherwise returns \c false.
3635 
3636     \sa {Comparing Strings}
3637 */
3638 
3639 /*!
3640    \overload operator>()
3641 
3642     Returns \c true if this string is lexically greater than the parameter
3643     string \a other; otherwise returns \c false.
3644 */
3645 bool QString::operator>(QLatin1String other) const noexcept
3646 {
3647     return qt_compare_strings(*this, other, Qt::CaseSensitive) > 0;
3648 }
3649 
3650 /*! \fn bool QString::operator>(const QByteArray &other) const
3651 
3652     \overload operator>()
3653 
3654     The \a other byte array is converted to a QString using the
3655     fromUtf8() function. If any NUL characters ('\\0') are embedded
3656     in the byte array, they will be included in the transformation.
3657 
3658     You can disable this operator by defining \c
3659     QT_NO_CAST_FROM_ASCII when you compile your applications. This
3660     can be useful if you want to ensure that all user-visible strings
3661     go through QObject::tr(), for example.
3662 
3663     \sa QT_NO_CAST_FROM_ASCII
3664 */
3665 
3666 /*! \fn bool QString::operator>(const char *other) const
3667 
3668     \overload operator>()
3669 
3670     The \a other const char pointer is converted to a QString using
3671     the fromUtf8() function.
3672 
3673     You can disable this operator by defining \c QT_NO_CAST_FROM_ASCII
3674     when you compile your applications. This can be useful if you want
3675     to ensure that all user-visible strings go through QObject::tr(),
3676     for example.
3677 
3678     \sa QT_NO_CAST_FROM_ASCII
3679 */
3680 
3681 /*! \fn bool operator>=(const QString &s1, const QString &s2)
3682     \relates QString
3683 
3684     Returns \c true if string \a s1 is lexically greater than or equal to
3685     string \a s2; otherwise returns \c false.
3686 
3687     \sa {Comparing Strings}
3688 */
3689 
3690 /*! \fn bool QString::operator>=(QLatin1String other) const
3691 
3692     Returns \c true if this string is lexically greater than or equal to parameter
3693     string \a other. Otherwise returns \c false.
3694 
3695     \overload operator>=()
3696 */
3697 
3698 /*! \fn bool QString::operator>=(const QByteArray &other) const
3699 
3700     \overload operator>=()
3701 
3702     The \a other byte array is converted to a QString using the
3703     fromUtf8() function. If any NUL characters ('\\0') are embedded in
3704     the byte array, they will be included in the transformation.
3705 
3706     You can disable this operator by defining \c QT_NO_CAST_FROM_ASCII
3707     when you compile your applications. This can be useful if you want
3708     to ensure that all user-visible strings go through QObject::tr(),
3709     for example.
3710 
3711     \sa QT_NO_CAST_FROM_ASCII
3712 */
3713 
3714 /*! \fn bool QString::operator>=(const char *other) const
3715 
3716     \overload operator>=()
3717 
3718     The \a other const char pointer is converted to a QString using
3719     the fromUtf8() function.
3720 
3721     You can disable this operator by defining \c QT_NO_CAST_FROM_ASCII
3722     when you compile your applications. This can be useful if you want
3723     to ensure that all user-visible strings go through QObject::tr(),
3724     for example.
3725 
3726     \sa QT_NO_CAST_FROM_ASCII
3727 */
3728 
3729 /*! \fn bool operator!=(const QString &s1, const QString &s2)
3730     \relates QString
3731 
3732     Returns \c true if string \a s1 is not equal to string \a s2;
3733     otherwise returns \c false.
3734 
3735     \sa {Comparing Strings}
3736 */
3737 
3738 /*! \fn bool QString::operator!=(QLatin1String other) const
3739 
3740     Returns \c true if this string is not equal to parameter string \a other.
3741     Otherwise returns \c false.
3742 
3743     \overload operator!=()
3744 */
3745 
3746 /*! \fn bool QString::operator!=(const QByteArray &other) const
3747 
3748     \overload operator!=()
3749 
3750     The \a other byte array is converted to a QString using the
3751     fromUtf8() function. If any NUL characters ('\\0') are embedded
3752     in the byte array, they will be included in the transformation.
3753 
3754     You can disable this operator by defining \c QT_NO_CAST_FROM_ASCII
3755     when you compile your applications. This can be useful if you want
3756     to ensure that all user-visible strings go through QObject::tr(),
3757     for example.
3758 
3759     \sa QT_NO_CAST_FROM_ASCII
3760 */
3761 
3762 /*! \fn bool QString::operator!=(const char *other) const
3763 
3764     \overload operator!=()
3765 
3766     The \a other const char pointer is converted to a QString using
3767     the fromUtf8() function.
3768 
3769     You can disable this operator by defining \c
3770     QT_NO_CAST_FROM_ASCII when you compile your applications. This
3771     can be useful if you want to ensure that all user-visible strings
3772     go through QObject::tr(), for example.
3773 
3774     \sa QT_NO_CAST_FROM_ASCII
3775 */
3776 
3777 #if QT_STRINGVIEW_LEVEL < 2
3778 /*!
3779   Returns the index position of the first occurrence of the string \a
3780   str in this string, searching forward from index position \a
3781   from. Returns -1 if \a str is not found.
3782 
3783   If \a cs is Qt::CaseSensitive (default), the search is case
3784   sensitive; otherwise the search is case insensitive.
3785 
3786   Example:
3787 
3788   \snippet qstring/main.cpp 24
3789 
3790   If \a from is -1, the search starts at the last character; if it is
3791   -2, at the next to last character and so on.
3792 
3793   \sa lastIndexOf(), contains(), count()
3794 */
3795 qsizetype QString::indexOf(const QString &str, qsizetype from, Qt::CaseSensitivity cs) const
3796 {
3797     return QtPrivate::findString(QStringView(unicode(), length()), from, QStringView(str.unicode(), str.length()), cs);
3798 }
3799 #endif  // QT_STRINGVIEW_LEVEL < 2
3800 
3801 /*!
3802     \fn qsizetype QString::indexOf(QStringView str, qsizetype from, Qt::CaseSensitivity cs) const
3803     \since 5.14
3804     \overload indexOf()
3805 
3806     Returns the index position of the first occurrence of the string view \a str
3807     in this string, searching forward from index position \a from.
3808     Returns -1 if \a str is not found.
3809 
3810     If \a cs is Qt::CaseSensitive (default), the search is case
3811     sensitive; otherwise the search is case insensitive.
3812 
3813     If \a from is -1, the search starts at the last character; if it is
3814     -2, at the next to last character and so on.
3815 
3816     \sa QStringView::indexOf(), lastIndexOf(), contains(), count()
3817 */
3818 
3819 /*!
3820   \since 4.5
3821   Returns the index position of the first occurrence of the string \a
3822   str in this string, searching forward from index position \a
3823   from. Returns -1 if \a str is not found.
3824 
3825   If \a cs is Qt::CaseSensitive (default), the search is case
3826   sensitive; otherwise the search is case insensitive.
3827 
3828   Example:
3829 
3830   \snippet qstring/main.cpp 24
3831 
3832   If \a from is -1, the search starts at the last character; if it is
3833   -2, at the next to last character and so on.
3834 
3835   \sa lastIndexOf(), contains(), count()
3836 */
3837 
3838 qsizetype QString::indexOf(QLatin1String str, qsizetype from, Qt::CaseSensitivity cs) const
3839 {
3840     return QtPrivate::findString(QStringView(unicode(), size()), from, str, cs);
3841 }
3842 
3843 /*!
3844     \overload indexOf()
3845 
3846     Returns the index position of the first occurrence of the
3847     character \a ch in the string, searching forward from index
3848     position \a from. Returns -1 if \a ch could not be found.
3849 */
3850 qsizetype QString::indexOf(QChar ch, qsizetype from, Qt::CaseSensitivity cs) const
3851 {
3852     return qFindChar(QStringView(unicode(), length()), ch, from, cs);
3853 }
3854 
3855 #if QT_STRINGVIEW_LEVEL < 2
3856 /*!
3857   Returns the index position of the last occurrence of the string \a
3858   str in this string, searching backward from index position \a
3859   from. If \a from is -1 (default), the search starts at the last
3860   character; if \a from is -2, at the next to last character and so
3861   on. Returns -1 if \a str is not found.
3862 
3863   If \a cs is Qt::CaseSensitive (default), the search is case
3864   sensitive; otherwise the search is case insensitive.
3865 
3866   Example:
3867 
3868   \snippet qstring/main.cpp 29
3869 
3870   \sa indexOf(), contains(), count()
3871 */
3872 qsizetype QString::lastIndexOf(const QString &str, qsizetype from, Qt::CaseSensitivity cs) const
3873 {
3874     return QtPrivate::lastIndexOf(QStringView(*this), from, str, cs);
3875 }
3876 
3877 #endif // QT_STRINGVIEW_LEVEL < 2
3878 
3879 /*!
3880   \since 4.5
3881   \overload lastIndexOf()
3882 
3883   Returns the index position of the last occurrence of the string \a
3884   str in this string, searching backward from index position \a
3885   from. If \a from is -1 (default), the search starts at the last
3886   character; if \a from is -2, at the next to last character and so
3887   on. Returns -1 if \a str is not found.
3888 
3889   If \a cs is Qt::CaseSensitive (default), the search is case
3890   sensitive; otherwise the search is case insensitive.
3891 
3892   Example:
3893 
3894   \snippet qstring/main.cpp 29
3895 
3896   \sa indexOf(), contains(), count()
3897 */
3898 qsizetype QString::lastIndexOf(QLatin1String str, qsizetype from, Qt::CaseSensitivity cs) const
3899 {
3900     return QtPrivate::lastIndexOf(*this, from, str, cs);
3901 }
3902 
3903 /*!
3904   \overload lastIndexOf()
3905 
3906   Returns the index position of the last occurrence of the character
3907   \a ch, searching backward from position \a from.
3908 */
3909 qsizetype QString::lastIndexOf(QChar ch, qsizetype from, Qt::CaseSensitivity cs) const
3910 {
3911     return qLastIndexOf(QStringView(*this), ch, from, cs);
3912 }
3913 
3914 /*!
3915   \fn qsizetype QString::lastIndexOf(QStringView str, qsizetype from, Qt::CaseSensitivity cs) const
3916   \since 5.14
3917   \overload lastIndexOf()
3918 
3919   Returns the index position of the last occurrence of the string view \a
3920   str in this string, searching backward from index position \a
3921   from. If \a from is -1 (default), the search starts at the last
3922   character; if \a from is -2, at the next to last character and so
3923   on. Returns -1 if \a str is not found.
3924 
3925   If \a cs is Qt::CaseSensitive (default), the search is case
3926   sensitive; otherwise the search is case insensitive.
3927 
3928   \sa indexOf(), contains(), count()
3929 */
3930 
3931 
3932 #if QT_CONFIG(regularexpression)
3933 struct QStringCapture
3934 {
3935     qsizetype pos;
3936     qsizetype len;
3937     int no;
3938 };
3939 Q_DECLARE_TYPEINFO(QStringCapture, Q_PRIMITIVE_TYPE);
3940 
3941 /*!
3942   \overload replace()
3943   \since 5.0
3944 
3945   Replaces every occurrence of the regular expression \a re in the
3946   string with \a after. Returns a reference to the string. For
3947   example:
3948 
3949   \snippet qstring/main.cpp 87
3950 
3951   For regular expressions containing capturing groups,
3952   occurrences of \b{\\1}, \b{\\2}, ..., in \a after are replaced
3953   with the string captured by the corresponding capturing group.
3954 
3955   \snippet qstring/main.cpp 88
3956 
3957   \sa indexOf(), lastIndexOf(), remove(), QRegularExpression, QRegularExpressionMatch
3958 */
3959 QString &QString::replace(const QRegularExpression &re, const QString &after)
3960 {
3961     if (!re.isValid()) {
3962         qWarning("QString::replace: invalid QRegularExpression object");
3963         return *this;
3964     }
3965 
3966     const QString copy(*this);
3967     QRegularExpressionMatchIterator iterator = re.globalMatch(copy);
3968     if (!iterator.hasNext()) // no matches at all
3969         return *this;
3970 
3971     reallocData(size_t(d.size) + 1u, d->detachFlags());
3972 
3973     qsizetype numCaptures = re.captureCount();
3974 
3975     // 1. build the backreferences list, holding where the backreferences
3976     // are in the replacement string
3977     QList<QStringCapture> backReferences;
3978     const qsizetype al = after.length();
3979     const QChar *ac = after.unicode();
3980 
3981     for (qsizetype i = 0; i < al - 1; i++) {
3982         if (ac[i] == QLatin1Char('\\')) {
3983             int no = ac[i + 1].digitValue();
3984             if (no > 0 && no <= numCaptures) {
3985                 QStringCapture backReference;
3986                 backReference.pos = i;
3987                 backReference.len = 2;
3988 
3989                 if (i < al - 2) {
3990                     int secondDigit = ac[i + 2].digitValue();
3991                     if (secondDigit != -1 && ((no * 10) + secondDigit) <= numCaptures) {
3992                         no = (no * 10) + secondDigit;
3993                         ++backReference.len;
3994                     }
3995                 }
3996 
3997                 backReference.no = no;
3998                 backReferences.append(backReference);
3999             }
4000         }
4001     }
4002 
4003     // 2. iterate on the matches. For every match, copy in chunks
4004     // - the part before the match
4005     // - the after string, with the proper replacements for the backreferences
4006 
4007     qsizetype newLength = 0; // length of the new string, with all the replacements
4008     qsizetype lastEnd = 0;
4009     QList<QStringView> chunks;
4010     const QStringView copyView{ copy }, afterView{ after };
4011     while (iterator.hasNext()) {
4012         QRegularExpressionMatch match = iterator.next();
4013         qsizetype len;
4014         // add the part before the match
4015         len = match.capturedStart() - lastEnd;
4016         if (len > 0) {
4017             chunks << copyView.mid(lastEnd, len);
4018             newLength += len;
4019         }
4020 
4021         lastEnd = 0;
4022         // add the after string, with replacements for the backreferences
4023         for (const QStringCapture &backReference : qAsConst(backReferences)) {
4024             // part of "after" before the backreference
4025             len = backReference.pos - lastEnd;
4026             if (len > 0) {
4027                 chunks << afterView.mid(lastEnd, len);
4028                 newLength += len;
4029             }
4030 
4031             // backreference itself
4032             len = match.capturedLength(backReference.no);
4033             if (len > 0) {
4034                 chunks << copyView.mid(match.capturedStart(backReference.no), len);
4035                 newLength += len;
4036             }
4037 
4038             lastEnd = backReference.pos + backReference.len;
4039         }
4040 
4041         // add the last part of the after string
4042         len = afterView.length() - lastEnd;
4043         if (len > 0) {
4044             chunks << afterView.mid(lastEnd, len);
4045             newLength += len;
4046         }
4047 
4048         lastEnd = match.capturedEnd();
4049     }
4050 
4051     // 3. trailing string after the last match
4052     if (copyView.length() > lastEnd) {
4053         chunks << copyView.mid(lastEnd);
4054         newLength += copyView.length() - lastEnd;
4055     }
4056 
4057     // 4. assemble the chunks together
4058     resize(newLength);
4059     qsizetype i = 0;
4060     QChar *uc = data();
4061     for (const QStringView &chunk : qAsConst(chunks)) {
4062         qsizetype len = chunk.length();
4063         memcpy(uc + i, chunk.constData(), len * sizeof(QChar));
4064         i += len;
4065     }
4066 
4067     return *this;
4068 }
4069 #endif // QT_CONFIG(regularexpression)
4070 
4071 /*!
4072     Returns the number of (potentially overlapping) occurrences of
4073     the string \a str in this string.
4074 
4075     If \a cs is Qt::CaseSensitive (default), the search is
4076     case sensitive; otherwise the search is case insensitive.
4077 
4078     \sa contains(), indexOf()
4079 */
4080 
4081 qsizetype QString::count(const QString &str, Qt::CaseSensitivity cs) const
4082 {
4083     return QtPrivate::count(QStringView(unicode(), size()), QStringView(str.unicode(), str.size()), cs);
4084 }
4085 
4086 /*!
4087     \overload count()
4088 
4089     Returns the number of occurrences of character \a ch in the string.
4090 
4091     If \a cs is Qt::CaseSensitive (default), the search is
4092     case sensitive; otherwise the search is case insensitive.
4093 
4094     \sa contains(), indexOf()
4095 */
4096 
4097 qsizetype QString::count(QChar ch, Qt::CaseSensitivity cs) const
4098 {
4099     return QtPrivate::count(QStringView(unicode(), size()), ch, cs);
4100 }
4101 
4102 /*!
4103     \since 6.0
4104     \overload count()
4105     Returns the number of (potentially overlapping) occurrences of the
4106     string reference \a str in this string.
4107 
4108     If \a cs is Qt::CaseSensitive (default), the search is
4109     case sensitive; otherwise the search is case insensitive.
4110 
4111     \sa contains(), indexOf()
4112 */
4113 qsizetype QString::count(QStringView str, Qt::CaseSensitivity cs) const
4114 {
4115     return QtPrivate::count(*this, str, cs);
4116 }
4117 
4118 #if QT_STRINGVIEW_LEVEL < 2
4119 /*! \fn bool QString::contains(const QString &str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
4120 
4121     Returns \c true if this string contains an occurrence of the string
4122     \a str; otherwise returns \c false.
4123 
4124     If \a cs is Qt::CaseSensitive (default), the search is
4125     case sensitive; otherwise the search is case insensitive.
4126 
4127     Example:
4128     \snippet qstring/main.cpp 17
4129 
4130     \sa indexOf(), count()
4131 */
4132 #endif // QT_STRINGVIEW_LEVEL < 2
4133 
4134 /*! \fn bool QString::contains(QLatin1String str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
4135     \since 5.3
4136 
4137     \overload contains()
4138 
4139     Returns \c true if this string contains an occurrence of the latin-1 string
4140     \a str; otherwise returns \c false.
4141 */
4142 
4143 /*! \fn bool QString::contains(QChar ch, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
4144 
4145     \overload contains()
4146 
4147     Returns \c true if this string contains an occurrence of the
4148     character \a ch; otherwise returns \c false.
4149 */
4150 
4151 /*! \fn bool QString::contains(QStringView str, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
4152     \since 5.14
4153     \overload contains()
4154 
4155     Returns \c true if this string contains an occurrence of the string view
4156     \a str; otherwise returns \c false.
4157 
4158     If \a cs is Qt::CaseSensitive (default), the search is
4159     case sensitive; otherwise the search is case insensitive.
4160 
4161     \sa indexOf(), count()
4162 */
4163 
4164 #if QT_CONFIG(regularexpression)
4165 /*!
4166     \since 5.5
4167 
4168     Returns the index position of the first match of the regular
4169     expression \a re in the string, searching forward from index
4170     position \a from. Returns -1 if \a re didn't match anywhere.
4171 
4172     If the match is successful and \a rmatch is not \nullptr, it also
4173     writes the results of the match into the QRegularExpressionMatch object
4174     pointed to by \a rmatch.
4175 
4176     Example:
4177 
4178     \snippet qstring/main.cpp 93
4179 */
4180 qsizetype QString::indexOf(const QRegularExpression &re, qsizetype from, QRegularExpressionMatch *rmatch) const
4181 {
4182     if (!re.isValid()) {
4183         qWarning("QString::indexOf: invalid QRegularExpression object");
4184         return -1;
4185     }
4186 
4187     QRegularExpressionMatch match = re.match(*this, from);
4188     if (match.hasMatch()) {
4189         const qsizetype ret = match.capturedStart();
4190         if (rmatch)
4191             *rmatch = std::move(match);
4192         return ret;
4193     }
4194 
4195     return -1;
4196 }
4197 
4198 /*!
4199     \since 5.5
4200 
4201     Returns the index position of the last match of the regular
4202     expression \a re in the string, which starts before the index
4203     position \a from. Returns -1 if \a re didn't match anywhere.
4204 
4205     If the match is successful and \a rmatch is not \nullptr, it also
4206     writes the results of the match into the QRegularExpressionMatch object
4207     pointed to by \a rmatch.
4208 
4209     Example:
4210 
4211     \snippet qstring/main.cpp 94
4212 */
4213 qsizetype QString::lastIndexOf(const QRegularExpression &re, qsizetype from, QRegularExpressionMatch *rmatch) const
4214 {
4215     if (!re.isValid()) {
4216         qWarning("QString::lastIndexOf: invalid QRegularExpression object");
4217         return -1;
4218     }
4219 
4220     qsizetype endpos = (from < 0) ? (size() + from + 1) : (from + 1);
4221     QRegularExpressionMatchIterator iterator = re.globalMatch(*this);
4222     qsizetype lastIndex = -1;
4223     while (iterator.hasNext()) {
4224         QRegularExpressionMatch match = iterator.next();
4225         qsizetype start = match.capturedStart();
4226         if (start < endpos) {
4227             lastIndex = start;
4228             if (rmatch)
4229                 *rmatch = std::move(match);
4230         } else {
4231             break;
4232         }
4233     }
4234 
4235     return lastIndex;
4236 }
4237 
4238 /*!
4239     \since 5.1
4240 
4241     Returns \c true if the regular expression \a re matches somewhere in this
4242     string; otherwise returns \c false.
4243 
4244     If the match is successful and \a rmatch is not \nullptr, it also
4245     writes the results of the match into the QRegularExpressionMatch object
4246     pointed to by \a rmatch.
4247 
4248     \sa QRegularExpression::match()
4249 */
4250 
4251 bool QString::contains(const QRegularExpression &re, QRegularExpressionMatch *rmatch) const
4252 {
4253     if (!re.isValid()) {
4254         qWarning("QString::contains: invalid QRegularExpression object");
4255         return false;
4256     }
4257     QRegularExpressionMatch m = re.match(*this);
4258     bool hasMatch = m.hasMatch();
4259     if (hasMatch && rmatch)
4260         *rmatch = std::move(m);
4261     return hasMatch;
4262 }
4263 
4264 /*!
4265     \overload count()
4266     \since 5.0
4267 
4268     Returns the number of times the regular expression \a re matches
4269     in the string.
4270 
4271     This function counts overlapping matches, so in the example
4272     below, there are four instances of "ana" or "ama":
4273 
4274     \snippet qstring/main.cpp 95
4275 */
4276 qsizetype QString::count(const QRegularExpression &re) const
4277 {
4278     if (!re.isValid()) {
4279         qWarning("QString::count: invalid QRegularExpression object");
4280         return 0;
4281     }
4282     qsizetype count = 0;
4283     qsizetype index = -1;
4284     qsizetype len = length();
4285     while (index < len - 1) {
4286         QRegularExpressionMatch match = re.match(*this, index + 1);
4287         if (!match.hasMatch())
4288             break;
4289         index = match.capturedStart();
4290         count++;
4291     }
4292     return count;
4293 }
4294 #endif // QT_CONFIG(regularexpression)
4295 
4296 /*! \fn qsizetype QString::count() const
4297 
4298     \overload count()
4299 
4300     Same as size().
4301 */
4302 
4303 
4304 /*!
4305     \enum QString::SectionFlag
4306 
4307     This enum specifies flags that can be used to affect various
4308     aspects of the section() function's behavior with respect to
4309     separators and empty fields.
4310 
4311     \value SectionDefault Empty fields are counted, leading and
4312     trailing separators are not included, and the separator is
4313     compared case sensitively.
4314 
4315     \value SectionSkipEmpty Treat empty fields as if they don't exist,
4316     i.e. they are not considered as far as \e start and \e end are
4317     concerned.
4318 
4319     \value SectionIncludeLeadingSep Include the leading separator (if
4320     any) in the result string.
4321 
4322     \value SectionIncludeTrailingSep Include the trailing separator
4323     (if any) in the result string.
4324 
4325     \value SectionCaseInsensitiveSeps Compare the separator
4326     case-insensitively.
4327 
4328     \sa section()
4329 */
4330 
4331 /*!
4332     \fn QString QString::section(QChar sep, qsizetype start, qsizetype end = -1, SectionFlags flags) const
4333 
4334     This function returns a section of the string.
4335 
4336     This string is treated as a sequence of fields separated by the
4337     character, \a sep. The returned string consists of the fields from
4338     position \a start to position \a end inclusive. If \a end is not
4339     specified, all fields from position \a start to the end of the
4340     string are included. Fields are numbered 0, 1, 2, etc., counting
4341     from the left, and -1, -2, etc., counting from right to left.
4342 
4343     The \a flags argument can be used to affect some aspects of the
4344     function's behavior, e.g. whether to be case sensitive, whether
4345     to skip empty fields and how to deal with leading and trailing
4346     separators; see \l{SectionFlags}.
4347 
4348     \snippet qstring/main.cpp 52
4349 
4350     If \a start or \a end is negative, we count fields from the right
4351     of the string, the right-most field being -1, the one from
4352     right-most field being -2, and so on.
4353 
4354     \snippet qstring/main.cpp 53
4355 
4356     \sa split()
4357 */
4358 
4359 /*!
4360     \overload section()
4361 
4362     \snippet qstring/main.cpp 51
4363     \snippet qstring/main.cpp 54
4364 
4365     \sa split()
4366 */
4367 
4368 QString QString::section(const QString &sep, qsizetype start, qsizetype end, SectionFlags flags) const
4369 {
4370     const QList<QStringView> sections = QStringView{ *this }.split(
4371             sep, Qt::KeepEmptyParts, (flags & SectionCaseInsensitiveSeps) ? Qt::CaseInsensitive : Qt::CaseSensitive);
4372     const qsizetype sectionsSize = sections.size();
4373     if (!(flags & SectionSkipEmpty)) {
4374         if (start < 0)
4375             start += sectionsSize;
4376         if (end < 0)
4377             end += sectionsSize;
4378     } else {
4379         qsizetype skip = 0;
4380         for (qsizetype k = 0; k < sectionsSize; ++k) {
4381             if (sections.at(k).isEmpty())
4382                 skip++;
4383         }
4384         if (start < 0)
4385             start += sectionsSize - skip;
4386         if (end < 0)
4387             end += sectionsSize - skip;
4388     }
4389     if (start >= sectionsSize || end < 0 || start > end)
4390         return QString();
4391 
4392     QString ret;
4393     qsizetype first_i = start, last_i = end;
4394     for (qsizetype x = 0, i = 0; x <= end && i < sectionsSize; ++i) {
4395         const QStringView &section = sections.at(i);
4396         const bool empty = section.isEmpty();
4397         if (x >= start) {
4398             if(x == start)
4399                 first_i = i;
4400             if(x == end)
4401                 last_i = i;
4402             if (x > start && i > 0)
4403                 ret += sep;
4404             ret += section;
4405         }
4406         if (!empty || !(flags & SectionSkipEmpty))
4407             x++;
4408     }
4409     if ((flags & SectionIncludeLeadingSep) && first_i > 0)
4410         ret.prepend(sep);
4411     if ((flags & SectionIncludeTrailingSep) && last_i < sectionsSize - 1)
4412         ret += sep;
4413     return ret;
4414 }
4415 
4416 #if !(defined(QT_NO_REGEXP) && !QT_CONFIG(regularexpression))
4417 class qt_section_chunk {
4418 public:
4419     qt_section_chunk() {}
4420     qt_section_chunk(qsizetype l, QStringView s) : length(l), string(std::move(s)) {}
4421     qsizetype length;
4422     QStringView string;
4423 };
4424 Q_DECLARE_TYPEINFO(qt_section_chunk, Q_MOVABLE_TYPE);
4425 
4426 static QString extractSections(const QList<qt_section_chunk> &sections, qsizetype start, qsizetype end,
4427                                QString::SectionFlags flags)
4428 {
4429     const qsizetype sectionsSize = sections.size();
4430 
4431     if (!(flags & QString::SectionSkipEmpty)) {
4432         if (start < 0)
4433             start += sectionsSize;
4434         if (end < 0)
4435             end += sectionsSize;
4436     } else {
4437         qsizetype skip = 0;
4438         for (qsizetype k = 0; k < sectionsSize; ++k) {
4439             const qt_section_chunk &section = sections.at(k);
4440             if (section.length == section.string.length())
4441                 skip++;
4442         }
4443         if (start < 0)
4444             start += sectionsSize - skip;
4445         if (end < 0)
4446             end += sectionsSize - skip;
4447     }
4448     if (start >= sectionsSize || end < 0 || start > end)
4449         return QString();
4450 
4451     QString ret;
4452     qsizetype x = 0;
4453     qsizetype first_i = start, last_i = end;
4454     for (qsizetype i = 0; x <= end && i < sectionsSize; ++i) {
4455         const qt_section_chunk &section = sections.at(i);
4456         const bool empty = (section.length == section.string.length());
4457         if (x >= start) {
4458             if (x == start)
4459                 first_i = i;
4460             if (x == end)
4461                 last_i = i;
4462             if (x != start)
4463                 ret += section.string;
4464             else
4465                 ret += section.string.mid(section.length);
4466         }
4467         if (!empty || !(flags & QString::SectionSkipEmpty))
4468             x++;
4469     }
4470 
4471     if ((flags & QString::SectionIncludeLeadingSep) && first_i >= 0) {
4472         const qt_section_chunk &section = sections.at(first_i);
4473         ret.prepend(section.string.left(section.length));
4474     }
4475 
4476     if ((flags & QString::SectionIncludeTrailingSep)
4477         && last_i < sectionsSize - 1) {
4478         const qt_section_chunk &section = sections.at(last_i+1);
4479         ret += section.string.left(section.length);
4480     }
4481 
4482     return ret;
4483 }
4484 #endif
4485 
4486 #if QT_CONFIG(regularexpression)
4487 /*!
4488     \overload section()
4489     \since 5.0
4490 
4491     This string is treated as a sequence of fields separated by the
4492     regular expression, \a re.
4493 
4494     \snippet qstring/main.cpp 89
4495 
4496     \warning Using this QRegularExpression version is much more expensive than
4497     the overloaded string and character versions.
4498 
4499     \sa split(), simplified()
4500 */
4501 QString QString::section(const QRegularExpression &re, qsizetype start, qsizetype end, SectionFlags flags) const
4502 {
4503     if (!re.isValid()) {
4504         qWarning("QString::section: invalid QRegularExpression object");
4505         return QString();
4506     }
4507 
4508     const QChar *uc = unicode();
4509     if (!uc)
4510         return QString();
4511 
4512     QRegularExpression sep(re);
4513     if (flags & SectionCaseInsensitiveSeps)
4514         sep.setPatternOptions(sep.patternOptions() | QRegularExpression::CaseInsensitiveOption);
4515 
4516     QList<qt_section_chunk> sections;
4517     qsizetype n = length(), m = 0, last_m = 0, last_len = 0;
4518     QRegularExpressionMatchIterator iterator = sep.globalMatch(*this);
4519     while (iterator.hasNext()) {
4520         QRegularExpressionMatch match = iterator.next();
4521         m = match.capturedStart();
4522         sections.append(qt_section_chunk(last_len, QStringView{ *this }.mid(last_m, m - last_m)));
4523         last_m = m;
4524         last_len = match.capturedLength();
4525     }
4526     sections.append(qt_section_chunk(last_len, QStringView{ *this }.mid(last_m, n - last_m)));
4527 
4528     return extractSections(sections, start, end, flags);
4529 }
4530 #endif // QT_CONFIG(regularexpression)
4531 
4532 /*!
4533     Returns a substring that contains the \a n leftmost characters
4534     of the string.
4535 
4536     \obsolete Use first() instead in new code.
4537 
4538     The entire string is returned if \a n is greater than or equal
4539     to size(), or less than zero.
4540 
4541     \snippet qstring/main.cpp 31
4542 
4543     \sa first(), last(), startsWith(), chopped(), chop(), truncate()
4544 */
4545 QString QString::left(qsizetype n)  const
4546 {
4547     if (size_t(n) >= size_t(size()))
4548         return *this;
4549     return QString((const QChar*) d.data(), n);
4550 }
4551 
4552 /*!
4553     Returns a substring that contains the \a n rightmost characters
4554     of the string.
4555 
4556     \obsolete Use last() instead in new code.
4557 
4558     The entire string is returned if \a n is greater than or equal
4559     to size(), or less than zero.
4560 
4561     \snippet qstring/main.cpp 48
4562 
4563     \sa endsWith(), last(), first(), sliced(), chopped(), chop(), truncate()
4564 */
4565 QString QString::right(qsizetype n) const
4566 {
4567     if (size_t(n) >= size_t(size()))
4568         return *this;
4569     return QString(constData() + size() - n, n);
4570 }
4571 
4572 /*!
4573     Returns a string that contains \a n characters of this string,
4574     starting at the specified \a position index.
4575 
4576     \obsolete Use sliced() instead in new code.
4577 
4578     Returns a null string if the \a position index exceeds the
4579     length of the string. If there are less than \a n characters
4580     available in the string starting at the given \a position, or if
4581     \a n is -1 (default), the function returns all characters that
4582     are available from the specified \a position.
4583 
4584     Example:
4585 
4586     \snippet qstring/main.cpp 34
4587 
4588     \sa first(), last(), sliced(), chopped(), chop(), truncate()
4589 */
4590 
4591 QString QString::mid(qsizetype position, qsizetype n) const
4592 {
4593     qsizetype p = position;
4594     qsizetype l = n;
4595     using namespace QtPrivate;
4596     switch (QContainerImplHelper::mid(size(), &p, &l)) {
4597     case QContainerImplHelper::Null:
4598         return QString();
4599     case QContainerImplHelper::Empty:
4600         return QString(DataPointer::fromRawData(&_empty, 0));
4601     case QContainerImplHelper::Full:
4602         return *this;
4603     case QContainerImplHelper::Subset:
4604         return QString(constData() + p, l);
4605     }
4606     Q_UNREACHABLE();
4607     return QString();
4608 }
4609 
4610 /*!
4611     \fn QString QString::first(qsizetype n) const
4612     \since 6.0
4613 
4614     Returns a string that contains the first \a n characters
4615     of this string.
4616 
4617     \note The behavior is undefined when \a n < 0 or \a n > size().
4618 
4619     \sa last(), sliced(), startsWith(), chopped(), chop(), truncate()
4620 */
4621 
4622 /*!
4623     \fn QString QString::last(qsizetype n) const
4624     \since 6.0
4625 
4626     Returns the string that contains the last \a n characters of this string.
4627 
4628     \note The behavior is undefined when \a n < 0 or \a n > size().
4629 
4630     \sa first(), sliced(), endsWith(), chopped(), chop(), truncate()
4631 */
4632 
4633 /*!
4634     \fn QString QString::sliced(qsizetype pos, qsizetype n) const
4635     \since 6.0
4636 
4637     Returns a string that contains \a n characters of this string,
4638     starting at position \a pos.
4639 
4640     \note The behavior is undefined when \a pos < 0, \a n < 0,
4641     or \a pos + \a n > size().
4642 
4643     \sa first(), last(), chopped(), chop(), truncate()
4644 */
4645 
4646 /*!
4647     \fn QString QString::sliced(qsizetype pos) const
4648     \since 6.0
4649     \overload
4650 
4651     Returns a string that contains the portion of this string starting at
4652     position \a pos and extending to its end.
4653 
4654     \note The behavior is undefined when \a pos < 0 or \a pos > size().
4655 
4656     \sa first(), last(), sliced(), chopped(), chop(), truncate()
4657 */
4658 
4659 /*!
4660     \fn QString QString::chopped(qsizetype len) const
4661     \since 5.10
4662 
4663     Returns a string that contains the size() - \a len leftmost characters
4664     of this string.
4665 
4666     \note The behavior is undefined if \a len is negative or greater than size().
4667 
4668     \sa endsWith(), left(), right(), mid(), chop(), truncate()
4669 */
4670 
4671 #if QT_STRINGVIEW_LEVEL < 2
4672 /*!
4673     Returns \c true if the string starts with \a s; otherwise returns
4674     \c false.
4675 
4676     If \a cs is Qt::CaseSensitive (default), the search is
4677     case sensitive; otherwise the search is case insensitive.
4678 
4679     \snippet qstring/main.cpp 65
4680 
4681     \sa endsWith()
4682 */
4683 bool QString::startsWith(const QString& s, Qt::CaseSensitivity cs) const
4684 {
4685     return qt_starts_with(*this, s, cs);
4686 }
4687 #endif
4688 
4689 /*!
4690   \overload startsWith()
4691  */
4692 bool QString::startsWith(QLatin1String s, Qt::CaseSensitivity cs) const
4693 {
4694     return qt_starts_with(*this, s, cs);
4695 }
4696 
4697 /*!
4698   \overload startsWith()
4699 
4700   Returns \c true if the string starts with \a c; otherwise returns
4701   \c false.
4702 */
4703 bool QString::startsWith(QChar c, Qt::CaseSensitivity cs) const
4704 {
4705     return qt_starts_with(*this, c, cs);
4706 }
4707 
4708 /*!
4709     \fn bool QString::startsWith(QStringView str, Qt::CaseSensitivity cs) const
4710     \since 5.10
4711     \overload
4712 
4713     Returns \c true if the string starts with the string-view \a str;
4714     otherwise returns \c false.
4715 
4716     If \a cs is Qt::CaseSensitive (default), the search is case-sensitive;
4717     otherwise the search is case insensitive.
4718 
4719     \sa endsWith()
4720 */
4721 
4722 #if QT_STRINGVIEW_LEVEL < 2
4723 /*!
4724     Returns \c true if the string ends with \a s; otherwise returns
4725     \c false.
4726 
4727     If \a cs is Qt::CaseSensitive (default), the search is case
4728     sensitive; otherwise the search is case insensitive.
4729 
4730     \snippet qstring/main.cpp 20
4731 
4732     \sa startsWith()
4733 */
4734 bool QString::endsWith(const QString &s, Qt::CaseSensitivity cs) const
4735 {
4736     return qt_ends_with(*this, s, cs);
4737 }
4738 #endif // QT_STRINGVIEW_LEVEL < 2
4739 
4740 /*!
4741     \fn bool QString::endsWith(QStringView str, Qt::CaseSensitivity cs) const
4742     \since 5.10
4743     \overload endsWith()
4744     Returns \c true if the string ends with the string view \a str;
4745     otherwise returns \c false.
4746 
4747     If \a cs is Qt::CaseSensitive (default), the search is case
4748     sensitive; otherwise the search is case insensitive.
4749 
4750     \sa startsWith()
4751 */
4752 
4753 /*!
4754     \overload endsWith()
4755 */
4756 bool QString::endsWith(QLatin1String s, Qt::CaseSensitivity cs) const
4757 {
4758     return qt_ends_with(*this, s, cs);
4759 }
4760 
4761 /*!
4762   Returns \c true if the string ends with \a c; otherwise returns
4763   \c false.
4764 
4765   \overload endsWith()
4766  */
4767 bool QString::endsWith(QChar c, Qt::CaseSensitivity cs) const
4768 {
4769     return qt_ends_with(*this, c, cs);
4770 }
4771 
4772 /*!
4773     Returns \c true if the string is uppercase, that is, it's identical
4774     to its toUpper() folding.
4775 
4776     Note that this does \e not mean that the string does not contain
4777     lowercase letters (some lowercase letters do not have a uppercase
4778     folding; they are left unchanged by toUpper()).
4779     For more information, refer to the Unicode standard, section 3.13.
4780 
4781     \since 5.12
4782 
4783     \sa QChar::toUpper(), isLower()
4784 */
4785 bool QString::isUpper() const
4786 {
4787     QStringIterator it(*this);
4788 
4789     while (it.hasNext()) {
4790         const char32_t uc = it.nextUnchecked();
4791         if (qGetProp(uc)->cases[QUnicodeTables::UpperCase].diff)
4792             return false;
4793     }
4794 
4795     return true;
4796 }
4797 
4798 /*!
4799     Returns \c true if the string is lowercase, that is, it's identical
4800     to its toLower() folding.
4801 
4802     Note that this does \e not mean that the string does not contain
4803     uppercase letters (some uppercase letters do not have a lowercase
4804     folding; they are left unchanged by toLower()).
4805     For more information, refer to the Unicode standard, section 3.13.
4806 
4807     \since 5.12
4808 
4809     \sa QChar::toLower(), isUpper()
4810  */
4811 bool QString::isLower() const
4812 {
4813     QStringIterator it(*this);
4814 
4815     while (it.hasNext()) {
4816         const char32_t uc = it.nextUnchecked();
4817         if (qGetProp(uc)->cases[QUnicodeTables::LowerCase].diff)
4818             return false;
4819     }
4820 
4821     return true;
4822 }
4823 
4824 static QByteArray qt_convert_to_latin1(QStringView string);
4825 
4826 QByteArray QString::toLatin1_helper(const QString &string)
4827 {
4828     return qt_convert_to_latin1(string);
4829 }
4830 
4831 /*!
4832     \since 5.10
4833     \internal
4834     \relates QStringView
4835 
4836     Returns a Latin-1 representation of \a string as a QByteArray.
4837 
4838     The behavior is undefined if \a string contains non-Latin1 characters.
4839 
4840     \sa QString::toLatin1(), QStringView::toLatin1(), QtPrivate::convertToUtf8(),
4841     QtPrivate::convertToLocal8Bit(), QtPrivate::convertToUcs4()
4842 */
4843 QByteArray QtPrivate::convertToLatin1(QStringView string)
4844 {
4845     return qt_convert_to_latin1(string);
4846 }
4847 
4848 static QByteArray qt_convert_to_latin1(QStringView string)
4849 {
4850     if (Q_UNLIKELY(string.isNull()))
4851         return QByteArray();
4852 
4853     QByteArray ba(string.length(), Qt::Uninitialized);
4854 
4855     // since we own the only copy, we're going to const_cast the constData;
4856     // that avoids an unnecessary call to detach() and expansion code that will never get used
4857     qt_to_latin1(reinterpret_cast<uchar *>(const_cast<char *>(ba.constData())),
4858                  string.utf16(), string.size());
4859     return ba;
4860 }
4861 
4862 QByteArray QString::toLatin1_helper_inplace(QString &s)
4863 {
4864     if (!s.isDetached())
4865         return qt_convert_to_latin1(s);
4866 
4867     // We can return our own buffer to the caller.
4868     // Conversion to Latin-1 always shrinks the buffer by half.
4869     const char16_t *data = s.d.data();
4870     qsizetype length = s.d.size;
4871 
4872     // Move the d pointer over to the bytearray.
4873     // Kids, avert your eyes. Don't try this at home.
4874 
4875     // this relies on the fact that we use QArrayData for everything behind the scenes which has the same layout
4876     static_assert(sizeof(QByteArray::DataPointer) == sizeof(QString::DataPointer), "sizes have to be equal");
4877     QByteArray::DataPointer ba_d(reinterpret_cast<QByteArray::Data *>(s.d.d_ptr()), reinterpret_cast<char *>(s.d.data()), length);
4878     ba_d.ref();
4879     s.clear();
4880 
4881     char *ddata = ba_d.data();
4882 
4883     // multiply the allocated capacity by sizeof(char16_t)
4884     ba_d.d_ptr()->alloc *= sizeof(char16_t);
4885 
4886     // do the in-place conversion
4887     qt_to_latin1(reinterpret_cast<uchar *>(ddata), data, length);
4888     ddata[length] = '\0';
4889     return QByteArray(ba_d);
4890 }
4891 
4892 /*!
4893     \fn QByteArray QString::toLatin1() const
4894 
4895     Returns a Latin-1 representation of the string as a QByteArray.
4896 
4897     The returned byte array is undefined if the string contains non-Latin1
4898     characters. Those characters may be suppressed or replaced with a
4899     question mark.
4900 
4901     \sa fromLatin1(), toUtf8(), toLocal8Bit(), QStringEncoder
4902 */
4903 
4904 static QByteArray qt_convert_to_local_8bit(QStringView string);
4905 
4906 /*!
4907     \fn QByteArray QString::toLocal8Bit() const
4908 
4909     Returns the local 8-bit representation of the string as a
4910     QByteArray. The returned byte array is undefined if the string
4911     contains characters not supported by the local 8-bit encoding.
4912 
4913     On Unix systems this is equivalen to toUtf8(), on Windows the systems
4914     current code page is being used.
4915 
4916     If this string contains any characters that cannot be encoded in the
4917     locale, the returned byte array is undefined. Those characters may be
4918     suppressed or replaced by another.
4919 
4920     \sa fromLocal8Bit(), toLatin1(), toUtf8(), QStringEncoder
4921 */
4922 
4923 QByteArray QString::toLocal8Bit_helper(const QChar *data, qsizetype size)
4924 {
4925     return qt_convert_to_local_8bit(QStringView(data, size));
4926 }
4927 
4928 static QByteArray qt_convert_to_local_8bit(QStringView string)
4929 {
4930     if (string.isNull())
4931         return QByteArray();
4932     QStringEncoder fromUtf16(QStringEncoder::System, QStringEncoder::Flag::Stateless);
4933     return fromUtf16(string);
4934 }
4935 
4936 /*!
4937     \since 5.10
4938     \internal
4939     \relates QStringView
4940 
4941     Returns a local 8-bit representation of \a string as a QByteArray.
4942 
4943     On Unix systems this is equivalen to toUtf8(), on Windows the systems
4944     current code page is being used.
4945 
4946     The behavior is undefined if \a string contains characters not
4947     supported by the locale's 8-bit encoding.
4948 
4949     \sa QString::toLocal8Bit(), QStringView::toLocal8Bit()
4950 */
4951 QByteArray QtPrivate::convertToLocal8Bit(QStringView string)
4952 {
4953     return qt_convert_to_local_8bit(string);
4954 }
4955 
4956 static QByteArray qt_convert_to_utf8(QStringView str);
4957 
4958 /*!
4959     \fn QByteArray QString::toUtf8() const
4960 
4961     Returns a UTF-8 representation of the string as a QByteArray.
4962 
4963     UTF-8 is a Unicode codec and can represent all characters in a Unicode
4964     string like QString.
4965 
4966     \sa fromUtf8(), toLatin1(), toLocal8Bit(), QStringEncoder
4967 */
4968 
4969 QByteArray QString::toUtf8_helper(const QString &str)
4970 {
4971     return qt_convert_to_utf8(str);
4972 }
4973 
4974 static QByteArray qt_convert_to_utf8(QStringView str)
4975 {
4976     if (str.isNull())
4977         return QByteArray();
4978 
4979     return QUtf8::convertFromUnicode(str.data(), str.length());
4980 }
4981 
4982 /*!
4983     \since 5.10
4984     \internal
4985     \relates QStringView
4986 
4987     Returns a UTF-8 representation of \a string as a QByteArray.
4988 
4989     UTF-8 is a Unicode codec and can represent all characters in a Unicode
4990     string like QStringView.
4991 
4992     \sa QString::toUtf8(), QStringView::toUtf8()
4993 */
4994 QByteArray QtPrivate::convertToUtf8(QStringView string)
4995 {
4996     return qt_convert_to_utf8(string);
4997 }
4998 
4999 static QList<uint> qt_convert_to_ucs4(QStringView string);
5000 
5001 /*!
5002     \since 4.2
5003 
5004     Returns a UCS-4/UTF-32 representation of the string as a QList<uint>.
5005 
5006     UCS-4 is a Unicode codec and therefore it is lossless. All characters from
5007     this string will be encoded in UCS-4. Any invalid sequence of code units in
5008     this string is replaced by the Unicode's replacement character
5009     (QChar::ReplacementCharacter, which corresponds to \c{U+FFFD}).
5010 
5011     The returned list is not \\0'-terminated.
5012 
5013     \sa fromUtf8(), toUtf8(), toLatin1(), toLocal8Bit(), QStringEncoder, fromUcs4(), toWCharArray()
5014 */
5015 QList<uint> QString::toUcs4() const
5016 {
5017     return qt_convert_to_ucs4(*this);
5018 }
5019 
5020 static QList<uint> qt_convert_to_ucs4(QStringView string)
5021 {
5022     QList<uint> v(string.length());
5023     uint *a = const_cast<uint*>(v.constData());
5024     QStringIterator it(string);
5025     while (it.hasNext())
5026         *a++ = it.next();
5027     v.resize(a - v.constData());
5028     return v;
5029 }
5030 
5031 /*!
5032     \since 5.10
5033     \internal
5034     \relates QStringView
5035 
5036     Returns a UCS-4/UTF-32 representation of \a string as a QList<uint>.
5037 
5038     UCS-4 is a Unicode codec and therefore it is lossless. All characters from
5039     this string will be encoded in UCS-4. Any invalid sequence of code units in
5040     this string is replaced by the Unicode's replacement character
5041     (QChar::ReplacementCharacter, which corresponds to \c{U+FFFD}).
5042 
5043     The returned list is not \\0'-terminated.
5044 
5045     \sa QString::toUcs4(), QStringView::toUcs4(), QtPrivate::convertToLatin1(),
5046     QtPrivate::convertToLocal8Bit(), QtPrivate::convertToUtf8()
5047 */
5048 QList<uint> QtPrivate::convertToUcs4(QStringView string)
5049 {
5050     return qt_convert_to_ucs4(string);
5051 }
5052 
5053 QString::DataPointer QString::fromLatin1_helper(const char *str, qsizetype size)
5054 {
5055     DataPointer d;
5056     if (!str) {
5057         // nothing to do
5058     } else if (size == 0 || (!*str && size < 0)) {
5059         d = DataPointer::fromRawData(&_empty, 0);
5060     } else {
5061         if (size < 0)
5062             size = qstrlen(str);
5063         d = DataPointer(Data::allocate(size + 1), size);
5064         d.data()[size] = '\0';
5065         char16_t *dst = d.data();
5066 
5067         qt_from_latin1(dst, str, size_t(size));
5068     }
5069     return d;
5070 }
5071 
5072 /*! \fn QString QString::fromLatin1(const char *str, qsizetype size)
5073     Returns a QString initialized with the first \a size characters
5074     of the Latin-1 string \a str.
5075 
5076     If \a size is -1 (default), it is taken to be strlen(\a
5077     str).
5078 
5079     \sa toLatin1(), fromUtf8(), fromLocal8Bit()
5080 */
5081 
5082 /*!
5083     \fn QString QString::fromLatin1(const QByteArray &str)
5084     \overload
5085     \since 5.0
5086 
5087     Returns a QString initialized with the Latin-1 string \a str.
5088 */
5089 
5090 /*! \fn QString QString::fromLocal8Bit(const char *str, qsizetype size)
5091     Returns a QString initialized with the first \a size characters
5092     of the 8-bit string \a str.
5093 
5094     If \a size is -1 (default), it is taken to be strlen(\a
5095     str).
5096 
5097     On Unix systems this is equivalen to fromUtf8(), on Windows the systems
5098     current code page is being used.
5099 
5100     \sa toLocal8Bit(), fromLatin1(), fromUtf8()
5101 */
5102 
5103 /*!
5104     \fn QString QString::fromLocal8Bit(const QByteArray &str)
5105     \overload
5106     \since 5.0
5107 
5108     Returns a QString initialized with the 8-bit string \a str.
5109 */
5110 QString QString::fromLocal8Bit_helper(const char *str, qsizetype size)
5111 {
5112     if (!str)
5113         return QString();
5114     if (size < 0)
5115         size = qstrlen(str);
5116     if (size == 0)
5117         return QString(DataPointer::fromRawData(&_empty, 0));
5118     QStringDecoder toUtf16(QStringDecoder::System, QStringDecoder::Flag::Stateless);
5119     return toUtf16(str, size);
5120 }
5121 
5122 /*! \fn QString QString::fromUtf8(const char *str, qsizetype size)
5123     Returns a QString initialized with the first \a size bytes
5124     of the UTF-8 string \a str.
5125 
5126     If \a size is -1 (default), it is taken to be strlen(\a
5127     str).
5128 
5129     UTF-8 is a Unicode codec and can represent all characters in a Unicode
5130     string like QString. However, invalid sequences are possible with UTF-8
5131     and, if any such are found, they will be replaced with one or more
5132     "replacement characters", or suppressed. These include non-Unicode
5133     sequences, non-characters, overlong sequences or surrogate codepoints
5134     encoded into UTF-8.
5135 
5136     This function can be used to process incoming data incrementally as long as
5137     all UTF-8 characters are terminated within the incoming data. Any
5138     unterminated characters at the end of the string will be replaced or
5139     suppressed. In order to do stateful decoding, please use \l QStringDecoder.
5140 
5141     \sa toUtf8(), fromLatin1(), fromLocal8Bit()
5142 */
5143 
5144 /*!
5145     \fn QString QString::fromUtf8(const char8_t *str, qsizetype size)
5146     \overload
5147     \since 6.0
5148 
5149     This overload is only available when compiling in C++20 mode.
5150 */
5151 
5152 /*!
5153     \fn QString QString::fromUtf8(const QByteArray &str)
5154     \overload
5155     \since 5.0
5156 
5157     Returns a QString initialized with the UTF-8 string \a str.
5158 */
5159 QString QString::fromUtf8_helper(const char *str, qsizetype size)
5160 {
5161     if (!str)
5162         return QString();
5163 
5164     Q_ASSERT(size != -1);
5165     return QUtf8::convertToUnicode(str, size);
5166 }
5167 
5168 /*!
5169     \since 5.3
5170     Returns a QString initialized with the first \a size characters
5171     of the Unicode string \a unicode (ISO-10646-UTF-16 encoded).
5172 
5173     If \a size is -1 (default), \a unicode must be \\0'-terminated.
5174 
5175     This function checks for a Byte Order Mark (BOM). If it is missing,
5176     host byte order is assumed.
5177 
5178     This function is slow compared to the other Unicode conversions.
5179     Use QString(const QChar *, int) or QString(const QChar *) if possible.
5180 
5181     QString makes a deep copy of the Unicode data.
5182 
5183     \sa utf16(), setUtf16(), fromStdU16String()
5184 */
5185 QString QString::fromUtf16(const char16_t *unicode, qsizetype size)
5186 {
5187     if (!unicode)
5188         return QString();
5189     if (size < 0) {
5190         size = 0;
5191         while (unicode[size] != 0)
5192             ++size;
5193     }
5194     QStringDecoder toUtf16(QStringDecoder::Utf16, QStringDecoder::Flag::Stateless);
5195     return toUtf16(reinterpret_cast<const char *>(unicode), size*2);
5196 }
5197 
5198 /*!
5199     \fn QString QString::fromUtf16(const ushort *str, qsizetype size)
5200     \obsolete
5201 
5202     Use the \c char16_t overload.
5203 */
5204 
5205 /*!
5206     \fn QString QString::fromUcs4(const uint *str, qsizetype size)
5207     \since 4.2
5208     \obsolete
5209 
5210     Use the \c char32_t overload instead.
5211 */
5212 
5213 /*!
5214     \since 5.3
5215 
5216     Returns a QString initialized with the first \a size characters
5217     of the Unicode string \a unicode (ISO-10646-UCS-4 encoded).
5218 
5219     If \a size is -1 (default), \a unicode must be \\0'-terminated.
5220 
5221     \sa toUcs4(), fromUtf16(), utf16(), setUtf16(), fromWCharArray(), fromStdU32String()
5222 */
5223 QString QString::fromUcs4(const char32_t *unicode, qsizetype size)
5224 {
5225     if (!unicode)
5226         return QString();
5227     if (size < 0) {
5228         size = 0;
5229         while (unicode[size] != 0)
5230             ++size;
5231     }
5232     QStringDecoder toUtf16(QStringDecoder::Utf32, QStringDecoder::Flag::Stateless);
5233     return toUtf16(reinterpret_cast<const char *>(unicode), size*4);
5234 }
5235 
5236 
5237 /*!
5238     Resizes the string to \a size characters and copies \a unicode
5239     into the string.
5240 
5241     If \a unicode is 0, nothing is copied, but the string is still
5242     resized to \a size.
5243 
5244     \sa unicode(), setUtf16()
5245 */
5246 QString& QString::setUnicode(const QChar *unicode, qsizetype size)
5247 {
5248      resize(size);
5249      if (unicode && size)
5250          memcpy(d.data(), unicode, size * sizeof(QChar));
5251      return *this;
5252 }
5253 
5254 /*!
5255     \fn QString &QString::setUtf16(const ushort *unicode, qsizetype size)
5256 
5257     Resizes the string to \a size characters and copies \a unicode
5258     into the string.
5259 
5260     If \a unicode is 0, nothing is copied, but the string is still
5261     resized to \a size.
5262 
5263     Note that unlike fromUtf16(), this function does not consider BOMs and
5264     possibly differing byte ordering.
5265 
5266     \sa utf16(), setUnicode()
5267 */
5268 
5269 /*!
5270     \fn QString QString::simplified() const
5271 
5272     Returns a string that has whitespace removed from the start
5273     and the end, and that has each sequence of internal whitespace
5274     replaced with a single space.
5275 
5276     Whitespace means any character for which QChar::isSpace() returns
5277     \c true. This includes the ASCII characters '\\t', '\\n', '\\v',
5278     '\\f', '\\r', and ' '.
5279 
5280     Example:
5281 
5282     \snippet qstring/main.cpp 57
5283 
5284     \sa trimmed()
5285 */
5286 QString QString::simplified_helper(const QString &str)
5287 {
5288     return QStringAlgorithms<const QString>::simplified_helper(str);
5289 }
5290 
5291 QString QString::simplified_helper(QString &str)
5292 {
5293     return QStringAlgorithms<QString>::simplified_helper(str);
5294 }
5295 
5296 namespace {
5297     template <typename StringView>
5298     StringView qt_trimmed(StringView s) noexcept
5299     {
5300         auto begin = s.begin();
5301         auto end = s.end();
5302         QStringAlgorithms<const StringView>::trimmed_helper_positions(begin, end);
5303         return StringView{begin, end};
5304     }
5305 }
5306 
5307 /*!
5308     \fn QStringView QtPrivate::trimmed(QStringView s)
5309     \fn QLatin1String QtPrivate::trimmed(QLatin1String s)
5310     \internal
5311     \relates QStringView
5312     \since 5.10
5313 
5314     Returns \a s with whitespace removed from the start and the end.
5315 
5316     Whitespace means any character for which QChar::isSpace() returns
5317     \c true. This includes the ASCII characters '\\t', '\\n', '\\v',
5318     '\\f', '\\r', and ' '.
5319 
5320     \sa QString::trimmed(), QStringView::trimmed(), QLatin1String::trimmed()
5321 */
5322 QStringView QtPrivate::trimmed(QStringView s) noexcept
5323 {
5324     return qt_trimmed(s);
5325 }
5326 
5327 QLatin1String QtPrivate::trimmed(QLatin1String s) noexcept
5328 {
5329     return qt_trimmed(s);
5330 }
5331 
5332 /*!
5333     \fn QString QString::trimmed() const
5334 
5335     Returns a string that has whitespace removed from the start and
5336     the end.
5337 
5338     Whitespace means any character for which QChar::isSpace() returns
5339     \c true. This includes the ASCII characters '\\t', '\\n', '\\v',
5340     '\\f', '\\r', and ' '.
5341 
5342     Example:
5343 
5344     \snippet qstring/main.cpp 82
5345 
5346     Unlike simplified(), trimmed() leaves internal whitespace alone.
5347 
5348     \sa simplified()
5349 */
5350 QString QString::trimmed_helper(const QString &str)
5351 {
5352     return QStringAlgorithms<const QString>::trimmed_helper(str);
5353 }
5354 
5355 QString QString::trimmed_helper(QString &str)
5356 {
5357     return QStringAlgorithms<QString>::trimmed_helper(str);
5358 }
5359 
5360 /*! \fn const QChar QString::at(qsizetype position) const
5361 
5362     Returns the character at the given index \a position in the
5363     string.
5364 
5365     The \a position must be a valid index position in the string
5366     (i.e., 0 <= \a position < size()).
5367 
5368     \sa operator[]()
5369 */
5370 
5371 /*!
5372     \fn QChar &QString::operator[](qsizetype position)
5373 
5374     Returns the character at the specified \a position in the string as a
5375     modifiable reference.
5376 
5377     Example:
5378 
5379     \snippet qstring/main.cpp 85
5380 
5381     \sa at()
5382 */
5383 
5384 /*!
5385     \fn const QChar QString::operator[](qsizetype position) const
5386 
5387     \overload operator[]()
5388 */
5389 
5390 /*!
5391     \fn QChar QString::front() const
5392     \since 5.10
5393 
5394     Returns the first character in the string.
5395     Same as \c{at(0)}.
5396 
5397     This function is provided for STL compatibility.
5398 
5399     \warning Calling this function on an empty string constitutes
5400     undefined behavior.
5401 
5402     \sa back(), at(), operator[]()
5403 */
5404 
5405 /*!
5406     \fn QChar QString::back() const
5407     \since 5.10
5408 
5409     Returns the last character in the string.
5410     Same as \c{at(size() - 1)}.
5411 
5412     This function is provided for STL compatibility.
5413 
5414     \warning Calling this function on an empty string constitutes
5415     undefined behavior.
5416 
5417     \sa front(), at(), operator[]()
5418 */
5419 
5420 /*!
5421     \fn QChar &QString::front()
5422     \since 5.10
5423 
5424     Returns a reference to the first character in the string.
5425     Same as \c{operator[](0)}.
5426 
5427     This function is provided for STL compatibility.
5428 
5429     \warning Calling this function on an empty string constitutes
5430     undefined behavior.
5431 
5432     \sa back(), at(), operator[]()
5433 */
5434 
5435 /*!
5436     \fn QChar &QString::back()
5437     \since 5.10
5438 
5439     Returns a reference to the last character in the string.
5440     Same as \c{operator[](size() - 1)}.
5441 
5442     This function is provided for STL compatibility.
5443 
5444     \warning Calling this function on an empty string constitutes
5445     undefined behavior.
5446 
5447     \sa front(), at(), operator[]()
5448 */
5449 
5450 /*!
5451     \fn void QString::truncate(qsizetype position)
5452 
5453     Truncates the string at the given \a position index.
5454 
5455     If the specified \a position index is beyond the end of the
5456     string, nothing happens.
5457 
5458     Example:
5459 
5460     \snippet qstring/main.cpp 83
5461 
5462     If \a position is negative, it is equivalent to passing zero.
5463 
5464     \sa chop(), resize(), left(), QStringView::truncate()
5465 */
5466 
5467 void QString::truncate(qsizetype pos)
5468 {
5469     if (pos < size())
5470         resize(pos);
5471 }
5472 
5473 
5474 /*!
5475     Removes \a n characters from the end of the string.
5476 
5477     If \a n is greater than or equal to size(), the result is an
5478     empty string; if \a n is negative, it is equivalent to passing zero.
5479 
5480     Example:
5481     \snippet qstring/main.cpp 15
5482 
5483     If you want to remove characters from the \e beginning of the
5484     string, use remove() instead.
5485 
5486     \sa truncate(), resize(), remove(), QStringView::chop()
5487 */
5488 void QString::chop(qsizetype n)
5489 {
5490     if (n > 0)
5491         resize(d.size - n);
5492 }
5493 
5494 /*!
5495     Sets every character in the string to character \a ch. If \a size
5496     is different from -1 (default), the string is resized to \a
5497     size beforehand.
5498 
5499     Example:
5500 
5501     \snippet qstring/main.cpp 21
5502 
5503     \sa resize()
5504 */
5505 
5506 QString& QString::fill(QChar ch, qsizetype size)
5507 {
5508     resize(size < 0 ? d.size : size);
5509     if (d.size) {
5510         QChar *i = (QChar*)d.data() + d.size;
5511         QChar *b = (QChar*)d.data();
5512         while (i != b)
5513            *--i = ch;
5514     }
5515     return *this;
5516 }
5517 
5518 /*!
5519     \fn qsizetype QString::length() const
5520 
5521     Returns the number of characters in this string.  Equivalent to
5522     size().
5523 
5524     \sa resize()
5525 */
5526 
5527 /*!
5528     \fn qsizetype QString::size() const
5529 
5530     Returns the number of characters in this string.
5531 
5532     The last character in the string is at position size() - 1.
5533 
5534     Example:
5535     \snippet qstring/main.cpp 58
5536 
5537     \sa isEmpty(), resize()
5538 */
5539 
5540 /*! \fn bool QString::isNull() const
5541 
5542     Returns \c true if this string is null; otherwise returns \c false.
5543 
5544     Example:
5545 
5546     \snippet qstring/main.cpp 28
5547 
5548     Qt makes a distinction between null strings and empty strings for
5549     historical reasons. For most applications, what matters is
5550     whether or not a string contains any data, and this can be
5551     determined using the isEmpty() function.
5552 
5553     \sa isEmpty()
5554 */
5555 
5556 /*! \fn bool QString::isEmpty() const
5557 
5558     Returns \c true if the string has no characters; otherwise returns
5559     \c false.
5560 
5561     Example:
5562 
5563     \snippet qstring/main.cpp 27
5564 
5565     \sa size()
5566 */
5567 
5568 /*! \fn QString &QString::operator+=(const QString &other)
5569 
5570     Appends the string \a other onto the end of this string and
5571     returns a reference to this string.
5572 
5573     Example:
5574 
5575     \snippet qstring/main.cpp 84
5576 
5577     This operation is typically very fast (\l{constant time}),
5578     because QString preallocates extra space at the end of the string
5579     data so it can grow without reallocating the entire string each
5580     time.
5581 
5582     \sa append(), prepend()
5583 */
5584 
5585 /*! \fn QString &QString::operator+=(QLatin1String str)
5586 
5587     \overload operator+=()
5588 
5589     Appends the Latin-1 string \a str to this string.
5590 */
5591 
5592 /*! \fn QString &QString::operator+=(const QByteArray &ba)
5593 
5594     \overload operator+=()
5595 
5596     Appends the byte array \a ba to this string. The byte array is converted
5597     to Unicode using the fromUtf8() function. If any NUL characters ('\\0')
5598     are embedded in the \a ba byte array, they will be included in the
5599     transformation.
5600 
5601     You can disable this function by defining \c
5602     QT_NO_CAST_FROM_ASCII when you compile your applications. This
5603     can be useful if you want to ensure that all user-visible strings
5604     go through QObject::tr(), for example.
5605 
5606     \sa QT_NO_CAST_FROM_ASCII
5607 */
5608 
5609 /*! \fn QString &QString::operator+=(const char *str)
5610 
5611     \overload operator+=()
5612 
5613     Appends the string \a str to this string. The const char pointer
5614     is converted to Unicode using the fromUtf8() function.
5615 
5616     You can disable this function by defining \c QT_NO_CAST_FROM_ASCII
5617     when you compile your applications. This can be useful if you want
5618     to ensure that all user-visible strings go through QObject::tr(),
5619     for example.
5620 
5621     \sa QT_NO_CAST_FROM_ASCII
5622 */
5623 
5624 /*! \fn QString &QString::operator+=(QStringView str)
5625     \since 6.0
5626     \overload operator+=()
5627 
5628     Appends the string view \a str to this string.
5629 */
5630 
5631 /*! \fn QString &QString::operator+=(QChar ch)
5632 
5633     \overload operator+=()
5634 
5635     Appends the character \a ch to the string.
5636 */
5637 
5638 /*!
5639     \fn bool operator==(const char *s1, const QString &s2)
5640 
5641     \overload  operator==()
5642     \relates QString
5643 
5644     Returns \c true if \a s1 is equal to \a s2; otherwise returns \c false.
5645     Note that no string is equal to \a s1 being 0.
5646 
5647     Equivalent to \c {s1 != 0 && compare(s1, s2) == 0}.
5648 */
5649 
5650 /*!
5651     \fn bool operator!=(const char *s1, const QString &s2)
5652     \relates QString
5653 
5654     Returns \c true if \a s1 is not equal to \a s2; otherwise returns
5655     \c false.
5656 
5657     For \a s1 != 0, this is equivalent to \c {compare(} \a s1, \a s2
5658     \c {) != 0}. Note that no string is equal to \a s1 being 0.
5659 */
5660 
5661 /*!
5662     \fn bool operator<(const char *s1, const QString &s2)
5663     \relates QString
5664 
5665     Returns \c true if \a s1 is lexically less than \a s2; otherwise
5666     returns \c false.  For \a s1 != 0, this is equivalent to \c
5667     {compare(s1, s2) < 0}.
5668 
5669     \sa {Comparing Strings}
5670 */
5671 
5672 /*!
5673     \fn bool operator<=(const char *s1, const QString &s2)
5674     \relates QString
5675 
5676     Returns \c true if \a s1 is lexically less than or equal to \a s2;
5677     otherwise returns \c false.  For \a s1 != 0, this is equivalent to \c
5678     {compare(s1, s2) <= 0}.
5679 
5680     \sa {Comparing Strings}
5681 */
5682 
5683 /*!
5684     \fn bool operator>(const char *s1, const QString &s2)
5685     \relates QString
5686 
5687     Returns \c true if \a s1 is lexically greater than \a s2; otherwise
5688     returns \c false.  Equivalent to \c {compare(s1, s2) > 0}.
5689 
5690     \sa {Comparing Strings}
5691 */
5692 
5693 /*!
5694     \fn bool operator>=(const char *s1, const QString &s2)
5695     \relates QString
5696 
5697     Returns \c true if \a s1 is lexically greater than or equal to \a s2;
5698     otherwise returns \c false.  For \a s1 != 0, this is equivalent to \c
5699     {compare(s1, s2) >= 0}.
5700 
5701     \sa {Comparing Strings}
5702 */
5703 
5704 /*!
5705     \fn const QString operator+(const QString &s1, const QString &s2)
5706     \relates QString
5707 
5708     Returns a string which is the result of concatenating \a s1 and \a
5709     s2.
5710 */
5711 
5712 /*!
5713     \fn const QString operator+(const QString &s1, const char *s2)
5714     \relates QString
5715 
5716     Returns a string which is the result of concatenating \a s1 and \a
5717     s2 (\a s2 is converted to Unicode using the QString::fromUtf8()
5718     function).
5719 
5720     \sa QString::fromUtf8()
5721 */
5722 
5723 /*!
5724     \fn const QString operator+(const char *s1, const QString &s2)
5725     \relates QString
5726 
5727     Returns a string which is the result of concatenating \a s1 and \a
5728     s2 (\a s1 is converted to Unicode using the QString::fromUtf8()
5729     function).
5730 
5731     \sa QString::fromUtf8()
5732 */
5733 
5734 /*!
5735     \fn int QString::compare(const QString &s1, const QString &s2, Qt::CaseSensitivity cs)
5736     \since 4.2
5737 
5738     Compares \a s1 with \a s2 and returns an integer less than, equal
5739     to, or greater than zero if \a s1 is less than, equal to, or
5740     greater than \a s2.
5741 
5742     If \a cs is Qt::CaseSensitive, the comparison is case sensitive;
5743     otherwise the comparison is case insensitive.
5744 
5745     Case sensitive comparison is based exclusively on the numeric
5746     Unicode values of the characters and is very fast, but is not what
5747     a human would expect.  Consider sorting user-visible strings with
5748     localeAwareCompare().
5749 
5750     \snippet qstring/main.cpp 16
5751 
5752     \sa operator==(), operator<(), operator>(), {Comparing Strings}
5753 */
5754 
5755 /*!
5756     \fn int QString::compare(const QString &s1, QLatin1String s2, Qt::CaseSensitivity cs)
5757     \since 4.2
5758     \overload compare()
5759 
5760     Performs a comparison of \a s1 and \a s2, using the case
5761     sensitivity setting \a cs.
5762 */
5763 
5764 /*!
5765     \fn int QString::compare(QLatin1String s1, const QString &s2, Qt::CaseSensitivity cs = Qt::CaseSensitive)
5766 
5767     \since 4.2
5768     \overload compare()
5769 
5770     Performs a comparison of \a s1 and \a s2, using the case
5771     sensitivity setting \a cs.
5772 */
5773 
5774 /*!
5775     \fn int QString::compare(QStringView s, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
5776 
5777     \since 5.12
5778     \overload compare()
5779 
5780     Performs a comparison of this with \a s, using the case
5781     sensitivity setting \a cs.
5782 */
5783 
5784 /*!
5785     \fn int QString::compare(QChar ch, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
5786 
5787     \since 5.14
5788     \overload compare()
5789 
5790     Performs a comparison of this with \a ch, using the case
5791     sensitivity setting \a cs.
5792 */
5793 
5794 #if QT_STRINGVIEW_LEVEL < 2
5795 /*!
5796     \overload compare()
5797     \since 4.2
5798 
5799     Lexically compares this string with the \a other string and
5800     returns an integer less than, equal to, or greater than zero if
5801     this string is less than, equal to, or greater than the other
5802     string.
5803 
5804     Same as compare(*this, \a other, \a cs).
5805 */
5806 int QString::compare(const QString &other, Qt::CaseSensitivity cs) const noexcept
5807 {
5808     return qt_compare_strings(*this, other, cs);
5809 }
5810 #endif
5811 
5812 /*!
5813     \internal
5814     \since 4.5
5815 */
5816 int QString::compare_helper(const QChar *data1, qsizetype length1, const QChar *data2, qsizetype length2,
5817                             Qt::CaseSensitivity cs) noexcept
5818 {
5819     Q_ASSERT(length1 >= 0);
5820     Q_ASSERT(length2 >= 0);
5821     Q_ASSERT(data1 || length1 == 0);
5822     Q_ASSERT(data2 || length2 == 0);
5823     return qt_compare_strings(QStringView(data1, length1), QStringView(data2, length2), cs);
5824 }
5825 
5826 /*!
5827     \overload compare()
5828     \since 4.2
5829 
5830     Same as compare(*this, \a other, \a cs).
5831 */
5832 int QString::compare(QLatin1String other, Qt::CaseSensitivity cs) const noexcept
5833 {
5834     return qt_compare_strings(*this, other, cs);
5835 }
5836 
5837 /*!
5838     \internal
5839     \since 5.0
5840 */
5841 int QString::compare_helper(const QChar *data1, qsizetype length1, const char *data2, qsizetype length2,
5842                             Qt::CaseSensitivity cs)
5843 {
5844     Q_ASSERT(length1 >= 0);
5845     Q_ASSERT(data1 || length1 == 0);
5846     if (!data2)
5847         return length1;
5848     if (Q_UNLIKELY(length2 < 0))
5849         length2 = qsizetype(strlen(data2));
5850     // ### make me nothrow in all cases
5851     QVarLengthArray<ushort> s2(length2);
5852     const auto beg = reinterpret_cast<QChar *>(s2.data());
5853     const auto end = QUtf8::convertToUnicode(beg, data2, length2);
5854     return qt_compare_strings(QStringView(data1, length1), QStringView(beg, end - beg), cs);
5855 }
5856 
5857 /*!
5858   \fn int QString::compare(const QString &s1, QStringView s2, Qt::CaseSensitivity cs = Qt::CaseSensitive)
5859   \overload compare()
5860 */
5861 
5862 /*!
5863   \fn int QString::compare(QStringView s1, const QString &s2, Qt::CaseSensitivity cs = Qt::CaseSensitive)
5864   \overload compare()
5865 */
5866 
5867 /*!
5868     \internal
5869     \since 4.5
5870 */
5871 int QString::compare_helper(const QChar *data1, qsizetype length1, QLatin1String s2,
5872                             Qt::CaseSensitivity cs) noexcept
5873 {
5874     Q_ASSERT(length1 >= 0);
5875     Q_ASSERT(data1 || length1 == 0);
5876     return qt_compare_strings(QStringView(data1, length1), s2, cs);
5877 }
5878 
5879 /*!
5880     \fn int QString::localeAwareCompare(const QString & s1, const QString & s2)
5881 
5882     Compares \a s1 with \a s2 and returns an integer less than, equal
5883     to, or greater than zero if \a s1 is less than, equal to, or
5884     greater than \a s2.
5885 
5886     The comparison is performed in a locale- and also
5887     platform-dependent manner. Use this function to present sorted
5888     lists of strings to the user.
5889 
5890     \sa compare(), QLocale, {Comparing Strings}
5891 */
5892 
5893 /*!
5894     \fn int QString::localeAwareCompare(QStringView other) const
5895     \since 6.0
5896     \overload localeAwareCompare()
5897 
5898     Compares this string with the \a other string and returns an
5899     integer less than, equal to, or greater than zero if this string
5900     is less than, equal to, or greater than the \a other string.
5901 
5902     The comparison is performed in a locale- and also
5903     platform-dependent manner. Use this function to present sorted
5904     lists of strings to the user.
5905 
5906     Same as \c {localeAwareCompare(*this, other)}.
5907 
5908     \sa {Comparing Strings}
5909 */
5910 
5911 /*!
5912     \fn int QString::localeAwareCompare(QStringView s1, QStringView s2)
5913     \since 6.0
5914     \overload localeAwareCompare()
5915 
5916     Compares \a s1 with \a s2 and returns an integer less than, equal
5917     to, or greater than zero if \a s1 is less than, equal to, or
5918     greater than \a s2.
5919 
5920     The comparison is performed in a locale- and also
5921     platform-dependent manner. Use this function to present sorted
5922     lists of strings to the user.
5923 
5924     \sa {Comparing Strings}
5925 */
5926 
5927 
5928 #if !defined(CSTR_LESS_THAN)
5929 #define CSTR_LESS_THAN    1
5930 #define CSTR_EQUAL        2
5931 #define CSTR_GREATER_THAN 3
5932 #endif
5933 
5934 /*!
5935     \overload localeAwareCompare()
5936 
5937     Compares this string with the \a other string and returns an
5938     integer less than, equal to, or greater than zero if this string
5939     is less than, equal to, or greater than the \a other string.
5940 
5941     The comparison is performed in a locale- and also
5942     platform-dependent manner. Use this function to present sorted
5943     lists of strings to the user.
5944 
5945     Same as \c {localeAwareCompare(*this, other)}.
5946 
5947     \sa {Comparing Strings}
5948 */
5949 int QString::localeAwareCompare(const QString &other) const
5950 {
5951     return localeAwareCompare_helper(constData(), length(), other.constData(), other.length());
5952 }
5953 
5954 #if QT_CONFIG(icu)
5955 Q_GLOBAL_STATIC(QThreadStorage<QCollator>, defaultCollator)
5956 #endif
5957 
5958 /*!
5959     \internal
5960     \since 4.5
5961 */
5962 int QString::localeAwareCompare_helper(const QChar *data1, qsizetype length1,
5963                                        const QChar *data2, qsizetype length2)
5964 {
5965     Q_ASSERT(length1 >= 0);
5966     Q_ASSERT(data1 || length1 == 0);
5967     Q_ASSERT(length2 >= 0);
5968     Q_ASSERT(data2 || length2 == 0);
5969 
5970     // do the right thing for null and empty
5971     if (length1 == 0 || length2 == 0)
5972         return qt_compare_strings(QStringView(data1, length1), QStringView(data2, length2),
5973                                Qt::CaseSensitive);
5974 
5975 #if QT_CONFIG(icu)
5976     if (!defaultCollator()->hasLocalData())
5977         defaultCollator()->setLocalData(QCollator());
5978     return defaultCollator()->localData().compare(data1, length1, data2, length2);
5979 #else
5980     const QString lhs = QString::fromRawData(data1, length1).normalized(QString::NormalizationForm_C);
5981     const QString rhs = QString::fromRawData(data2, length2).normalized(QString::NormalizationForm_C);
5982 #  if defined(Q_OS_WIN)
5983     int res = CompareStringEx(LOCALE_NAME_USER_DEFAULT, 0, (LPWSTR)lhs.constData(), lhs.length(), (LPWSTR)rhs.constData(), rhs.length(), NULL, NULL, 0);
5984 
5985     switch (res) {
5986     case CSTR_LESS_THAN:
5987         return -1;
5988     case CSTR_GREATER_THAN:
5989         return 1;
5990     default:
5991         return 0;
5992     }
5993 #  elif defined (Q_OS_DARWIN)
5994     // Use CFStringCompare for comparing strings on Mac. This makes Qt order
5995     // strings the same way as native applications do, and also respects
5996     // the "Order for sorted lists" setting in the International preferences
5997     // panel.
5998     const CFStringRef thisString =
5999         CFStringCreateWithCharactersNoCopy(kCFAllocatorDefault,
6000             reinterpret_cast<const UniChar *>(lhs.constData()), lhs.length(), kCFAllocatorNull);
6001     const CFStringRef otherString =
6002         CFStringCreateWithCharactersNoCopy(kCFAllocatorDefault,
6003             reinterpret_cast<const UniChar *>(rhs.constData()), rhs.length(), kCFAllocatorNull);
6004 
6005     const int result = CFStringCompare(thisString, otherString, kCFCompareLocalized);
6006     CFRelease(thisString);
6007     CFRelease(otherString);
6008     return result;
6009 #  elif defined(Q_OS_UNIX)
6010     // declared in <string.h>
6011     int delta = strcoll(lhs.toLocal8Bit().constData(), rhs.toLocal8Bit().constData());
6012     if (delta == 0)
6013         delta = qt_compare_strings(lhs, rhs, Qt::CaseSensitive);
6014     return delta;
6015 #  else
6016 #     error "This case shouldn't happen"
6017     return qt_compare_strings(lhs, rhs, Qt::CaseSensitive);
6018 #  endif
6019 #endif // !QT_CONFIG(icu)
6020 }
6021 
6022 
6023 /*!
6024     \fn const QChar *QString::unicode() const
6025 
6026     Returns a Unicode representation of the string.
6027     The result remains valid until the string is modified.
6028 
6029     \note The returned string may not be '\\0'-terminated.
6030     Use size() to determine the length of the array.
6031 
6032     \sa utf16(), fromRawData()
6033 */
6034 
6035 /*!
6036     \fn const ushort *QString::utf16() const
6037 
6038     Returns the QString as a '\\0\'-terminated array of unsigned
6039     shorts. The result remains valid until the string is modified.
6040 
6041     The returned string is in host byte order.
6042 
6043     \sa unicode()
6044 */
6045 
6046 const ushort *QString::utf16() const
6047 {
6048     if (!d->isMutable()) {
6049         // ensure '\0'-termination for ::fromRawData strings
6050         const_cast<QString*>(this)->reallocData(size_t(d.size) + 1u, d->detachFlags());
6051     }
6052     return reinterpret_cast<const ushort *>(d.data());
6053 }
6054 
6055 /*!
6056     Returns a string of size \a width that contains this string
6057     padded by the \a fill character.
6058 
6059     If \a truncate is \c false and the size() of the string is more than
6060     \a width, then the returned string is a copy of the string.
6061 
6062     \snippet qstring/main.cpp 32
6063 
6064     If \a truncate is \c true and the size() of the string is more than
6065     \a width, then any characters in a copy of the string after
6066     position \a width are removed, and the copy is returned.
6067 
6068     \snippet qstring/main.cpp 33
6069 
6070     \sa rightJustified()
6071 */
6072 
6073 QString QString::leftJustified(qsizetype width, QChar fill, bool truncate) const
6074 {
6075     QString result;
6076     qsizetype len = length();
6077     qsizetype padlen = width - len;
6078     if (padlen > 0) {
6079         result.resize(len+padlen);
6080         if (len)
6081             memcpy(result.d.data(), d.data(), sizeof(QChar)*len);
6082         QChar *uc = (QChar*)result.d.data() + len;
6083         while (padlen--)
6084            * uc++ = fill;
6085     } else {
6086         if (truncate)
6087             result = left(width);
6088         else
6089             result = *this;
6090     }
6091     return result;
6092 }
6093 
6094 /*!
6095     Returns a string of size() \a width that contains the \a fill
6096     character followed by the string. For example:
6097 
6098     \snippet qstring/main.cpp 49
6099 
6100     If \a truncate is \c false and the size() of the string is more than
6101     \a width, then the returned string is a copy of the string.
6102 
6103     If \a truncate is true and the size() of the string is more than
6104     \a width, then the resulting string is truncated at position \a
6105     width.
6106 
6107     \snippet qstring/main.cpp 50
6108 
6109     \sa leftJustified()
6110 */
6111 
6112 QString QString::rightJustified(qsizetype width, QChar fill, bool truncate) const
6113 {
6114     QString result;
6115     qsizetype len = length();
6116     qsizetype padlen = width - len;
6117     if (padlen > 0) {
6118         result.resize(len+padlen);
6119         QChar *uc = (QChar*)result.d.data();
6120         while (padlen--)
6121            * uc++ = fill;
6122         if (len)
6123           memcpy(static_cast<void *>(uc), static_cast<const void *>(d.data()), sizeof(QChar)*len);
6124     } else {
6125         if (truncate)
6126             result = left(width);
6127         else
6128             result = *this;
6129     }
6130     return result;
6131 }
6132 
6133 /*!
6134     \fn QString QString::toLower() const
6135 
6136     Returns a lowercase copy of the string.
6137 
6138     \snippet qstring/main.cpp 75
6139 
6140     The case conversion will always happen in the 'C' locale. For locale dependent
6141     case folding use QLocale::toLower()
6142 
6143     \sa toUpper(), QLocale::toLower()
6144 */
6145 
6146 namespace QUnicodeTables {
6147 /*
6148     \internal
6149     Converts the \a str string starting from the position pointed to by the \a
6150     it iterator, using the Unicode case traits \c Traits, and returns the
6151     result. The input string must not be empty (the convertCase function below
6152     guarantees that).
6153 
6154     The string type \c{T} is also a template and is either \c{const QString} or
6155     \c{QString}. This function can do both copy-conversion and in-place
6156     conversion depending on the state of the \a str parameter:
6157     \list
6158        \li \c{T} is \c{const QString}: copy-convert
6159        \li \c{T} is \c{QString} and its refcount != 1: copy-convert
6160        \li \c{T} is \c{QString} and its refcount == 1: in-place convert
6161     \endlist
6162 
6163     In copy-convert mode, the local variable \c{s} is detached from the input
6164     \a str. In the in-place convert mode, \a str is in moved-from state (which
6165     this function requires to be a valid, empty string) and \c{s} contains the
6166     only copy of the string, without reallocation (thus, \a it is still valid).
6167 
6168     There is one pathological case left: when the in-place conversion needs to
6169     reallocate memory to grow the buffer. In that case, we need to adjust the \a
6170     it pointer.
6171  */
6172 template <typename T>
6173 Q_NEVER_INLINE
6174 static QString detachAndConvertCase(T &str, QStringIterator it, QUnicodeTables::Case which)
6175 {
6176     Q_ASSERT(!str.isEmpty());
6177     QString s = std::move(str);             // will copy if T is const QString
6178     QChar *pp = s.begin() + it.index(); // will detach if necessary
6179 
6180     do {
6181         const auto folded = fullConvertCase(it.nextUnchecked(), which);
6182         if (Q_UNLIKELY(folded.size() > 1)) {
6183             if (folded.chars[0] == *pp && folded.size() == 2) {
6184                 // special case: only second actually changed (e.g. surrogate pairs),
6185                 // avoid slow case
6186                 ++pp;
6187                 *pp++ = folded.chars[1];
6188             } else {
6189                 // slow path: the string is growing
6190                 qsizetype inpos = it.index() - 1;
6191                 qsizetype outpos = pp - s.constBegin();
6192 
6193                 s.replace(outpos, 1, reinterpret_cast<const QChar *>(folded.data()), folded.size());
6194                 pp = const_cast<QChar *>(s.constBegin()) + outpos + folded.size();
6195 
6196                 // do we need to adjust the input iterator too?
6197                 // if it is pointing to s's data, str is empty
6198                 if (str.isEmpty())
6199                     it = QStringIterator(s.constBegin(), inpos + folded.size(), s.constEnd());
6200             }
6201         } else {
6202             *pp++ = folded.chars[0];
6203         }
6204     } while (it.hasNext());
6205 
6206     return s;
6207 }
6208 
6209 template <typename T>
6210 static QString convertCase(T &str, QUnicodeTables::Case which)
6211 {
6212     const QChar *p = str.constBegin();
6213     const QChar *e = p + str.size();
6214 
6215     // this avoids out of bounds check in the loop
6216     while (e != p && e[-1].isHighSurrogate())
6217         --e;
6218 
6219     QStringIterator it(p, e);
6220     while (it.hasNext()) {
6221         const char32_t uc = it.nextUnchecked();
6222         if (qGetProp(uc)->cases[which].diff) {
6223             it.recedeUnchecked();
6224             return detachAndConvertCase(str, it, which);
6225         }
6226     }
6227     return std::move(str);
6228 }
6229 } // namespace QUnicodeTables
6230 
6231 QString QString::toLower_helper(const QString &str)
6232 {
6233     return QUnicodeTables::convertCase(str, QUnicodeTables::LowerCase);
6234 }
6235 
6236 QString QString::toLower_helper(QString &str)
6237 {
6238     return QUnicodeTables::convertCase(str, QUnicodeTables::LowerCase);
6239 }
6240 
6241 /*!
6242     \fn QString QString::toCaseFolded() const
6243 
6244     Returns the case folded equivalent of the string. For most Unicode
6245     characters this is the same as toLower().
6246 */
6247 
6248 QString QString::toCaseFolded_helper(const QString &str)
6249 {
6250     return QUnicodeTables::convertCase(str, QUnicodeTables::CaseFold);
6251 }
6252 
6253 QString QString::toCaseFolded_helper(QString &str)
6254 {
6255     return QUnicodeTables::convertCase(str, QUnicodeTables::CaseFold);
6256 }
6257 
6258 /*!
6259     \fn QString QString::toUpper() const
6260 
6261     Returns an uppercase copy of the string.
6262 
6263     \snippet qstring/main.cpp 81
6264 
6265     The case conversion will always happen in the 'C' locale. For locale dependent
6266     case folding use QLocale::toUpper()
6267 
6268     \sa toLower(), QLocale::toLower()
6269 */
6270 
6271 QString QString::toUpper_helper(const QString &str)
6272 {
6273     return QUnicodeTables::convertCase(str, QUnicodeTables::UpperCase);
6274 }
6275 
6276 QString QString::toUpper_helper(QString &str)
6277 {
6278     return QUnicodeTables::convertCase(str, QUnicodeTables::UpperCase);
6279 }
6280 
6281 // ### Qt 6: Consider whether this function shouldn't be removed See task 202871.
6282 /*!
6283     \since 5.5
6284 
6285     Safely builds a formatted string from the format string \a cformat
6286     and an arbitrary list of arguments.
6287 
6288     The format string supports the conversion specifiers, length modifiers,
6289     and flags provided by printf() in the standard C++ library. The \a cformat
6290     string and \c{%s} arguments must be UTF-8 encoded.
6291 
6292     \note The \c{%lc} escape sequence expects a unicode character of type
6293     \c char16_t, or \c ushort (as returned by QChar::unicode()).
6294     The \c{%ls} escape sequence expects a pointer to a zero-terminated array
6295     of unicode characters of type \c char16_t, or ushort (as returned by
6296     QString::utf16()). This is at odds with the printf() in the standard C++
6297     library, which defines \c {%lc} to print a wchar_t and \c{%ls} to print
6298     a \c{wchar_t*}, and might also produce compiler warnings on platforms
6299     where the size of \c {wchar_t} is not 16 bits.
6300 
6301     \warning We do not recommend using QString::asprintf() in new Qt
6302     code. Instead, consider using QTextStream or arg(), both of
6303     which support Unicode strings seamlessly and are type-safe.
6304     Here is an example that uses QTextStream:
6305 
6306     \snippet qstring/main.cpp 64
6307 
6308     For \l {QObject::tr()}{translations}, especially if the strings
6309     contains more than one escape sequence, you should consider using
6310     the arg() function instead. This allows the order of the
6311     replacements to be controlled by the translator.
6312 
6313     \sa arg()
6314 */
6315 
6316 QString QString::asprintf(const char *cformat, ...)
6317 {
6318     va_list ap;
6319     va_start(ap, cformat);
6320     const QString s = vasprintf(cformat, ap);
6321     va_end(ap);
6322     return s;
6323 }
6324 
6325 static void append_utf8(QString &qs, const char *cs, int len)
6326 {
6327     const int oldSize = qs.size();
6328     qs.resize(oldSize + len);
6329     const QChar *newEnd = QUtf8::convertToUnicode(qs.data() + oldSize, cs, len);
6330     qs.resize(newEnd - qs.constData());
6331 }
6332 
6333 static uint parse_flag_characters(const char * &c) noexcept
6334 {
6335     uint flags = QLocaleData::ZeroPadExponent;
6336     while (true) {
6337         switch (*c) {
6338         case '#':
6339             flags |= QLocaleData::ShowBase | QLocaleData::AddTrailingZeroes
6340                     | QLocaleData::ForcePoint;
6341             break;
6342         case '0': flags |= QLocaleData::ZeroPadded; break;
6343         case '-': flags |= QLocaleData::LeftAdjusted; break;
6344         case ' ': flags |= QLocaleData::BlankBeforePositive; break;
6345         case '+': flags |= QLocaleData::AlwaysShowSign; break;
6346         case '\'': flags |= QLocaleData::GroupDigits; break;
6347         default: return flags;
6348         }
6349         ++c;
6350     }
6351 }
6352 
6353 static int parse_field_width(const char * &c)
6354 {
6355     Q_ASSERT(qIsDigit(*c));
6356 
6357     // can't be negative - started with a digit
6358     // contains at least one digit
6359     const char *endp;
6360     bool ok;
6361     const qulonglong result = qstrtoull(c, &endp, 10, &ok);
6362     c = endp;
6363     while (qIsDigit(*c)) // preserve Qt 5.5 behavior of consuming all digits, no matter how many
6364         ++c;
6365     return ok && result < qulonglong(std::numeric_limits<int>::max()) ? int(result) : 0;
6366 }
6367 
6368 enum LengthMod { lm_none, lm_hh, lm_h, lm_l, lm_ll, lm_L, lm_j, lm_z, lm_t };
6369 
6370 static inline bool can_consume(const char * &c, char ch) noexcept
6371 {
6372     if (*c == ch) {
6373         ++c;
6374         return true;
6375     }
6376     return false;
6377 }
6378 
6379 static LengthMod parse_length_modifier(const char * &c) noexcept
6380 {
6381     switch (*c++) {
6382     case 'h': return can_consume(c, 'h') ? lm_hh : lm_h;
6383     case 'l': return can_consume(c, 'l') ? lm_ll : lm_l;
6384     case 'L': return lm_L;
6385     case 'j': return lm_j;
6386     case 'z':
6387     case 'Z': return lm_z;
6388     case 't': return lm_t;
6389     }
6390     --c; // don't consume *c - it wasn't a flag
6391     return lm_none;
6392 }
6393 
6394 /*!
6395     \fn QString QString::vasprintf(const char *cformat, va_list ap)
6396     \since 5.5
6397 
6398     Equivalent method to asprintf(), but takes a va_list \a ap
6399     instead a list of variable arguments. See the asprintf()
6400     documentation for an explanation of \a cformat.
6401 
6402     This method does not call the va_end macro, the caller
6403     is responsible to call va_end on \a ap.
6404 
6405     \sa asprintf()
6406 */
6407 
6408 QString QString::vasprintf(const char *cformat, va_list ap)
6409 {
6410     if (!cformat || !*cformat) {
6411         // Qt 1.x compat
6412         return fromLatin1("");
6413     }
6414 
6415     // Parse cformat
6416 
6417     QString result;
6418     const char *c = cformat;
6419     for (;;) {
6420         // Copy non-escape chars to result
6421         const char *cb = c;
6422         while (*c != '\0' && *c != '%')
6423             c++;
6424         append_utf8(result, cb, qsizetype(c - cb));
6425 
6426         if (*c == '\0')
6427             break;
6428 
6429         // Found '%'
6430         const char *escape_start = c;
6431         ++c;
6432 
6433         if (*c == '\0') {
6434             result.append(QLatin1Char('%')); // a % at the end of the string - treat as non-escape text
6435             break;
6436         }
6437         if (*c == '%') {
6438             result.append(QLatin1Char('%')); // %%
6439             ++c;
6440             continue;
6441         }
6442 
6443         uint flags = parse_flag_characters(c);
6444 
6445         if (*c == '\0') {
6446             result.append(QLatin1String(escape_start)); // incomplete escape, treat as non-escape text
6447             break;
6448         }
6449 
6450         // Parse field width
6451         int width = -1; // -1 means unspecified
6452         if (qIsDigit(*c)) {
6453             width = parse_field_width(c);
6454         } else if (*c == '*') { // can't parse this in another function, not portably, at least
6455             width = va_arg(ap, int);
6456             if (width < 0)
6457                 width = -1; // treat all negative numbers as unspecified
6458             ++c;
6459         }
6460 
6461         if (*c == '\0') {
6462             result.append(QLatin1String(escape_start)); // incomplete escape, treat as non-escape text
6463             break;
6464         }
6465 
6466         // Parse precision
6467         int precision = -1; // -1 means unspecified
6468         if (*c == '.') {
6469             ++c;
6470             if (qIsDigit(*c)) {
6471                 precision = parse_field_width(c);
6472             } else if (*c == '*') { // can't parse this in another function, not portably, at least
6473                 precision = va_arg(ap, int);
6474                 if (precision < 0)
6475                     precision = -1; // treat all negative numbers as unspecified
6476                 ++c;
6477             }
6478         }
6479 
6480         if (*c == '\0') {
6481             result.append(QLatin1String(escape_start)); // incomplete escape, treat as non-escape text
6482             break;
6483         }
6484 
6485         const LengthMod length_mod = parse_length_modifier(c);
6486 
6487         if (*c == '\0') {
6488             result.append(QLatin1String(escape_start)); // incomplete escape, treat as non-escape text
6489             break;
6490         }
6491 
6492         // Parse the conversion specifier and do the conversion
6493         QString subst;
6494         switch (*c) {
6495             case 'd':
6496             case 'i': {
6497                 qint64 i;
6498                 switch (length_mod) {
6499                     case lm_none: i = va_arg(ap, int); break;
6500                     case lm_hh: i = va_arg(ap, int); break;
6501                     case lm_h: i = va_arg(ap, int); break;
6502                     case lm_l: i = va_arg(ap, long int); break;
6503                     case lm_ll: i = va_arg(ap, qint64); break;
6504                     case lm_j: i = va_arg(ap, long int); break;
6505 
6506                     /* ptrdiff_t actually, but it should be the same for us */
6507                     case lm_z: i = va_arg(ap, qsizetype); break;
6508                     case lm_t: i = va_arg(ap, qsizetype); break;
6509                     default: i = 0; break;
6510                 }
6511                 subst = QLocaleData::c()->longLongToString(i, precision, 10, width, flags);
6512                 ++c;
6513                 break;
6514             }
6515             case 'o':
6516             case 'u':
6517             case 'x':
6518             case 'X': {
6519                 quint64 u;
6520                 switch (length_mod) {
6521                     case lm_none: u = va_arg(ap, uint); break;
6522                     case lm_hh: u = va_arg(ap, uint); break;
6523                     case lm_h: u = va_arg(ap, uint); break;
6524                     case lm_l: u = va_arg(ap, ulong); break;
6525                     case lm_ll: u = va_arg(ap, quint64); break;
6526                     case lm_t: u = va_arg(ap, size_t); break;
6527                     case lm_z: u = va_arg(ap, size_t); break;
6528                     default: u = 0; break;
6529                 }
6530 
6531                 if (qIsUpper(*c))
6532                     flags |= QLocaleData::CapitalEorX;
6533 
6534                 int base = 10;
6535                 switch (qToLower(*c)) {
6536                     case 'o':
6537                         base = 8; break;
6538                     case 'u':
6539                         base = 10; break;
6540                     case 'x':
6541                         base = 16; break;
6542                     default: break;
6543                 }
6544                 subst = QLocaleData::c()->unsLongLongToString(u, precision, base, width, flags);
6545                 ++c;
6546                 break;
6547             }
6548             case 'E':
6549             case 'e':
6550             case 'F':
6551             case 'f':
6552             case 'G':
6553             case 'g':
6554             case 'A':
6555             case 'a': {
6556                 double d;
6557                 if (length_mod == lm_L)
6558                     d = va_arg(ap, long double); // not supported - converted to a double
6559                 else
6560                     d = va_arg(ap, double);
6561 
6562                 if (qIsUpper(*c))
6563                     flags |= QLocaleData::CapitalEorX;
6564 
6565                 QLocaleData::DoubleForm form = QLocaleData::DFDecimal;
6566                 switch (qToLower(*c)) {
6567                     case 'e': form = QLocaleData::DFExponent; break;
6568                     case 'a':                             // not supported - decimal form used instead
6569                     case 'f': form = QLocaleData::DFDecimal; break;
6570                     case 'g': form = QLocaleData::DFSignificantDigits; break;
6571                     default: break;
6572                 }
6573                 subst = QLocaleData::c()->doubleToString(d, precision, form, width, flags);
6574                 ++c;
6575                 break;
6576             }
6577             case 'c': {
6578                 if (length_mod == lm_l)
6579                     subst = QChar::fromUcs2(va_arg(ap, int));
6580                 else
6581                     subst = QLatin1Char((uchar) va_arg(ap, int));
6582                 ++c;
6583                 break;
6584             }
6585             case 's': {
6586                 if (length_mod == lm_l) {
6587                     const ushort *buff = va_arg(ap, const ushort*);
6588                     const ushort *ch = buff;
6589                     while (*ch != 0)
6590                         ++ch;
6591                     subst.setUtf16(buff, ch - buff);
6592                 } else
6593                     subst = QString::fromUtf8(va_arg(ap, const char*));
6594                 if (precision != -1)
6595                     subst.truncate(precision);
6596                 ++c;
6597                 break;
6598             }
6599             case 'p': {
6600                 void *arg = va_arg(ap, void*);
6601                 const quint64 i = reinterpret_cast<quintptr>(arg);
6602                 flags |= QLocaleData::ShowBase;
6603                 subst = QLocaleData::c()->unsLongLongToString(i, precision, 16, width, flags);
6604                 ++c;
6605                 break;
6606             }
6607             case 'n':
6608                 switch (length_mod) {
6609                     case lm_hh: {
6610                         signed char *n = va_arg(ap, signed char*);
6611                         *n = result.length();
6612                         break;
6613                     }
6614                     case lm_h: {
6615                         short int *n = va_arg(ap, short int*);
6616                         *n = result.length();
6617                             break;
6618                     }
6619                     case lm_l: {
6620                         long int *n = va_arg(ap, long int*);
6621                         *n = result.length();
6622                         break;
6623                     }
6624                     case lm_ll: {
6625                         qint64 *n = va_arg(ap, qint64*);
6626                         *n = result.length();
6627                         break;
6628                     }
6629                     default: {
6630                         int *n = va_arg(ap, int*);
6631                         *n = result.length();
6632                         break;
6633                     }
6634                 }
6635                 ++c;
6636                 break;
6637 
6638             default: // bad escape, treat as non-escape text
6639                 for (const char *cc = escape_start; cc != c; ++cc)
6640                     result.append(QLatin1Char(*cc));
6641                 continue;
6642         }
6643 
6644         if (flags & QLocaleData::LeftAdjusted)
6645             result.append(subst.leftJustified(width));
6646         else
6647             result.append(subst.rightJustified(width));
6648     }
6649 
6650     return result;
6651 }
6652 
6653 /*!
6654     Returns the string converted to a \c{long long} using base \a
6655     base, which is 10 by default and must be between 2 and 36, or 0.
6656     Returns 0 if the conversion fails.
6657 
6658     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
6659     to \c false, and success by setting *\a{ok} to \c true.
6660 
6661     If \a base is 0, the C language convention is used: If the string
6662     begins with "0x", base 16 is used; if the string begins with "0",
6663     base 8 is used; otherwise, base 10 is used.
6664 
6665     The string conversion will always happen in the 'C' locale. For locale
6666     dependent conversion use QLocale::toLongLong()
6667 
6668     Example:
6669 
6670     \snippet qstring/main.cpp 74
6671 
6672     This function ignores leading and trailing whitespace.
6673 
6674     \sa number(), toULongLong(), toInt(), QLocale::toLongLong()
6675 */
6676 
6677 qint64 QString::toLongLong(bool *ok, int base) const
6678 {
6679     return toIntegral_helper<qlonglong>(*this, ok, base);
6680 }
6681 
6682 qlonglong QString::toIntegral_helper(QStringView string, bool *ok, int base)
6683 {
6684 #if defined(QT_CHECK_RANGE)
6685     if (base != 0 && (base < 2 || base > 36)) {
6686         qWarning("QString::toULongLong: Invalid base (%d)", base);
6687         base = 10;
6688     }
6689 #endif
6690 
6691     return QLocaleData::c()->stringToLongLong(string, base, ok, QLocale::RejectGroupSeparator);
6692 }
6693 
6694 
6695 /*!
6696     Returns the string converted to an \c{unsigned long long} using base \a
6697     base, which is 10 by default and must be between 2 and 36, or 0.
6698     Returns 0 if the conversion fails.
6699 
6700     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
6701     to \c false, and success by setting *\a{ok} to \c true.
6702 
6703     If \a base is 0, the C language convention is used: If the string
6704     begins with "0x", base 16 is used; if the string begins with "0",
6705     base 8 is used; otherwise, base 10 is used.
6706 
6707     The string conversion will always happen in the 'C' locale. For locale
6708     dependent conversion use QLocale::toULongLong()
6709 
6710     Example:
6711 
6712     \snippet qstring/main.cpp 79
6713 
6714     This function ignores leading and trailing whitespace.
6715 
6716     \sa number(), toLongLong(), QLocale::toULongLong()
6717 */
6718 
6719 quint64 QString::toULongLong(bool *ok, int base) const
6720 {
6721     return toIntegral_helper<qulonglong>(*this, ok, base);
6722 }
6723 
6724 qulonglong QString::toIntegral_helper(QStringView string, bool *ok, uint base)
6725 {
6726 #if defined(QT_CHECK_RANGE)
6727     if (base != 0 && (base < 2 || base > 36)) {
6728         qWarning("QString::toULongLong: Invalid base (%d)", base);
6729         base = 10;
6730     }
6731 #endif
6732 
6733     return QLocaleData::c()->stringToUnsLongLong(string, base, ok, QLocale::RejectGroupSeparator);
6734 }
6735 
6736 /*!
6737     \fn long QString::toLong(bool *ok, int base) const
6738 
6739     Returns the string converted to a \c long using base \a
6740     base, which is 10 by default and must be between 2 and 36, or 0.
6741     Returns 0 if the conversion fails.
6742 
6743     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
6744     to \c false, and success by setting *\a{ok} to \c true.
6745 
6746     If \a base is 0, the C language convention is used: If the string
6747     begins with "0x", base 16 is used; if the string begins with "0",
6748     base 8 is used; otherwise, base 10 is used.
6749 
6750     The string conversion will always happen in the 'C' locale. For locale
6751     dependent conversion use QLocale::toLongLong()
6752 
6753     Example:
6754 
6755     \snippet qstring/main.cpp 73
6756 
6757     This function ignores leading and trailing whitespace.
6758 
6759     \sa number(), toULong(), toInt(), QLocale::toInt()
6760 */
6761 
6762 long QString::toLong(bool *ok, int base) const
6763 {
6764     return toIntegral_helper<long>(*this, ok, base);
6765 }
6766 
6767 /*!
6768     \fn ulong QString::toULong(bool *ok, int base) const
6769 
6770     Returns the string converted to an \c{unsigned long} using base \a
6771     base, which is 10 by default and must be between 2 and 36, or 0.
6772     Returns 0 if the conversion fails.
6773 
6774     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
6775     to \c false, and success by setting *\a{ok} to \c true.
6776 
6777     If \a base is 0, the C language convention is used: If the string
6778     begins with "0x", base 16 is used; if the string begins with "0",
6779     base 8 is used; otherwise, base 10 is used.
6780 
6781     The string conversion will always happen in the 'C' locale. For locale
6782     dependent conversion use QLocale::toULongLong()
6783 
6784     Example:
6785 
6786     \snippet qstring/main.cpp 78
6787 
6788     This function ignores leading and trailing whitespace.
6789 
6790     \sa number(), QLocale::toUInt()
6791 */
6792 
6793 ulong QString::toULong(bool *ok, int base) const
6794 {
6795     return toIntegral_helper<ulong>(*this, ok, base);
6796 }
6797 
6798 
6799 /*!
6800     Returns the string converted to an \c int using base \a
6801     base, which is 10 by default and must be between 2 and 36, or 0.
6802     Returns 0 if the conversion fails.
6803 
6804     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
6805     to \c false, and success by setting *\a{ok} to \c true.
6806 
6807     If \a base is 0, the C language convention is used: If the string
6808     begins with "0x", base 16 is used; if the string begins with "0",
6809     base 8 is used; otherwise, base 10 is used.
6810 
6811     The string conversion will always happen in the 'C' locale. For locale
6812     dependent conversion use QLocale::toInt()
6813 
6814     Example:
6815 
6816     \snippet qstring/main.cpp 72
6817 
6818     This function ignores leading and trailing whitespace.
6819 
6820     \sa number(), toUInt(), toDouble(), QLocale::toInt()
6821 */
6822 
6823 int QString::toInt(bool *ok, int base) const
6824 {
6825     return toIntegral_helper<int>(*this, ok, base);
6826 }
6827 
6828 /*!
6829     Returns the string converted to an \c{unsigned int} using base \a
6830     base, which is 10 by default and must be between 2 and 36, or 0.
6831     Returns 0 if the conversion fails.
6832 
6833     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
6834     to \c false, and success by setting *\a{ok} to \c true.
6835 
6836     If \a base is 0, the C language convention is used: If the string
6837     begins with "0x", base 16 is used; if the string begins with "0",
6838     base 8 is used; otherwise, base 10 is used.
6839 
6840     The string conversion will always happen in the 'C' locale. For locale
6841     dependent conversion use QLocale::toUInt()
6842 
6843     Example:
6844 
6845     \snippet qstring/main.cpp 77
6846 
6847     This function ignores leading and trailing whitespace.
6848 
6849     \sa number(), toInt(), QLocale::toUInt()
6850 */
6851 
6852 uint QString::toUInt(bool *ok, int base) const
6853 {
6854     return toIntegral_helper<uint>(*this, ok, base);
6855 }
6856 
6857 /*!
6858     Returns the string converted to a \c short using base \a
6859     base, which is 10 by default and must be between 2 and 36, or 0.
6860     Returns 0 if the conversion fails.
6861 
6862     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
6863     to \c false, and success by setting *\a{ok} to \c true.
6864 
6865     If \a base is 0, the C language convention is used: If the string
6866     begins with "0x", base 16 is used; if the string begins with "0",
6867     base 8 is used; otherwise, base 10 is used.
6868 
6869     The string conversion will always happen in the 'C' locale. For locale
6870     dependent conversion use QLocale::toShort()
6871 
6872     Example:
6873 
6874     \snippet qstring/main.cpp 76
6875 
6876     This function ignores leading and trailing whitespace.
6877 
6878     \sa number(), toUShort(), toInt(), QLocale::toShort()
6879 */
6880 
6881 short QString::toShort(bool *ok, int base) const
6882 {
6883     return toIntegral_helper<short>(*this, ok, base);
6884 }
6885 
6886 /*!
6887     Returns the string converted to an \c{unsigned short} using base \a
6888     base, which is 10 by default and must be between 2 and 36, or 0.
6889     Returns 0 if the conversion fails.
6890 
6891     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
6892     to \c false, and success by setting *\a{ok} to \c true.
6893 
6894     If \a base is 0, the C language convention is used: If the string
6895     begins with "0x", base 16 is used; if the string begins with "0",
6896     base 8 is used; otherwise, base 10 is used.
6897 
6898     The string conversion will always happen in the 'C' locale. For locale
6899     dependent conversion use QLocale::toUShort()
6900 
6901     Example:
6902 
6903     \snippet qstring/main.cpp 80
6904 
6905     This function ignores leading and trailing whitespace.
6906 
6907     \sa number(), toShort(), QLocale::toUShort()
6908 */
6909 
6910 ushort QString::toUShort(bool *ok, int base) const
6911 {
6912     return toIntegral_helper<ushort>(*this, ok, base);
6913 }
6914 
6915 
6916 /*!
6917     Returns the string converted to a \c double value.
6918 
6919     Returns an infinity if the conversion overflows or 0.0 if the
6920     conversion fails for other reasons (e.g. underflow).
6921 
6922     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
6923     to \c false, and success by setting *\a{ok} to \c true.
6924 
6925     \snippet qstring/main.cpp 66
6926 
6927     \warning The QString content may only contain valid numerical characters
6928     which includes the plus/minus sign, the character e used in scientific
6929     notation, and the decimal point. Including the unit or additional characters
6930     leads to a conversion error.
6931 
6932     \snippet qstring/main.cpp 67
6933 
6934     The string conversion will always happen in the 'C' locale. For locale
6935     dependent conversion use QLocale::toDouble()
6936 
6937     \snippet qstring/main.cpp 68
6938 
6939     For historical reasons, this function does not handle
6940     thousands group separators. If you need to convert such numbers,
6941     use QLocale::toDouble().
6942 
6943     \snippet qstring/main.cpp 69
6944 
6945     This function ignores leading and trailing whitespace.
6946 
6947     \sa number(), QLocale::setDefault(), QLocale::toDouble(), trimmed()
6948 */
6949 
6950 double QString::toDouble(bool *ok) const
6951 {
6952     return QLocaleData::c()->stringToDouble(*this, ok, QLocale::RejectGroupSeparator);
6953 }
6954 
6955 /*!
6956     Returns the string converted to a \c float value.
6957 
6958     Returns an infinity if the conversion overflows or 0.0 if the
6959     conversion fails for other reasons (e.g. underflow).
6960 
6961     If \a ok is not \nullptr, failure is reported by setting *\a{ok}
6962     to \c false, and success by setting *\a{ok} to \c true.
6963 
6964     \warning The QString content may only contain valid numerical characters
6965     which includes the plus/minus sign, the character e used in scientific
6966     notation, and the decimal point. Including the unit or additional characters
6967     leads to a conversion error.
6968 
6969     The string conversion will always happen in the 'C' locale. For locale
6970     dependent conversion use QLocale::toFloat()
6971 
6972     For historical reasons, this function does not handle
6973     thousands group separators. If you need to convert such numbers,
6974     use QLocale::toFloat().
6975 
6976     Example:
6977 
6978     \snippet qstring/main.cpp 71
6979 
6980     This function ignores leading and trailing whitespace.
6981 
6982     \sa number(), toDouble(), toInt(), QLocale::toFloat(), trimmed()
6983 */
6984 
6985 float QString::toFloat(bool *ok) const
6986 {
6987     return QLocaleData::convertDoubleToFloat(toDouble(ok), ok);
6988 }
6989 
6990 /*! \fn QString &QString::setNum(int n, int base)
6991 
6992     Sets the string to the printed value of \a n in the specified \a
6993     base, and returns a reference to the string.
6994 
6995     The base is 10 by default and must be between 2 and 36. For bases
6996     other than 10, \a n is treated as an unsigned integer.
6997 
6998     \snippet qstring/main.cpp 56
6999 
7000    The formatting always uses QLocale::C, i.e., English/UnitedStates.
7001    To get a localized string representation of a number, use
7002    QLocale::toString() with the appropriate locale.
7003 
7004    \sa number()
7005 */
7006 
7007 /*! \fn QString &QString::setNum(uint n, int base)
7008 
7009     \overload
7010 */
7011 
7012 /*! \fn QString &QString::setNum(long n, int base)
7013 
7014     \overload
7015 */
7016 
7017 /*! \fn QString &QString::setNum(ulong n, int base)
7018 
7019     \overload
7020 */
7021 
7022 /*!
7023     \overload
7024 */
7025 QString &QString::setNum(qlonglong n, int base)
7026 {
7027     return *this = number(n, base);
7028 }
7029 
7030 /*!
7031     \overload
7032 */
7033 QString &QString::setNum(qulonglong n, int base)
7034 {
7035     return *this = number(n, base);
7036 }
7037 
7038 /*! \fn QString &QString::setNum(short n, int base)
7039 
7040     \overload
7041 */
7042 
7043 /*! \fn QString &QString::setNum(ushort n, int base)
7044 
7045     \overload
7046 */
7047 
7048 /*!
7049     \fn QString &QString::setNum(double n, char format, int precision)
7050     \overload
7051 
7052     Sets the string to the printed value of \a n, formatted according
7053     to the given \a format and \a precision, and returns a reference
7054     to the string.
7055 
7056     The \a format can be 'e', 'E', 'f', 'g' or 'G' (see
7057     \l{Argument Formats} for an explanation of the formats).
7058 
7059     The formatting always uses QLocale::C, i.e., English/UnitedStates.
7060     To get a localized string representation of a number, use
7061     QLocale::toString() with the appropriate locale.
7062 
7063     \sa number()
7064 */
7065 
7066 QString &QString::setNum(double n, char f, int prec)
7067 {
7068     return *this = number(n, f, prec);
7069 }
7070 
7071 /*!
7072     \fn QString &QString::setNum(float n, char format, int precision)
7073     \overload
7074 
7075     Sets the string to the printed value of \a n, formatted according
7076     to the given \a format and \a precision, and returns a reference
7077     to the string.
7078 
7079     The formatting always uses QLocale::C, i.e., English/UnitedStates.
7080     To get a localized string representation of a number, use
7081     QLocale::toString() with the appropriate locale.
7082 
7083     \sa number()
7084 */
7085 
7086 
7087 /*!
7088     \fn QString QString::number(long n, int base)
7089 
7090     Returns a string equivalent of the number \a n according to the
7091     specified \a base.
7092 
7093     The base is 10 by default and must be between 2
7094     and 36. For bases other than 10, \a n is treated as an
7095     unsigned integer.
7096 
7097     The formatting always uses QLocale::C, i.e., English/UnitedStates.
7098     To get a localized string representation of a number, use
7099     QLocale::toString() with the appropriate locale.
7100 
7101     \snippet qstring/main.cpp 35
7102 
7103     \sa setNum()
7104 */
7105 
7106 QString QString::number(long n, int base)
7107 {
7108     return number(qlonglong(n), base);
7109 }
7110 
7111 /*!
7112   \fn QString QString::number(ulong n, int base)
7113 
7114     \overload
7115 */
7116 QString QString::number(ulong n, int base)
7117 {
7118     return number(qulonglong(n), base);
7119 }
7120 
7121 /*!
7122     \overload
7123 */
7124 QString QString::number(int n, int base)
7125 {
7126     return number(qlonglong(n), base);
7127 }
7128 
7129 /*!
7130     \overload
7131 */
7132 QString QString::number(uint n, int base)
7133 {
7134     return number(qulonglong(n), base);
7135 }
7136 
7137 /*!
7138     \overload
7139 */
7140 QString QString::number(qlonglong n, int base)
7141 {
7142 #if defined(QT_CHECK_RANGE)
7143     if (base < 2 || base > 36) {
7144         qWarning("QString::setNum: Invalid base (%d)", base);
7145         base = 10;
7146     }
7147 #endif
7148     return QLocaleData::c()->longLongToString(n, -1, base);
7149 }
7150 
7151 /*!
7152     \overload
7153 */
7154 QString QString::number(qulonglong n, int base)
7155 {
7156 #if defined(QT_CHECK_RANGE)
7157     if (base < 2 || base > 36) {
7158         qWarning("QString::setNum: Invalid base (%d)", base);
7159         base = 10;
7160     }
7161 #endif
7162     return QLocaleData::c()->unsLongLongToString(n, -1, base);
7163 }
7164 
7165 
7166 /*!
7167     \fn QString QString::number(double n, char format, int precision)
7168 
7169     Returns a string equivalent of the number \a n, formatted
7170     according to the specified \a format and \a precision. See
7171     \l{Argument Formats} for details.
7172 
7173     Unlike QLocale::toString(), this function does not honor the
7174     user's locale settings.
7175 
7176     \sa setNum(), QLocale::toString()
7177 */
7178 QString QString::number(double n, char f, int prec)
7179 {
7180     QLocaleData::DoubleForm form = QLocaleData::DFDecimal;
7181     uint flags = QLocaleData::ZeroPadExponent;
7182 
7183     if (qIsUpper(f))
7184         flags |= QLocaleData::CapitalEorX;
7185 
7186     switch (qToLower(f)) {
7187         case 'f':
7188             form = QLocaleData::DFDecimal;
7189             break;
7190         case 'e':
7191             form = QLocaleData::DFExponent;
7192             break;
7193         case 'g':
7194             form = QLocaleData::DFSignificantDigits;
7195             break;
7196         default:
7197 #if defined(QT_CHECK_RANGE)
7198             qWarning("QString::setNum: Invalid format char '%c'", f);
7199 #endif
7200             break;
7201     }
7202 
7203     return QLocaleData::c()->doubleToString(n, prec, form, -1, flags);
7204 }
7205 
7206 namespace {
7207 template<class ResultList, class StringSource>
7208 static ResultList splitString(const StringSource &source, QStringView sep,
7209                               Qt::SplitBehavior behavior, Qt::CaseSensitivity cs)
7210 {
7211     ResultList list;
7212     typename StringSource::size_type start = 0;
7213     typename StringSource::size_type end;
7214     typename StringSource::size_type extra = 0;
7215     while ((end = QtPrivate::findString(QStringView(source.constData(), source.size()), start + extra, sep, cs)) != -1) {
7216         if (start != end || behavior == Qt::KeepEmptyParts)
7217             list.append(source.mid(start, end - start));
7218         start = end + sep.size();
7219         extra = (sep.size() == 0 ? 1 : 0);
7220     }
7221     if (start != source.size() || behavior == Qt::KeepEmptyParts)
7222         list.append(source.mid(start));
7223     return list;
7224 }
7225 
7226 } // namespace
7227 
7228 /*!
7229     Splits the string into substrings wherever \a sep occurs, and
7230     returns the list of those strings. If \a sep does not match
7231     anywhere in the string, split() returns a single-element list
7232     containing this string.
7233 
7234     \a cs specifies whether \a sep should be matched case
7235     sensitively or case insensitively.
7236 
7237     If \a behavior is QString::SkipEmptyParts, empty entries don't
7238     appear in the result. By default, empty entries are kept.
7239 
7240     Example:
7241 
7242     \snippet qstring/main.cpp 62
7243 
7244     If \a sep is empty, split() returns an empty string, followed
7245     by each of the string's characters, followed by another empty string:
7246 
7247     \snippet qstring/main.cpp 62-empty
7248 
7249     To understand this behavior, recall that the empty string matches
7250     everywhere, so the above is qualitatively the same as:
7251 
7252     \snippet qstring/main.cpp 62-slashes
7253 
7254     \sa QStringList::join(), section()
7255 
7256     \since 5.14
7257 */
7258 QStringList QString::split(const QString &sep, Qt::SplitBehavior behavior, Qt::CaseSensitivity cs) const
7259 {
7260     return splitString<QStringList>(*this, sep, behavior, cs);
7261 }
7262 
7263 /*!
7264     \overload
7265     \since 5.14
7266 */
7267 QStringList QString::split(QChar sep, Qt::SplitBehavior behavior, Qt::CaseSensitivity cs) const
7268 {
7269     return splitString<QStringList>(*this, QStringView(&sep, 1), behavior, cs);
7270 }
7271 
7272 /*!
7273     \fn QList<QStringView> QStringView::split(QChar sep, Qt::SplitBehavior behavior, Qt::CaseSensitivity cs) const
7274     \fn QList<QStringView> QStringView::split(QStringView sep, Qt::SplitBehavior behavior, Qt::CaseSensitivity cs) const
7275 
7276 
7277     Splits the string into substring references wherever \a sep occurs, and
7278     returns the list of those strings.
7279 
7280     See QString::split() for how \a sep, \a behavior and \a cs interact to form
7281     the result.
7282 
7283     \note All references are valid as long this string is alive. Destroying this
7284     string will cause all references to be dangling pointers.
7285 
7286     \since 6.0
7287 */
7288 QList<QStringView> QStringView::split(QStringView sep, Qt::SplitBehavior behavior, Qt::CaseSensitivity cs) const
7289 {
7290     return splitString<QList<QStringView>>(QStringView(*this), sep, behavior, cs);
7291 }
7292 
7293 QList<QStringView> QStringView::split(QChar sep, Qt::SplitBehavior behavior, Qt::CaseSensitivity cs) const
7294 {
7295     return split(QStringView(&sep, 1), behavior, cs);
7296 }
7297 
7298 #if QT_CONFIG(regularexpression)
7299 namespace {
7300 template<class ResultList, typename String>
7301 static ResultList splitString(const String &source, const QRegularExpression &re,
7302                               Qt::SplitBehavior behavior)
7303 {
7304     ResultList list;
7305     if (!re.isValid()) {
7306         qWarning("QString::split: invalid QRegularExpression object");
7307         return list;
7308     }
7309 
7310     qsizetype start = 0;
7311     qsizetype end = 0;
7312     QRegularExpressionMatchIterator iterator = re.globalMatch(source);
7313     while (iterator.hasNext()) {
7314         QRegularExpressionMatch match = iterator.next();
7315         end = match.capturedStart();
7316         if (start != end || behavior == Qt::KeepEmptyParts)
7317             list.append(source.mid(start, end - start));
7318         start = match.capturedEnd();
7319     }
7320 
7321     if (start != source.size() || behavior == Qt::KeepEmptyParts)
7322         list.append(source.mid(start));
7323 
7324     return list;
7325 }
7326 } // namespace
7327 
7328 /*!
7329     \overload
7330     \since 5.14
7331 
7332     Splits the string into substrings wherever the regular expression
7333     \a re matches, and returns the list of those strings. If \a re
7334     does not match anywhere in the string, split() returns a
7335     single-element list containing this string.
7336 
7337     Here is an example where we extract the words in a sentence
7338     using one or more whitespace characters as the separator:
7339 
7340     \snippet qstring/main.cpp 90
7341 
7342     Here is a similar example, but this time we use any sequence of
7343     non-word characters as the separator:
7344 
7345     \snippet qstring/main.cpp 91
7346 
7347     Here is a third example where we use a zero-length assertion,
7348     \b{\\b} (word boundary), to split the string into an
7349     alternating sequence of non-word and word tokens:
7350 
7351     \snippet qstring/main.cpp 92
7352 
7353     \sa QStringList::join(), section()
7354 */
7355 QStringList QString::split(const QRegularExpression &re, Qt::SplitBehavior behavior) const
7356 {
7357     return splitString<QStringList>(*this, re, behavior);
7358 }
7359 
7360 /*!
7361     \since 6.0
7362 
7363     Splits the string into substring views wherever the regular expression \a re
7364     matches, and returns the list of those strings. If \a re does not match
7365     anywhere in the string, split() returns a single-element list containing
7366     this string as view.
7367 
7368     \note The views in the returned list are sub-views of this view; as such,
7369     they reference the same data as it and only remain valid for as long as that
7370     data remains live.
7371 */
7372 QList<QStringView> QStringView::split(const QRegularExpression &re, Qt::SplitBehavior behavior) const
7373 {
7374     return splitString<QList<QStringView>>(*this, re, behavior);
7375 }
7376 
7377 #endif // QT_CONFIG(regularexpression)
7378 
7379 /*!
7380     \enum QString::NormalizationForm
7381 
7382     This enum describes the various normalized forms of Unicode text.
7383 
7384     \value NormalizationForm_D  Canonical Decomposition
7385     \value NormalizationForm_C  Canonical Decomposition followed by Canonical Composition
7386     \value NormalizationForm_KD  Compatibility Decomposition
7387     \value NormalizationForm_KC  Compatibility Decomposition followed by Canonical Composition
7388 
7389     \sa normalized(),
7390         {http://www.unicode.org/reports/tr15/}{Unicode Standard Annex #15}
7391 */
7392 
7393 /*!
7394     \since 4.5
7395 
7396     Returns a copy of this string repeated the specified number of \a times.
7397 
7398     If \a times is less than 1, an empty string is returned.
7399 
7400     Example:
7401 
7402     \snippet code/src_corelib_text_qstring.cpp 8
7403 */
7404 QString QString::repeated(qsizetype times) const
7405 {
7406     if (d.size == 0)
7407         return *this;
7408 
7409     if (times <= 1) {
7410         if (times == 1)
7411             return *this;
7412         return QString();
7413     }
7414 
7415     const qsizetype resultSize = times * d.size;
7416 
7417     QString result;
7418     result.reserve(resultSize);
7419     if (result.capacity() != resultSize)
7420         return QString(); // not enough memory
7421 
7422     memcpy(result.d.data(), d.data(), d.size * sizeof(QChar));
7423 
7424     qsizetype sizeSoFar = d.size;
7425     char16_t *end = result.d.data() + sizeSoFar;
7426 
7427     const qsizetype halfResultSize = resultSize >> 1;
7428     while (sizeSoFar <= halfResultSize) {
7429         memcpy(end, result.d.data(), sizeSoFar * sizeof(QChar));
7430         end += sizeSoFar;
7431         sizeSoFar <<= 1;
7432     }
7433     memcpy(end, result.d.data(), (resultSize - sizeSoFar) * sizeof(QChar));
7434     result.d.data()[resultSize] = '\0';
7435     result.d.size = resultSize;
7436     return result;
7437 }
7438 
7439 void qt_string_normalize(QString *data, QString::NormalizationForm mode, QChar::UnicodeVersion version, qsizetype from)
7440 {
7441     const QChar *p = data->constData() + from;
7442     if (isAscii(p, p + data->length() - from))
7443         return;
7444     if (p > data->constData() + from)
7445         from = p - data->constData() - 1;   // need one before the non-ASCII to perform NFC
7446 
7447     if (version == QChar::Unicode_Unassigned) {
7448         version = QChar::currentUnicodeVersion();
7449     } else if (int(version) <= NormalizationCorrectionsVersionMax) {
7450         const QString &s = *data;
7451         QChar *d = nullptr;
7452         for (int i = 0; i < NumNormalizationCorrections; ++i) {
7453             const NormalizationCorrection &n = uc_normalization_corrections[i];
7454             if (n.version > version) {
7455                 qsizetype pos = from;
7456                 if (QChar::requiresSurrogates(n.ucs4)) {
7457                     char16_t ucs4High = QChar::highSurrogate(n.ucs4);
7458                     char16_t ucs4Low = QChar::lowSurrogate(n.ucs4);
7459                     char16_t oldHigh = QChar::highSurrogate(n.old_mapping);
7460                     char16_t oldLow = QChar::lowSurrogate(n.old_mapping);
7461                     while (pos < s.length() - 1) {
7462                         if (s.at(pos).unicode() == ucs4High && s.at(pos + 1).unicode() == ucs4Low) {
7463                             if (!d)
7464                                 d = data->data();
7465                             d[pos] = QChar(oldHigh);
7466                             d[++pos] = QChar(oldLow);
7467                         }
7468                         ++pos;
7469                     }
7470                 } else {
7471                     while (pos < s.length()) {
7472                         if (s.at(pos).unicode() == n.ucs4) {
7473                             if (!d)
7474                                 d = data->data();
7475                             d[pos] = QChar(n.old_mapping);
7476                         }
7477                         ++pos;
7478                     }
7479                 }
7480             }
7481         }
7482     }
7483 
7484     if (normalizationQuickCheckHelper(data, mode, from, &from))
7485         return;
7486 
7487     decomposeHelper(data, mode < QString::NormalizationForm_KD, version, from);
7488 
7489     canonicalOrderHelper(data, version, from);
7490 
7491     if (mode == QString::NormalizationForm_D || mode == QString::NormalizationForm_KD)
7492         return;
7493 
7494     composeHelper(data, version, from);
7495 }
7496 
7497 /*!
7498     Returns the string in the given Unicode normalization \a mode,
7499     according to the given \a version of the Unicode standard.
7500 */
7501 QString QString::normalized(QString::NormalizationForm mode, QChar::UnicodeVersion version) const
7502 {
7503     QString copy = *this;
7504     qt_string_normalize(&copy, mode, version, 0);
7505     return copy;
7506 }
7507 
7508 
7509 struct ArgEscapeData
7510 {
7511     int min_escape;            // lowest escape sequence number
7512     int occurrences;           // number of occurrences of the lowest escape sequence number
7513     int locale_occurrences;    // number of occurrences of the lowest escape sequence number that
7514                                // contain 'L'
7515     int escape_len;            // total length of escape sequences which will be replaced
7516 };
7517 
7518 static ArgEscapeData findArgEscapes(QStringView s)
7519 {
7520     const QChar *uc_begin = s.begin();
7521     const QChar *uc_end = s.end();
7522 
7523     ArgEscapeData d;
7524 
7525     d.min_escape = INT_MAX;
7526     d.occurrences = 0;
7527     d.escape_len = 0;
7528     d.locale_occurrences = 0;
7529 
7530     const QChar *c = uc_begin;
7531     while (c != uc_end) {
7532         while (c != uc_end && c->unicode() != '%')
7533             ++c;
7534 
7535         if (c == uc_end)
7536             break;
7537         const QChar *escape_start = c;
7538         if (++c == uc_end)
7539             break;
7540 
7541         bool locale_arg = false;
7542         if (c->unicode() == 'L') {
7543             locale_arg = true;
7544             if (++c == uc_end)
7545                 break;
7546         }
7547 
7548         int escape = c->digitValue();
7549         if (escape == -1)
7550             continue;
7551 
7552         ++c;
7553 
7554         if (c != uc_end) {
7555             int next_escape = c->digitValue();
7556             if (next_escape != -1) {
7557                 escape = (10 * escape) + next_escape;
7558                 ++c;
7559             }
7560         }
7561 
7562         if (escape > d.min_escape)
7563             continue;
7564 
7565         if (escape < d.min_escape) {
7566             d.min_escape = escape;
7567             d.occurrences = 0;
7568             d.escape_len = 0;
7569             d.locale_occurrences = 0;
7570         }
7571 
7572         ++d.occurrences;
7573         if (locale_arg)
7574             ++d.locale_occurrences;
7575         d.escape_len += c - escape_start;
7576     }
7577     return d;
7578 }
7579 
7580 static QString replaceArgEscapes(QStringView s, const ArgEscapeData &d, int field_width,
7581                                  QStringView arg, QStringView larg, QChar fillChar)
7582 {
7583     const QChar *uc_begin = s.begin();
7584     const QChar *uc_end = s.end();
7585 
7586     int abs_field_width = qAbs(field_width);
7587     qsizetype result_len = s.length()
7588                      - d.escape_len
7589                      + (d.occurrences - d.locale_occurrences)
7590                      *qMax(abs_field_width, arg.length())
7591                      + d.locale_occurrences
7592                      *qMax(abs_field_width, larg.length());
7593 
7594     QString result(result_len, Qt::Uninitialized);
7595     QChar *result_buff = (QChar*) result.unicode();
7596 
7597     QChar *rc = result_buff;
7598     const QChar *c = uc_begin;
7599     int repl_cnt = 0;
7600     while (c != uc_end) {
7601         /* We don't have to check if we run off the end of the string with c,
7602            because as long as d.occurrences > 0 we KNOW there are valid escape
7603            sequences. */
7604 
7605         const QChar *text_start = c;
7606 
7607         while (c->unicode() != '%')
7608             ++c;
7609 
7610         const QChar *escape_start = c++;
7611 
7612         bool locale_arg = false;
7613         if (c->unicode() == 'L') {
7614             locale_arg = true;
7615             ++c;
7616         }
7617 
7618         int escape = c->digitValue();
7619         if (escape != -1) {
7620             if (c + 1 != uc_end && (c + 1)->digitValue() != -1) {
7621                 escape = (10 * escape) + (c + 1)->digitValue();
7622                 ++c;
7623             }
7624         }
7625 
7626         if (escape != d.min_escape) {
7627             memcpy(rc, text_start, (c - text_start)*sizeof(QChar));
7628             rc += c - text_start;
7629         }
7630         else {
7631             ++c;
7632 
7633             memcpy(rc, text_start, (escape_start - text_start)*sizeof(QChar));
7634             rc += escape_start - text_start;
7635 
7636             uint pad_chars;
7637             if (locale_arg)
7638                 pad_chars = qMax(abs_field_width, larg.length()) - larg.length();
7639             else
7640                 pad_chars = qMax(abs_field_width, arg.length()) - arg.length();
7641 
7642             if (field_width > 0) { // left padded
7643                 for (uint i = 0; i < pad_chars; ++i)
7644                     *rc++ = fillChar;
7645             }
7646 
7647             if (locale_arg) {
7648                 memcpy(rc, larg.data(), larg.length()*sizeof(QChar));
7649                 rc += larg.length();
7650             }
7651             else {
7652                 memcpy(rc, arg.data(), arg.length()*sizeof(QChar));
7653                 rc += arg.length();
7654             }
7655 
7656             if (field_width < 0) { // right padded
7657                 for (uint i = 0; i < pad_chars; ++i)
7658                     *rc++ = fillChar;
7659             }
7660 
7661             if (++repl_cnt == d.occurrences) {
7662                 memcpy(rc, c, (uc_end - c)*sizeof(QChar));
7663                 rc += uc_end - c;
7664                 Q_ASSERT(rc - result_buff == result_len);
7665                 c = uc_end;
7666             }
7667         }
7668     }
7669     Q_ASSERT(rc == result_buff + result_len);
7670 
7671     return result;
7672 }
7673 
7674 #if QT_STRINGVIEW_LEVEL < 2
7675 /*!
7676   Returns a copy of this string with the lowest numbered place marker
7677   replaced by string \a a, i.e., \c %1, \c %2, ..., \c %99.
7678 
7679   \a fieldWidth specifies the minimum amount of space that argument \a
7680   a shall occupy. If \a a requires less space than \a fieldWidth, it
7681   is padded to \a fieldWidth with character \a fillChar.  A positive
7682   \a fieldWidth produces right-aligned text. A negative \a fieldWidth
7683   produces left-aligned text.
7684 
7685   This example shows how we might create a \c status string for
7686   reporting progress while processing a list of files:
7687 
7688   \snippet qstring/main.cpp 11
7689 
7690   First, \c arg(i) replaces \c %1. Then \c arg(total) replaces \c
7691   %2. Finally, \c arg(fileName) replaces \c %3.
7692 
7693   One advantage of using arg() over asprintf() is that the order of the
7694   numbered place markers can change, if the application's strings are
7695   translated into other languages, but each arg() will still replace
7696   the lowest numbered unreplaced place marker, no matter where it
7697   appears. Also, if place marker \c %i appears more than once in the
7698   string, the arg() replaces all of them.
7699 
7700   If there is no unreplaced place marker remaining, a warning message
7701   is output and the result is undefined. Place marker numbers must be
7702   in the range 1 to 99.
7703 */
7704 QString QString::arg(const QString &a, int fieldWidth, QChar fillChar) const
7705 {
7706     return arg(qToStringViewIgnoringNull(a), fieldWidth, fillChar);
7707 }
7708 #endif // QT_STRINGVIEW_LEVEL < 2
7709 
7710 /*!
7711     \overload
7712     \since 5.10
7713 
7714     Returns a copy of this string with the lowest-numbered place-marker
7715     replaced by string \a a, i.e., \c %1, \c %2, ..., \c %99.
7716 
7717     \a fieldWidth specifies the minimum amount of space that \a a
7718     shall occupy. If \a a requires less space than \a fieldWidth, it
7719     is padded to \a fieldWidth with character \a fillChar.  A positive
7720     \a fieldWidth produces right-aligned text. A negative \a fieldWidth
7721     produces left-aligned text.
7722 
7723     This example shows how we might create a \c status string for
7724     reporting progress while processing a list of files:
7725 
7726     \snippet qstring/main.cpp 11-qstringview
7727 
7728     First, \c arg(i) replaces \c %1. Then \c arg(total) replaces \c
7729     %2. Finally, \c arg(fileName) replaces \c %3.
7730 
7731     One advantage of using arg() over asprintf() is that the order of the
7732     numbered place markers can change, if the application's strings are
7733     translated into other languages, but each arg() will still replace
7734     the lowest-numbered unreplaced place-marker, no matter where it
7735     appears. Also, if place-marker \c %i appears more than once in the
7736     string, arg() replaces all of them.
7737 
7738     If there is no unreplaced place-marker remaining, a warning message
7739     is printed and the result is undefined. Place-marker numbers must be
7740     in the range 1 to 99.
7741 */
7742 QString QString::arg(QStringView a, int fieldWidth, QChar fillChar) const
7743 {
7744     ArgEscapeData d = findArgEscapes(*this);
7745 
7746     if (Q_UNLIKELY(d.occurrences == 0)) {
7747         qWarning("QString::arg: Argument missing: %ls, %ls", qUtf16Printable(*this),
7748                   qUtf16Printable(a.toString()));
7749         return *this;
7750     }
7751     return replaceArgEscapes(*this, d, fieldWidth, a, a, fillChar);
7752 }
7753 
7754 /*!
7755     \overload
7756     \since 5.10
7757 
7758     Returns a copy of this string with the lowest-numbered place-marker
7759     replaced by string \a a, i.e., \c %1, \c %2, ..., \c %99.
7760 
7761     \a fieldWidth specifies the minimum amount of space that \a a
7762     shall occupy. If \a a requires less space than \a fieldWidth, it
7763     is padded to \a fieldWidth with character \a fillChar.  A positive
7764     \a fieldWidth produces right-aligned text. A negative \a fieldWidth
7765     produces left-aligned text.
7766 
7767     One advantage of using arg() over asprintf() is that the order of the
7768     numbered place markers can change, if the application's strings are
7769     translated into other languages, but each arg() will still replace
7770     the lowest-numbered unreplaced place-marker, no matter where it
7771     appears. Also, if place-marker \c %i appears more than once in the
7772     string, arg() replaces all of them.
7773 
7774     If there is no unreplaced place-marker remaining, a warning message
7775     is printed and the result is undefined. Place-marker numbers must be
7776     in the range 1 to 99.
7777 */
7778 QString QString::arg(QLatin1String a, int fieldWidth, QChar fillChar) const
7779 {
7780     QVarLengthArray<char16_t> utf16(a.size());
7781     qt_from_latin1(utf16.data(), a.data(), a.size());
7782     return arg(QStringView(utf16.data(), utf16.size()), fieldWidth, fillChar);
7783 }
7784 
7785 /*!
7786   \fn QString QString::arg(const QString& a1, const QString& a2) const
7787   \overload arg()
7788 
7789   This is the same as \c {str.arg(a1).arg(a2)}, except that the
7790   strings \a a1 and \a a2 are replaced in one pass. This can make a
7791   difference if \a a1 contains e.g. \c{%1}:
7792 
7793   \snippet qstring/main.cpp 13
7794 
7795   A similar problem occurs when the numbered place markers are not
7796   white space separated:
7797 
7798   \snippet qstring/main.cpp 12
7799   \snippet qstring/main.cpp 97
7800 
7801   Let's look at the substitutions:
7802   \list
7803   \li First, \c Hello replaces \c {%1} so the string becomes \c {"Hello%3%2"}.
7804   \li Then, \c 20 replaces \c {%2} so the string becomes \c {"Hello%320"}.
7805   \li Since the maximum numbered place marker value is 99, \c 50 replaces \c {%32}.
7806   \endlist
7807   Thus the string finally becomes \c {"Hello500"}.
7808 
7809   In such cases, the following yields the expected results:
7810 
7811   \snippet qstring/main.cpp 12
7812   \snippet qstring/main.cpp 98
7813 */
7814 
7815 /*!
7816   \fn QString QString::arg(const QString& a1, const QString& a2, const QString& a3) const
7817   \overload arg()
7818 
7819   This is the same as calling \c str.arg(a1).arg(a2).arg(a3), except
7820   that the strings \a a1, \a a2 and \a a3 are replaced in one pass.
7821 */
7822 
7823 /*!
7824   \fn QString QString::arg(const QString& a1, const QString& a2, const QString& a3, const QString& a4) const
7825   \overload arg()
7826 
7827   This is the same as calling \c
7828   {str.arg(a1).arg(a2).arg(a3).arg(a4)}, except that the strings \a
7829   a1, \a a2, \a a3 and \a a4 are replaced in one pass.
7830 */
7831 
7832 /*!
7833   \fn QString QString::arg(const QString& a1, const QString& a2, const QString& a3, const QString& a4, const QString& a5) const
7834   \overload arg()
7835 
7836   This is the same as calling \c
7837   {str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5)}, except that the strings
7838   \a a1, \a a2, \a a3, \a a4, and \a a5 are replaced in one pass.
7839 */
7840 
7841 /*!
7842   \fn QString QString::arg(const QString& a1, const QString& a2, const QString& a3, const QString& a4, const QString& a5, const QString& a6) const
7843   \overload arg()
7844 
7845   This is the same as calling \c
7846   {str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6))}, except that
7847   the strings \a a1, \a a2, \a a3, \a a4, \a a5, and \a a6 are
7848   replaced in one pass.
7849 */
7850 
7851 /*!
7852   \fn QString QString::arg(const QString& a1, const QString& a2, const QString& a3, const QString& a4, const QString& a5, const QString& a6, const QString& a7) const
7853   \overload arg()
7854 
7855   This is the same as calling \c
7856   {str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7)},
7857   except that the strings \a a1, \a a2, \a a3, \a a4, \a a5, \a a6,
7858   and \a a7 are replaced in one pass.
7859 */
7860 
7861 /*!
7862   \fn QString QString::arg(const QString& a1, const QString& a2, const QString& a3, const QString& a4, const QString& a5, const QString& a6, const QString& a7, const QString& a8) const
7863   \overload arg()
7864 
7865   This is the same as calling \c
7866   {str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8)},
7867   except that the strings \a a1, \a a2, \a a3, \a a4, \a a5, \a a6, \a
7868   a7, and \a a8 are replaced in one pass.
7869 */
7870 
7871 /*!
7872   \fn QString QString::arg(const QString& a1, const QString& a2, const QString& a3, const QString& a4, const QString& a5, const QString& a6, const QString& a7, const QString& a8, const QString& a9) const
7873   \overload arg()
7874 
7875   This is the same as calling \c
7876   {str.arg(a1).arg(a2).arg(a3).arg(a4).arg(a5).arg(a6).arg(a7).arg(a8).arg(a9)},
7877   except that the strings \a a1, \a a2, \a a3, \a a4, \a a5, \a a6, \a
7878   a7, \a a8, and \a a9 are replaced in one pass.
7879 */
7880 
7881 /*! \fn QString QString::arg(int a, int fieldWidth, int base, QChar fillChar) const
7882   \overload arg()
7883 
7884   The \a a argument is expressed in base \a base, which is 10 by
7885   default and must be between 2 and 36. For bases other than 10, \a a
7886   is treated as an unsigned integer.
7887 
7888   \a fieldWidth specifies the minimum amount of space that \a a is
7889   padded to and filled with the character \a fillChar. A positive
7890   value produces right-aligned text; a negative value produces
7891   left-aligned text.
7892 
7893   The '%' can be followed by an 'L', in which case the sequence is
7894   replaced with a localized representation of \a a. The conversion
7895   uses the default locale, set by QLocale::setDefault(). If no default
7896   locale was specified, the "C" locale is used. The 'L' flag is
7897   ignored if \a base is not 10.
7898 
7899   \snippet qstring/main.cpp 12
7900   \snippet qstring/main.cpp 14
7901 
7902   If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is
7903   used. For negative numbers, zero padding might appear before the
7904   minus sign.
7905 */
7906 
7907 /*! \fn QString QString::arg(uint a, int fieldWidth, int base, QChar fillChar) const
7908   \overload arg()
7909 
7910   The \a base argument specifies the base to use when converting the
7911   integer \a a into a string. The base must be between 2 and 36.
7912 
7913   If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is
7914   used. For negative numbers, zero padding might appear before the
7915   minus sign.
7916 */
7917 
7918 /*! \fn QString QString::arg(long a, int fieldWidth, int base, QChar fillChar) const
7919   \overload arg()
7920 
7921   \a fieldWidth specifies the minimum amount of space that \a a is
7922   padded to and filled with the character \a fillChar. A positive
7923   value produces right-aligned text; a negative value produces
7924   left-aligned text.
7925 
7926   The \a a argument is expressed in the given \a base, which is 10 by
7927   default and must be between 2 and 36.
7928 
7929   The '%' can be followed by an 'L', in which case the sequence is
7930   replaced with a localized representation of \a a. The conversion
7931   uses the default locale. The default locale is determined from the
7932   system's locale settings at application startup. It can be changed
7933   using QLocale::setDefault(). The 'L' flag is ignored if \a base is
7934   not 10.
7935 
7936   \snippet qstring/main.cpp 12
7937   \snippet qstring/main.cpp 14
7938 
7939   If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is
7940   used. For negative numbers, zero padding might appear before the
7941   minus sign.
7942 */
7943 
7944 /*! \fn QString QString::arg(ulong a, int fieldWidth, int base, QChar fillChar) const
7945   \overload arg()
7946 
7947   \a fieldWidth specifies the minimum amount of space that \a a is
7948   padded to and filled with the character \a fillChar. A positive
7949   value produces right-aligned text; a negative value produces
7950   left-aligned text.
7951 
7952   The \a base argument specifies the base to use when converting the
7953   integer \a a to a string. The base must be between 2 and 36, with 8
7954   giving octal, 10 decimal, and 16 hexadecimal numbers.
7955 
7956   If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is
7957   used. For negative numbers, zero padding might appear before the
7958   minus sign.
7959 */
7960 
7961 /*!
7962   \overload arg()
7963 
7964   \a fieldWidth specifies the minimum amount of space that \a a is
7965   padded to and filled with the character \a fillChar. A positive
7966   value produces right-aligned text; a negative value produces
7967   left-aligned text.
7968 
7969   The \a base argument specifies the base to use when converting the
7970   integer \a a into a string. The base must be between 2 and 36, with
7971   8 giving octal, 10 decimal, and 16 hexadecimal numbers.
7972 
7973   If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is
7974   used. For negative numbers, zero padding might appear before the
7975   minus sign.
7976 */
7977 QString QString::arg(qlonglong a, int fieldWidth, int base, QChar fillChar) const
7978 {
7979     ArgEscapeData d = findArgEscapes(*this);
7980 
7981     if (d.occurrences == 0) {
7982         qWarning() << "QString::arg: Argument missing:" << *this << ',' << a;
7983         return *this;
7984     }
7985 
7986     unsigned flags = QLocaleData::NoFlags;
7987     if (fillChar == QLatin1Char('0'))
7988         flags = QLocaleData::ZeroPadded;
7989 
7990     QString arg;
7991     if (d.occurrences > d.locale_occurrences)
7992         arg = QLocaleData::c()->longLongToString(a, -1, base, fieldWidth, flags);
7993 
7994     QString locale_arg;
7995     if (d.locale_occurrences > 0) {
7996         QLocale locale;
7997         if (!(locale.numberOptions() & QLocale::OmitGroupSeparator))
7998             flags |= QLocaleData::GroupDigits;
7999         locale_arg = locale.d->m_data->longLongToString(a, -1, base, fieldWidth, flags);
8000     }
8001 
8002     return replaceArgEscapes(*this, d, fieldWidth, arg, locale_arg, fillChar);
8003 }
8004 
8005 /*!
8006   \overload arg()
8007 
8008   \a fieldWidth specifies the minimum amount of space that \a a is
8009   padded to and filled with the character \a fillChar. A positive
8010   value produces right-aligned text; a negative value produces
8011   left-aligned text.
8012 
8013   The \a base argument specifies the base to use when converting the
8014   integer \a a into a string. \a base must be between 2 and 36, with 8
8015   giving octal, 10 decimal, and 16 hexadecimal numbers.
8016 
8017   If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is
8018   used. For negative numbers, zero padding might appear before the
8019   minus sign.
8020 */
8021 QString QString::arg(qulonglong a, int fieldWidth, int base, QChar fillChar) const
8022 {
8023     ArgEscapeData d = findArgEscapes(*this);
8024 
8025     if (d.occurrences == 0) {
8026         qWarning() << "QString::arg: Argument missing:" << *this << ',' << a;
8027         return *this;
8028     }
8029 
8030     unsigned flags = QLocaleData::NoFlags;
8031     if (fillChar == QLatin1Char('0'))
8032         flags = QLocaleData::ZeroPadded;
8033 
8034     QString arg;
8035     if (d.occurrences > d.locale_occurrences)
8036         arg = QLocaleData::c()->unsLongLongToString(a, -1, base, fieldWidth, flags);
8037 
8038     QString locale_arg;
8039     if (d.locale_occurrences > 0) {
8040         QLocale locale;
8041         if (!(locale.numberOptions() & QLocale::OmitGroupSeparator))
8042             flags |= QLocaleData::GroupDigits;
8043         locale_arg = locale.d->m_data->unsLongLongToString(a, -1, base, fieldWidth, flags);
8044     }
8045 
8046     return replaceArgEscapes(*this, d, fieldWidth, arg, locale_arg, fillChar);
8047 }
8048 
8049 /*!
8050   \overload arg()
8051 
8052   \fn QString QString::arg(short a, int fieldWidth, int base, QChar fillChar) const
8053 
8054   \a fieldWidth specifies the minimum amount of space that \a a is
8055   padded to and filled with the character \a fillChar. A positive
8056   value produces right-aligned text; a negative value produces
8057   left-aligned text.
8058 
8059   The \a base argument specifies the base to use when converting the
8060   integer \a a into a string. The base must be between 2 and 36, with
8061   8 giving octal, 10 decimal, and 16 hexadecimal numbers.
8062 
8063   If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is
8064   used. For negative numbers, zero padding might appear before the
8065   minus sign.
8066 */
8067 
8068 /*!
8069   \fn QString QString::arg(ushort a, int fieldWidth, int base, QChar fillChar) const
8070   \overload arg()
8071 
8072   \a fieldWidth specifies the minimum amount of space that \a a is
8073   padded to and filled with the character \a fillChar. A positive
8074   value produces right-aligned text; a negative value produces
8075   left-aligned text.
8076 
8077   The \a base argument specifies the base to use when converting the
8078   integer \a a into a string. The base must be between 2 and 36, with
8079   8 giving octal, 10 decimal, and 16 hexadecimal numbers.
8080 
8081   If \a fillChar is '0' (the number 0, ASCII 48), the locale's zero is
8082   used. For negative numbers, zero padding might appear before the
8083   minus sign.
8084 */
8085 
8086 /*!
8087     \overload arg()
8088 */
8089 QString QString::arg(QChar a, int fieldWidth, QChar fillChar) const
8090 {
8091     return arg(QStringView{&a, 1}, fieldWidth, fillChar);
8092 }
8093 
8094 /*!
8095   \overload arg()
8096 
8097   The \a a argument is interpreted as a Latin-1 character.
8098 */
8099 QString QString::arg(char a, int fieldWidth, QChar fillChar) const
8100 {
8101     return arg(QLatin1Char(a), fieldWidth, fillChar);
8102 }
8103 
8104 /*!
8105   \fn QString QString::arg(double a, int fieldWidth, char format, int precision, QChar fillChar) const
8106   \overload arg()
8107 
8108   Argument \a a is formatted according to the specified \a format and
8109   \a precision. See \l{Argument Formats} for details.
8110 
8111   \a fieldWidth specifies the minimum amount of space that \a a is
8112   padded to and filled with the character \a fillChar.  A positive
8113   value produces right-aligned text; a negative value produces
8114   left-aligned text.
8115 
8116   \snippet code/src_corelib_text_qstring.cpp 2
8117 
8118   The '%' can be followed by an 'L', in which case the sequence is
8119   replaced with a localized representation of \a a. The conversion
8120   uses the default locale, set by QLocale::setDefault(). If no
8121   default locale was specified, the "C" locale is used.
8122 
8123   If \a fillChar is '0' (the number 0, ASCII 48), this function will
8124   use the locale's zero to pad. For negative numbers, the zero padding
8125   will probably appear before the minus sign.
8126 
8127   \sa QLocale::toString()
8128 */
8129 QString QString::arg(double a, int fieldWidth, char fmt, int prec, QChar fillChar) const
8130 {
8131     ArgEscapeData d = findArgEscapes(*this);
8132 
8133     if (d.occurrences == 0) {
8134         qWarning("QString::arg: Argument missing: %s, %g", toLocal8Bit().data(), a);
8135         return *this;
8136     }
8137 
8138     unsigned flags = QLocaleData::NoFlags;
8139     if (fillChar == QLatin1Char('0'))
8140         flags |= QLocaleData::ZeroPadded;
8141 
8142     if (qIsUpper(fmt))
8143         flags |= QLocaleData::CapitalEorX;
8144 
8145     QLocaleData::DoubleForm form = QLocaleData::DFDecimal;
8146     switch (qToLower(fmt)) {
8147     case 'f':
8148         form = QLocaleData::DFDecimal;
8149         break;
8150     case 'e':
8151         form = QLocaleData::DFExponent;
8152         break;
8153     case 'g':
8154         form = QLocaleData::DFSignificantDigits;
8155         break;
8156     default:
8157 #if defined(QT_CHECK_RANGE)
8158         qWarning("QString::arg: Invalid format char '%c'", fmt);
8159 #endif
8160         break;
8161     }
8162 
8163     QString arg;
8164     if (d.occurrences > d.locale_occurrences)
8165         arg = QLocaleData::c()->doubleToString(a, prec, form, fieldWidth, flags | QLocaleData::ZeroPadExponent);
8166 
8167     QString locale_arg;
8168     if (d.locale_occurrences > 0) {
8169         QLocale locale;
8170 
8171         const QLocale::NumberOptions numberOptions = locale.numberOptions();
8172         if (!(numberOptions & QLocale::OmitGroupSeparator))
8173             flags |= QLocaleData::GroupDigits;
8174         if (!(numberOptions & QLocale::OmitLeadingZeroInExponent))
8175             flags |= QLocaleData::ZeroPadExponent;
8176         if (numberOptions & QLocale::IncludeTrailingZeroesAfterDot)
8177             flags |= QLocaleData::AddTrailingZeroes;
8178         locale_arg = locale.d->m_data->doubleToString(a, prec, form, fieldWidth, flags);
8179     }
8180 
8181     return replaceArgEscapes(*this, d, fieldWidth, arg, locale_arg, fillChar);
8182 }
8183 
8184 static inline char16_t to_unicode(const QChar c) { return c.unicode(); }
8185 static inline char16_t to_unicode(const char c) { return QLatin1Char{c}.unicode(); }
8186 
8187 template <typename Char>
8188 static int getEscape(const Char *uc, qsizetype *pos, qsizetype len, int maxNumber = 999)
8189 {
8190     int i = *pos;
8191     ++i;
8192     if (i < len && uc[i] == QLatin1Char('L'))
8193         ++i;
8194     if (i < len) {
8195         int escape = to_unicode(uc[i]) - '0';
8196         if (uint(escape) >= 10U)
8197             return -1;
8198         ++i;
8199         while (i < len) {
8200             int digit = to_unicode(uc[i]) - '0';
8201             if (uint(digit) >= 10U)
8202                 break;
8203             escape = (escape * 10) + digit;
8204             ++i;
8205         }
8206         if (escape <= maxNumber) {
8207             *pos = i;
8208             return escape;
8209         }
8210     }
8211     return -1;
8212 }
8213 
8214 /*
8215     Algorithm for multiArg:
8216 
8217     1. Parse the string as a sequence of verbatim text and placeholders (%L?\d{,3}).
8218        The L is parsed and accepted for compatibility with non-multi-arg, but since
8219        multiArg only accepts strings as replacements, the localization request can
8220        be safely ignored.
8221     2. The result of step (1) is a list of (string-ref,int)-tuples. The string-ref
8222        either points at text to be copied verbatim (in which case the int is -1),
8223        or, initially, at the textual representation of the placeholder. In that case,
8224        the int contains the numerical number as parsed from the placeholder.
8225     3. Next, collect all the non-negative ints found, sort them in ascending order and
8226        remove duplicates.
8227        3a. If the result has more entires than multiArg() was given replacement strings,
8228            we have found placeholders we can't satisfy with replacement strings. That is
8229            fine (there could be another .arg() call coming after this one), so just
8230            truncate the result to the number of actual multiArg() replacement strings.
8231        3b. If the result has less entries than multiArg() was given replacement strings,
8232            the string is missing placeholders. This is an error that the user should be
8233            warned about.
8234     4. The result of step (3) is a mapping from the index of any replacement string to
8235        placeholder number. This is the wrong way around, but since placeholder
8236        numbers could get as large as 999, while we typically don't have more than 9
8237        replacement strings, we trade 4K of sparsely-used memory for doing a reverse lookup
8238        each time we need to map a placeholder number to a replacement string index
8239        (that's a linear search; but still *much* faster than using an associative container).
8240     5. Next, for each of the tuples found in step (1), do the following:
8241        5a. If the int is negative, do nothing.
8242        5b. Otherwise, if the int is found in the result of step (3) at index I, replace
8243            the string-ref with a string-ref for the (complete) I'th replacement string.
8244        5c. Otherwise, do nothing.
8245     6. Concatenate all string refs into a single result string.
8246 */
8247 
8248 namespace {
8249 struct Part
8250 {
8251     Part() = default; // for QVarLengthArray; do not use
8252     constexpr Part(QStringView s, int num = -1)
8253         : tag{QtPrivate::ArgBase::U16}, number{num}, data{s.utf16()}, size{s.size()} {}
8254     constexpr Part(QLatin1String s, int num = -1)
8255         : tag{QtPrivate::ArgBase::L1}, number{num}, data{s.data()}, size{s.size()} {}
8256 
8257     void reset(QStringView s) noexcept { *this = {s, number}; }
8258     void reset(QLatin1String s) noexcept { *this = {s, number}; }
8259 
8260     QtPrivate::ArgBase::Tag tag;
8261     int number;
8262     const void *data;
8263     qsizetype size;
8264 };
8265 } // unnamed namespace
8266 
8267 Q_DECLARE_TYPEINFO(Part, Q_PRIMITIVE_TYPE);
8268 
8269 namespace {
8270 
8271 enum { ExpectedParts = 32 };
8272 
8273 typedef QVarLengthArray<Part, ExpectedParts> ParseResult;
8274 typedef QVarLengthArray<int, ExpectedParts/2> ArgIndexToPlaceholderMap;
8275 
8276 template <typename StringView>
8277 static ParseResult parseMultiArgFormatString(StringView s)
8278 {
8279     ParseResult result;
8280 
8281     const auto uc = s.data();
8282     const auto len = s.size();
8283     const auto end = len - 1;
8284     qsizetype i = 0;
8285     qsizetype last = 0;
8286 
8287     while (i < end) {
8288         if (uc[i] == QLatin1Char('%')) {
8289             qsizetype percent = i;
8290             int number = getEscape(uc, &i, len);
8291             if (number != -1) {
8292                 if (last != percent)
8293                     result.push_back(Part{s.mid(last, percent - last)}); // literal text (incl. failed placeholders)
8294                 result.push_back(Part{s.mid(percent, i - percent), number});  // parsed placeholder
8295                 last = i;
8296                 continue;
8297             }
8298         }
8299         ++i;
8300     }
8301 
8302     if (last < len)
8303         result.push_back(Part{s.mid(last, len - last)}); // trailing literal text
8304 
8305     return result;
8306 }
8307 
8308 static ArgIndexToPlaceholderMap makeArgIndexToPlaceholderMap(const ParseResult &parts)
8309 {
8310     ArgIndexToPlaceholderMap result;
8311 
8312     for (Part part : parts) {
8313         if (part.number >= 0)
8314             result.push_back(part.number);
8315     }
8316 
8317     std::sort(result.begin(), result.end());
8318     result.erase(std::unique(result.begin(), result.end()),
8319                  result.end());
8320 
8321     return result;
8322 }
8323 
8324 static qsizetype resolveStringRefsAndReturnTotalSize(ParseResult &parts, const ArgIndexToPlaceholderMap &argIndexToPlaceholderMap, const QtPrivate::ArgBase *args[])
8325 {
8326     using namespace QtPrivate;
8327     qsizetype totalSize = 0;
8328     for (Part &part : parts) {
8329         if (part.number != -1) {
8330             const auto it = std::find(argIndexToPlaceholderMap.begin(), argIndexToPlaceholderMap.end(), part.number);
8331             if (it != argIndexToPlaceholderMap.end()) {
8332                 const auto &arg = *args[it - argIndexToPlaceholderMap.begin()];
8333                 switch (arg.tag) {
8334                 case ArgBase::L1:
8335                     part.reset(static_cast<const QLatin1StringArg&>(arg).string);
8336                     break;
8337                 case ArgBase::U8:
8338                     Q_UNREACHABLE(); // waiting for QUtf8String...
8339                     break;
8340                 case ArgBase::U16:
8341                     part.reset(static_cast<const QStringViewArg&>(arg).string);
8342                     break;
8343                 }
8344             }
8345         }
8346         totalSize += part.size;
8347     }
8348     return totalSize;
8349 }
8350 
8351 } // unnamed namespace
8352 
8353 Q_ALWAYS_INLINE QString to_string(QLatin1String s) noexcept { return s; }
8354 Q_ALWAYS_INLINE QString to_string(QStringView s) noexcept { return s.toString(); }
8355 
8356 template <typename StringView>
8357 static QString argToQStringImpl(StringView pattern, size_t numArgs, const QtPrivate::ArgBase **args)
8358 {
8359     // Step 1-2 above
8360     ParseResult parts = parseMultiArgFormatString(pattern);
8361 
8362     // 3-4
8363     ArgIndexToPlaceholderMap argIndexToPlaceholderMap = makeArgIndexToPlaceholderMap(parts);
8364 
8365     if (static_cast<size_t>(argIndexToPlaceholderMap.size()) > numArgs) // 3a
8366         argIndexToPlaceholderMap.resize(qsizetype(numArgs));
8367     else if (Q_UNLIKELY(static_cast<size_t>(argIndexToPlaceholderMap.size()) < numArgs)) // 3b
8368         qWarning("QString::arg: %d argument(s) missing in %ls",
8369                  int(numArgs - argIndexToPlaceholderMap.size()), qUtf16Printable(to_string(pattern)));
8370 
8371     // 5
8372     const qsizetype totalSize = resolveStringRefsAndReturnTotalSize(parts, argIndexToPlaceholderMap, args);
8373 
8374     // 6:
8375     QString result(totalSize, Qt::Uninitialized);
8376     auto out = const_cast<QChar*>(result.constData());
8377 
8378     for (Part part : parts) {
8379         switch (part.tag) {
8380         case QtPrivate::ArgBase::L1:
8381             if (part.size) {
8382                 qt_from_latin1(reinterpret_cast<char16_t*>(out),
8383                                reinterpret_cast<const char*>(part.data), part.size);
8384             }
8385             break;
8386         case QtPrivate::ArgBase::U8:
8387             Q_UNREACHABLE(); // waiting for QUtf8String
8388             break;
8389         case QtPrivate::ArgBase::U16:
8390             if (part.size)
8391                 memcpy(out, part.data, part.size * sizeof(QChar));
8392             break;
8393         }
8394         out += part.size;
8395     }
8396 
8397     return result;
8398 }
8399 
8400 QString QtPrivate::argToQString(QStringView pattern, size_t n, const ArgBase **args)
8401 {
8402     return argToQStringImpl(pattern, n, args);
8403 }
8404 
8405 QString QtPrivate::argToQString(QLatin1String pattern, size_t n, const ArgBase **args)
8406 {
8407     return argToQStringImpl(pattern, n, args);
8408 }
8409 
8410 /*! \fn bool QString::isSimpleText() const
8411 
8412     \internal
8413 */
8414 bool QString::isSimpleText() const
8415 {
8416     const char16_t *p = d.data();
8417     const char16_t * const end = p + d.size;
8418     while (p < end) {
8419         char16_t uc = *p;
8420         // sort out regions of complex text formatting
8421         if (uc > 0x058f && (uc < 0x1100 || uc > 0xfb0f)) {
8422             return false;
8423         }
8424         p++;
8425     }
8426 
8427     return true;
8428 }
8429 
8430 /*! \fn bool QString::isRightToLeft() const
8431 
8432     Returns \c true if the string is read right to left.
8433 
8434     \sa QStringView::isRightToLeft()
8435 */
8436 bool QString::isRightToLeft() const
8437 {
8438     return QtPrivate::isRightToLeft(QStringView(*this));
8439 }
8440 
8441 /*!
8442     \fn bool QString::isValidUtf16() const noexcept
8443     \since 5.15
8444 
8445     Returns \c true if the string contains valid UTF-16 encoded data,
8446     or \c false otherwise.
8447 
8448     Note that this function does not perform any special validation of the
8449     data; it merely checks if it can be successfully decoded from UTF-16.
8450     The data is assumed to be in host byte order; the presence of a BOM
8451     is meaningless.
8452 
8453     \sa QStringView::isValidUtf16()
8454 */
8455 
8456 /*! \fn QChar *QString::data()
8457 
8458     Returns a pointer to the data stored in the QString. The pointer
8459     can be used to access and modify the characters that compose the
8460     string.
8461 
8462     Unlike constData() and unicode(), the returned data is always
8463     '\\0'-terminated.
8464 
8465     Example:
8466 
8467     \snippet qstring/main.cpp 19
8468 
8469     Note that the pointer remains valid only as long as the string is
8470     not modified by other means. For read-only access, constData() is
8471     faster because it never causes a \l{deep copy} to occur.
8472 
8473     \sa constData(), operator[]()
8474 */
8475 
8476 /*! \fn const QChar *QString::data() const
8477 
8478     \overload
8479 
8480     \note The returned string may not be '\\0'-terminated.
8481     Use size() to determine the length of the array.
8482 
8483     \sa fromRawData()
8484 */
8485 
8486 /*! \fn const QChar *QString::constData() const
8487 
8488     Returns a pointer to the data stored in the QString. The pointer
8489     can be used to access the characters that compose the string.
8490 
8491     Note that the pointer remains valid only as long as the string is
8492     not modified.
8493 
8494     \note The returned string may not be '\\0'-terminated.
8495     Use size() to determine the length of the array.
8496 
8497     \sa data(), operator[](), fromRawData()
8498 */
8499 
8500 /*! \fn void QString::push_front(const QString &other)
8501 
8502     This function is provided for STL compatibility, prepending the
8503     given \a other string to the beginning of this string. It is
8504     equivalent to \c prepend(other).
8505 
8506     \sa prepend()
8507 */
8508 
8509 /*! \fn void QString::push_front(QChar ch)
8510 
8511     \overload
8512 
8513     Prepends the given \a ch character to the beginning of this string.
8514 */
8515 
8516 /*! \fn void QString::push_back(const QString &other)
8517 
8518     This function is provided for STL compatibility, appending the
8519     given \a other string onto the end of this string. It is
8520     equivalent to \c append(other).
8521 
8522     \sa append()
8523 */
8524 
8525 /*! \fn void QString::push_back(QChar ch)
8526 
8527     \overload
8528 
8529     Appends the given \a ch character onto the end of this string.
8530 */
8531 
8532 /*! \fn void QString::shrink_to_fit()
8533     \since 5.10
8534 
8535     This function is provided for STL compatibility. It is
8536     equivalent to squeeze().
8537 
8538     \sa squeeze()
8539 */
8540 
8541 /*!
8542     \fn std::string QString::toStdString() const
8543 
8544     Returns a std::string object with the data contained in this
8545     QString. The Unicode data is converted into 8-bit characters using
8546     the toUtf8() function.
8547 
8548     This method is mostly useful to pass a QString to a function
8549     that accepts a std::string object.
8550 
8551     \sa toLatin1(), toUtf8(), toLocal8Bit(), QByteArray::toStdString()
8552 */
8553 
8554 /*!
8555     Constructs a QString that uses the first \a size Unicode characters
8556     in the array \a unicode. The data in \a unicode is \e not
8557     copied. The caller must be able to guarantee that \a unicode will
8558     not be deleted or modified as long as the QString (or an
8559     unmodified copy of it) exists.
8560 
8561     Any attempts to modify the QString or copies of it will cause it
8562     to create a deep copy of the data, ensuring that the raw data
8563     isn't modified.
8564 
8565     Here is an example of how we can use a QRegularExpression on raw data in
8566     memory without requiring to copy the data into a QString:
8567 
8568     \snippet qstring/main.cpp 22
8569     \snippet qstring/main.cpp 23
8570 
8571     \warning A string created with fromRawData() is \e not
8572     '\\0'-terminated, unless the raw data contains a '\\0' character
8573     at position \a size. This means unicode() will \e not return a
8574     '\\0'-terminated string (although utf16() does, at the cost of
8575     copying the raw data).
8576 
8577     \sa fromUtf16(), setRawData()
8578 */
8579 QString QString::fromRawData(const QChar *unicode, qsizetype size)
8580 {
8581     return QString(DataPointer::fromRawData(const_cast<char16_t *>(reinterpret_cast<const char16_t *>(unicode)), size));
8582 }
8583 
8584 /*!
8585     \since 4.7
8586 
8587     Resets the QString to use the first \a size Unicode characters
8588     in the array \a unicode. The data in \a unicode is \e not
8589     copied. The caller must be able to guarantee that \a unicode will
8590     not be deleted or modified as long as the QString (or an
8591     unmodified copy of it) exists.
8592 
8593     This function can be used instead of fromRawData() to re-use
8594     existings QString objects to save memory re-allocations.
8595 
8596     \sa fromRawData()
8597 */
8598 QString &QString::setRawData(const QChar *unicode, qsizetype size)
8599 {
8600     if (!unicode || !size) {
8601         clear();
8602     }
8603     *this = fromRawData(unicode, size);
8604     return *this;
8605 }
8606 
8607 /*! \fn QString QString::fromStdU16String(const std::u16string &str)
8608     \since 5.5
8609 
8610     Returns a copy of the \a str string. The given string is assumed
8611     to be encoded in UTF-16.
8612 
8613     \sa fromUtf16(), fromStdWString(), fromStdU32String()
8614 */
8615 
8616 /*!
8617     \fn std::u16string QString::toStdU16String() const
8618     \since 5.5
8619 
8620     Returns a std::u16string object with the data contained in this
8621     QString. The Unicode data is the same as returned by the utf16()
8622     method.
8623 
8624     \sa utf16(), toStdWString(), toStdU32String()
8625 */
8626 
8627 /*! \fn QString QString::fromStdU32String(const std::u32string &str)
8628     \since 5.5
8629 
8630     Returns a copy of the \a str string. The given string is assumed
8631     to be encoded in UCS-4.
8632 
8633     \sa fromUcs4(), fromStdWString(), fromStdU16String()
8634 */
8635 
8636 /*!
8637     \fn std::u32string QString::toStdU32String() const
8638     \since 5.5
8639 
8640     Returns a std::u32string object with the data contained in this
8641     QString. The Unicode data is the same as returned by the toUcs4()
8642     method.
8643 
8644     \sa toUcs4(), toStdWString(), toStdU16String()
8645 */
8646 
8647 /*! \class QLatin1String
8648     \inmodule QtCore
8649     \brief The QLatin1String class provides a thin wrapper around an US-ASCII/Latin-1 encoded string literal.
8650 
8651     \ingroup string-processing
8652     \reentrant
8653 
8654     Many of QString's member functions are overloaded to accept
8655     \c{const char *} instead of QString. This includes the copy
8656     constructor, the assignment operator, the comparison operators,
8657     and various other functions such as \l{QString::insert()}{insert()}, \l{QString::replace()}{replace()},
8658     and \l{QString::indexOf()}{indexOf()}. These functions
8659     are usually optimized to avoid constructing a QString object for
8660     the \c{const char *} data. For example, assuming \c str is a
8661     QString,
8662 
8663     \snippet code/src_corelib_text_qstring.cpp 3
8664 
8665     is much faster than
8666 
8667     \snippet code/src_corelib_text_qstring.cpp 4
8668 
8669     because it doesn't construct four temporary QString objects and
8670     make a deep copy of the character data.
8671 
8672     Applications that define \c QT_NO_CAST_FROM_ASCII (as explained
8673     in the QString documentation) don't have access to QString's
8674     \c{const char *} API. To provide an efficient way of specifying
8675     constant Latin-1 strings, Qt provides the QLatin1String, which is
8676     just a very thin wrapper around a \c{const char *}. Using
8677     QLatin1String, the example code above becomes
8678 
8679     \snippet code/src_corelib_text_qstring.cpp 5
8680 
8681     This is a bit longer to type, but it provides exactly the same
8682     benefits as the first version of the code, and is faster than
8683     converting the Latin-1 strings using QString::fromLatin1().
8684 
8685     Thanks to the QString(QLatin1String) constructor,
8686     QLatin1String can be used everywhere a QString is expected. For
8687     example:
8688 
8689     \snippet code/src_corelib_text_qstring.cpp 6
8690 
8691     \note If the function you're calling with a QLatin1String
8692     argument isn't actually overloaded to take QLatin1String, the
8693     implicit conversion to QString will trigger a memory allocation,
8694     which is usually what you want to avoid by using QLatin1String
8695     in the first place. In those cases, using QStringLiteral may be
8696     the better option.
8697 
8698     \sa QString, QLatin1Char, {QStringLiteral()}{QStringLiteral}, QT_NO_CAST_FROM_ASCII
8699 */
8700 
8701 /*!
8702     \typedef QLatin1String::value_type
8703     \since 5.10
8704 
8705     Alias for \c{const char}. Provided for compatibility with the STL.
8706 */
8707 
8708 /*!
8709     \typedef QLatin1String::difference_type
8710     \since 5.10
8711 
8712     Alias for \c{qsizetype}. Provided for compatibility with the STL.
8713 */
8714 
8715 /*!
8716     \typedef QLatin1String::size_type
8717     \since 5.10
8718 
8719     Alias for \c{qsizetype}. Provided for compatibility with the STL.
8720 */
8721 
8722 /*!
8723     \typedef QLatin1String::reference
8724     \since 5.10
8725 
8726     Alias for \c{value_type &}. Provided for compatibility with the STL.
8727 */
8728 
8729 /*!
8730     \typedef QLatin1String::const_reference
8731     \since 5.11
8732 
8733     Alias for \c{reference}. Provided for compatibility with the STL.
8734 */
8735 
8736 /*!
8737     \typedef QLatin1String::iterator
8738     \since 5.10
8739 
8740     QLatin1String does not support mutable iterators, so this is the same
8741     as const_iterator.
8742 
8743     \sa const_iterator, reverse_iterator
8744 */
8745 
8746 /*!
8747     \typedef QLatin1String::const_iterator
8748     \since 5.10
8749 
8750     \sa iterator, const_reverse_iterator
8751 */
8752 
8753 /*!
8754     \typedef QLatin1String::reverse_iterator
8755     \since 5.10
8756 
8757     QLatin1String does not support mutable reverse iterators, so this is the
8758     same as const_reverse_iterator.
8759 
8760     \sa const_reverse_iterator, iterator
8761 */
8762 
8763 /*!
8764     \typedef QLatin1String::const_reverse_iterator
8765     \since 5.10
8766 
8767     \sa reverse_iterator, const_iterator
8768 */
8769 
8770 /*! \fn QLatin1String::QLatin1String()
8771     \since 5.6
8772 
8773     Constructs a QLatin1String object that stores a nullptr.
8774 */
8775 
8776 /*! \fn QLatin1String::QLatin1String(const char *str)
8777 
8778     Constructs a QLatin1String object that stores \a str.
8779 
8780     The string data is \e not copied. The caller must be able to
8781     guarantee that \a str will not be deleted or modified as long as
8782     the QLatin1String object exists.
8783 
8784     \sa latin1()
8785 */
8786 
8787 /*! \fn QLatin1String::QLatin1String(const char *str, int size)
8788 
8789     Constructs a QLatin1String object that stores \a str with \a size.
8790 
8791     The string data is \e not copied. The caller must be able to
8792     guarantee that \a str will not be deleted or modified as long as
8793     the QLatin1String object exists.
8794 
8795     \sa latin1()
8796 */
8797 
8798 /*!
8799     \fn QLatin1String::QLatin1String(const char *first, const char *last)
8800     \since 5.10
8801 
8802     Constructs a QLatin1String object that stores \a first with length
8803     (\a last - \a first).
8804 
8805     The range \c{[first,last)} must remain valid for the lifetime of
8806     this Latin-1 string object.
8807 
8808     Passing \nullptr as \a first is safe if \a last is \nullptr,
8809     too, and results in a null Latin-1 string.
8810 
8811     The behavior is undefined if \a last precedes \a first, \a first
8812     is \nullptr and \a last is not, or if \c{last - first >
8813     INT_MAX}.
8814 */
8815 
8816 /*! \fn QLatin1String::QLatin1String(const QByteArray &str)
8817 
8818     Constructs a QLatin1String object that stores \a str.
8819 
8820     The string data is \e not copied. The caller must be able to
8821     guarantee that \a str will not be deleted or modified as long as
8822     the QLatin1String object exists.
8823 
8824     \sa latin1()
8825 */
8826 
8827 /*!
8828     \fn QLatin1String::toString() const
8829     \since 6.0
8830 
8831     Converts this Latin-1 string into a QString. Equivalent to
8832     \code
8833     return QString(*this);
8834     \endcode
8835 */
8836 
8837 /*! \fn const char *QLatin1String::latin1() const
8838 
8839     Returns the Latin-1 string stored in this object.
8840 */
8841 
8842 /*! \fn const char *QLatin1String::data() const
8843 
8844     Returns the Latin-1 string stored in this object.
8845 */
8846 
8847 /*! \fn int QLatin1String::size() const
8848 
8849     Returns the size of the Latin-1 string stored in this object.
8850 */
8851 
8852 /*! \fn bool QLatin1String::isNull() const
8853     \since 5.10
8854 
8855     Returns whether the Latin-1 string stored in this object is null
8856     (\c{data() == nullptr}) or not.
8857 
8858     \sa isEmpty(), data()
8859 */
8860 
8861 /*! \fn bool QLatin1String::isEmpty() const
8862     \since 5.10
8863 
8864     Returns whether the Latin-1 string stored in this object is empty
8865     (\c{size() == 0}) or not.
8866 
8867     \sa isNull(), size()
8868 */
8869 
8870 /*! \fn QLatin1Char QLatin1String::at(int pos) const
8871     \since 5.8
8872 
8873     Returns the character at position \a pos in this object.
8874 
8875     \note This function performs no error checking.
8876     The behavior is undefined when \a pos < 0 or \a pos >= size().
8877 
8878     \sa operator[]()
8879 */
8880 
8881 /*! \fn QLatin1Char QLatin1String::operator[](int pos) const
8882     \since 5.8
8883 
8884     Returns the character at position \a pos in this object.
8885 
8886     \note This function performs no error checking.
8887     The behavior is undefined when \a pos < 0 or \a pos >= size().
8888 
8889     \sa at()
8890 */
8891 
8892 /*!
8893     \fn QLatin1Char QLatin1String::front() const
8894     \since 5.10
8895 
8896     Returns the first character in the string.
8897     Same as \c{at(0)}.
8898 
8899     This function is provided for STL compatibility.
8900 
8901     \warning Calling this function on an empty string constitutes
8902     undefined behavior.
8903 
8904     \sa back(), at(), operator[]()
8905 */
8906 
8907 /*!
8908     \fn QLatin1Char QLatin1String::back() const
8909     \since 5.10
8910 
8911     Returns the last character in the string.
8912     Same as \c{at(size() - 1)}.
8913 
8914     This function is provided for STL compatibility.
8915 
8916     \warning Calling this function on an empty string constitutes
8917     undefined behavior.
8918 
8919     \sa front(), at(), operator[]()
8920 */
8921 
8922 /*!
8923     \fn int QLatin1String::compare(QStringView str, Qt::CaseSensitivity cs) const
8924     \fn int QLatin1String::compare(QLatin1String l1, Qt::CaseSensitivity cs) const
8925     \fn int QLatin1String::compare(QChar ch) const
8926     \fn int QLatin1String::compare(QChar ch, Qt::CaseSensitivity cs) const
8927     \since 5.14
8928 
8929     Returns an integer that compares to zero as this Latin-1 string compares to the
8930     string-view \a str, Latin-1 string \a l1, or character \a ch, respectively.
8931 
8932     If \a cs is Qt::CaseSensitive (the default), the comparison is case sensitive;
8933     otherwise the comparison is case-insensitive.
8934 
8935     \sa operator==(), operator<(), operator>()
8936 */
8937 
8938 
8939 /*!
8940     \fn bool QLatin1String::startsWith(QStringView str, Qt::CaseSensitivity cs) const
8941     \since 5.10
8942     \fn bool QLatin1String::startsWith(QLatin1String l1, Qt::CaseSensitivity cs) const
8943     \since 5.10
8944     \fn bool QLatin1String::startsWith(QChar ch) const
8945     \since 5.10
8946     \fn bool QLatin1String::startsWith(QChar ch, Qt::CaseSensitivity cs) const
8947     \since 5.10
8948 
8949     Returns \c true if this Latin-1 string starts with string-view \a str,
8950     Latin-1 string \a l1, or character \a ch, respectively;
8951     otherwise returns \c false.
8952 
8953     If \a cs is Qt::CaseSensitive (the default), the search is case-sensitive;
8954     otherwise the search is case-insensitive.
8955 
8956     \sa endsWith()
8957 */
8958 
8959 /*!
8960     \fn bool QLatin1String::endsWith(QStringView str, Qt::CaseSensitivity cs) const
8961     \since 5.10
8962     \fn bool QLatin1String::endsWith(QLatin1String l1, Qt::CaseSensitivity cs) const
8963     \since 5.10
8964     \fn bool QLatin1String::endsWith(QChar ch) const
8965     \since 5.10
8966     \fn bool QLatin1String::endsWith(QChar ch, Qt::CaseSensitivity cs) const
8967     \since 5.10
8968 
8969     Returns \c true if this Latin-1 string ends with string-view \a str,
8970     Latin-1 string \a l1, or character \a ch, respectively;
8971     otherwise returns \c false.
8972 
8973     If \a cs is Qt::CaseSensitive (the default), the search is case-sensitive;
8974     otherwise the search is case-insensitive.
8975 
8976     \sa startsWith()
8977 */
8978 
8979 /*!
8980     \fn int QLatin1String::indexOf(QStringView str, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
8981     \fn int QLatin1String::indexOf(QLatin1String l1, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
8982     \fn int QLatin1String::indexOf(QChar c, int from = 0, Qt::CaseSensitivity cs = Qt::CaseSensitive) const
8983     \since 5.14
8984 
8985     Returns the index position of the first occurrence of the string-view \a str,
8986     Latin-1 string \a l1, or character \a ch, respectively, in this Latin-1 string,
8987     searching forward from index position \a from. Returns -1 if \a str is not found.
8988 
8989     If \a cs is Qt::CaseSensitive (default), the search is case
8990     sensitive; otherwise the search is case insensitive.
8991 
8992     If \a from is -1, the search starts at the last character; if it is
8993     -2, at the next to last character and so on.
8994 
8995     \sa QString::indexOf()
8996 */
8997 
8998 /*!
8999     \fn bool QLatin1String::contains(QStringView str, Qt::CaseSensitivity cs) const
9000     \fn bool QLatin1String::contains(QLatin1String l1, Qt::CaseSensitivity cs) const
9001     \fn bool QLatin1String::contains(QChar c, Qt::CaseSensitivity cs) const
9002     \since 5.14
9003 
9004     Returns \c true if this Latin-1 string contains an occurrence of the string-view
9005     \a str, Latin-1 string \a l1, or character \a ch; otherwise returns \c false.
9006 
9007     If \a cs is Qt::CaseSensitive (the default), the search is
9008     case-sensitive; otherwise the search is case-insensitive.
9009 
9010     \sa indexOf(), QStringView::contains(), QStringView::indexOf(), QString::indexOf()
9011 */
9012 
9013 /*!
9014     \fn int QLatin1String::lastIndexOf(QStringView str, int from, Qt::CaseSensitivity cs) const
9015     \fn int QLatin1String::lastIndexOf(QLatin1String l1, int from, Qt::CaseSensitivity cs) const
9016     \fn int QLatin1String::lastIndexOf(QChar c, int from, Qt::CaseSensitivity cs) const
9017     \since 5.14
9018 
9019     Returns the index position of the last occurrence of the string-view \a str,
9020     Latin-1 string \a l1, or character \a ch, respectively, in this Latin-1 string,
9021     searching backward from index position \a from. If \a from is -1 (default),
9022     the search starts at the last character; if \a from is -2, at the next to last
9023     character and so on. Returns -1 if \a str is not found.
9024 
9025     If \a cs is Qt::CaseSensitive (default), the search is case
9026     sensitive; otherwise the search is case insensitive.
9027 
9028     \sa indexOf(), QStringView::lastIndexOf(), QStringView::indexOf(), QString::indexOf()
9029 */
9030 
9031 /*!
9032     \fn QLatin1String::const_iterator QLatin1String::begin() const
9033     \since 5.10
9034 
9035     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the first character in
9036     the string.
9037 
9038     This function is provided for STL compatibility.
9039 
9040     \sa end(), cbegin(), rbegin(), data()
9041 */
9042 
9043 /*!
9044     \fn QLatin1String::const_iterator QLatin1String::cbegin() const
9045     \since 5.10
9046 
9047     Same as begin().
9048 
9049     This function is provided for STL compatibility.
9050 
9051     \sa cend(), begin(), crbegin(), data()
9052 */
9053 
9054 /*!
9055     \fn QLatin1String::const_iterator QLatin1String::end() const
9056     \since 5.10
9057 
9058     Returns a const \l{STL-style iterators}{STL-style iterator} pointing to the imaginary
9059     character after the last character in the list.
9060 
9061     This function is provided for STL compatibility.
9062 
9063     \sa begin(), cend(), rend()
9064 */
9065 
9066 /*! \fn QLatin1String::const_iterator QLatin1String::cend() const
9067     \since 5.10
9068 
9069     Same as end().
9070 
9071     This function is provided for STL compatibility.
9072 
9073     \sa cbegin(), end(), crend()
9074 */
9075 
9076 /*!
9077     \fn QLatin1String::const_reverse_iterator QLatin1String::rbegin() const
9078     \since 5.10
9079 
9080     Returns a const \l{STL-style iterators}{STL-style} reverse iterator pointing to the first
9081     character in the string, in reverse order.
9082 
9083     This function is provided for STL compatibility.
9084 
9085     \sa rend(), crbegin(), begin()
9086 */
9087 
9088 /*!
9089     \fn QLatin1String::const_reverse_iterator QLatin1String::crbegin() const
9090     \since 5.10
9091 
9092     Same as rbegin().
9093 
9094     This function is provided for STL compatibility.
9095 
9096     \sa crend(), rbegin(), cbegin()
9097 */
9098 
9099 /*!
9100     \fn QLatin1String::const_reverse_iterator QLatin1String::rend() const
9101     \since 5.10
9102 
9103     Returns a \l{STL-style iterators}{STL-style} reverse iterator pointing to one past
9104     the last character in the string, in reverse order.
9105 
9106     This function is provided for STL compatibility.
9107 
9108     \sa rbegin(), crend(), end()
9109 */
9110 
9111 /*!
9112     \fn QLatin1String::const_reverse_iterator QLatin1String::crend() const
9113     \since 5.10
9114 
9115     Same as rend().
9116 
9117     This function is provided for STL compatibility.
9118 
9119     \sa crbegin(), rend(), cend()
9120 */
9121 
9122 /*! \fn QLatin1String QLatin1String::mid(int start, int length) const
9123     \since 5.8
9124 
9125     Returns the substring of length \a length starting at position
9126     \a start in this object.
9127 
9128     Returns a null string if the \a start index exceeds the
9129     length of the string. If there are less than \a length characters
9130     available in the string starting at \a start, or if
9131     \a length is negative (default), the function returns all characters
9132     that are available from \a start.
9133 
9134     \sa left(), right(), chopped(), chop(), truncate()
9135 */
9136 
9137 /*! \fn QLatin1String QLatin1String::left(int length) const
9138     \since 5.8
9139 
9140     Returns the substring of length \a length starting at position
9141     0 in this object.
9142 
9143     The entire string is returned if \a length is greater than or equal
9144     to size(), or less than zero.
9145 
9146     \sa mid(), right(), chopped(), chop(), truncate()
9147 */
9148 
9149 /*! \fn QLatin1String QLatin1String::right(int length) const
9150     \since 5.8
9151 
9152     Returns the substring of length \a length starting at position
9153     size() - \a length in this object.
9154 
9155     The entire string is returned if \a length is greater than or equal
9156     to size(), or less than zero.
9157 
9158     \sa mid(), left(), chopped(), chop(), truncate()
9159 */
9160 
9161 /*!
9162     \fn QLatin1String QLatin1String::chopped(int length) const
9163     \since 5.10
9164 
9165     Returns the substring of length size() - \a length starting at the
9166     beginning of this object.
9167 
9168     Same as \c{left(size() - length)}.
9169 
9170     \note The behavior is undefined when \a length < 0 or \a length > size().
9171 
9172     \sa mid(), left(), right(), chop(), truncate()
9173 */
9174 
9175 /*!
9176     \fn void QLatin1String::truncate(int length)
9177     \since 5.10
9178 
9179     Truncates this string to length \a length.
9180 
9181     Same as \c{*this = left(length)}.
9182 
9183     \note The behavior is undefined when \a length < 0 or \a length > size().
9184 
9185     \sa mid(), left(), right(), chopped(), chop()
9186 */
9187 
9188 /*!
9189     \fn void QLatin1String::chop(int length)
9190     \since 5.10
9191 
9192     Truncates this string by \a length characters.
9193 
9194     Same as \c{*this = left(size() - length)}.
9195 
9196     \note The behavior is undefined when \a length < 0 or \a length > size().
9197 
9198     \sa mid(), left(), right(), chopped(), truncate()
9199 */
9200 
9201 /*!
9202     \fn QLatin1String QLatin1String::trimmed() const
9203     \since 5.10
9204 
9205     Strips leading and trailing whitespace and returns the result.
9206 
9207     Whitespace means any character for which QChar::isSpace() returns
9208     \c true. This includes the ASCII characters '\\t', '\\n', '\\v',
9209     '\\f', '\\r', and ' '.
9210 */
9211 
9212 /*! \fn bool QLatin1String::operator==(const QString &other) const
9213 
9214     Returns \c true if this string is equal to string \a other;
9215     otherwise returns \c false.
9216 
9217     \sa {Comparing Strings}
9218 */
9219 
9220 /*!
9221     \fn bool QLatin1String::operator==(const char *other) const
9222     \since 4.3
9223     \overload
9224 
9225     The \a other const char pointer is converted to a QString using
9226     the QString::fromUtf8() function.
9227 
9228     You can disable this operator by defining \c
9229     QT_NO_CAST_FROM_ASCII when you compile your applications. This
9230     can be useful if you want to ensure that all user-visible strings
9231     go through QObject::tr(), for example.
9232 
9233     \sa QT_NO_CAST_FROM_ASCII
9234 */
9235 
9236 /*!
9237     \fn bool QLatin1String::operator==(const QByteArray &other) const
9238     \since 5.0
9239     \overload
9240 
9241     The \a other byte array is converted to a QString using
9242     the QString::fromUtf8() function.
9243 
9244     You can disable this operator by defining \c
9245     QT_NO_CAST_FROM_ASCII when you compile your applications. This
9246     can be useful if you want to ensure that all user-visible strings
9247     go through QObject::tr(), for example.
9248 
9249     \sa QT_NO_CAST_FROM_ASCII
9250 */
9251 
9252 /*! \fn bool QLatin1String::operator!=(const QString &other) const
9253 
9254     Returns \c true if this string is not equal to string \a other;
9255     otherwise returns \c false.
9256 
9257     \sa {Comparing Strings}
9258 */
9259 
9260 /*!
9261     \fn bool QLatin1String::operator!=(const char *other) const
9262     \since 4.3
9263     \overload operator!=()
9264 
9265     The \a other const char pointer is converted to a QString using
9266     the QString::fromUtf8() function.
9267 
9268     You can disable this operator by defining \c
9269     QT_NO_CAST_FROM_ASCII when you compile your applications. This
9270     can be useful if you want to ensure that all user-visible strings
9271     go through QObject::tr(), for example.
9272 
9273     \sa QT_NO_CAST_FROM_ASCII
9274 */
9275 
9276 /*!
9277     \fn bool QLatin1String::operator!=(const QByteArray &other) const
9278     \since 5.0
9279     \overload operator!=()
9280 
9281     The \a other byte array is converted to a QString using
9282     the QString::fromUtf8() function.
9283 
9284     You can disable this operator by defining \c
9285     QT_NO_CAST_FROM_ASCII when you compile your applications. This
9286     can be useful if you want to ensure that all user-visible strings
9287     go through QObject::tr(), for example.
9288 
9289     \sa QT_NO_CAST_FROM_ASCII
9290 */
9291 
9292 /*!
9293     \fn bool QLatin1String::operator>(const QString &other) const
9294 
9295     Returns \c true if this string is lexically greater than string \a
9296     other; otherwise returns \c false.
9297 
9298     \sa {Comparing Strings}
9299 */
9300 
9301 /*!
9302     \fn bool QLatin1String::operator>(const char *other) const
9303     \since 4.3
9304     \overload
9305 
9306     The \a other const char pointer is converted to a QString using
9307     the QString::fromUtf8() function.
9308 
9309     You can disable this operator by defining \c QT_NO_CAST_FROM_ASCII
9310     when you compile your applications. This can be useful if you want
9311     to ensure that all user-visible strings go through QObject::tr(),
9312     for example.
9313 
9314     \sa QT_NO_CAST_FROM_ASCII
9315 */
9316 
9317 /*!
9318     \fn bool QLatin1String::operator>(const QByteArray &other) const
9319     \since 5.0
9320     \overload
9321 
9322     The \a other const char pointer is converted to a QString using
9323     the QString::fromUtf8() function.
9324 
9325     You can disable this operator by defining \c QT_NO_CAST_FROM_ASCII
9326     when you compile your applications. This can be useful if you want
9327     to ensure that all user-visible strings go through QObject::tr(),
9328     for example.
9329 
9330     \sa QT_NO_CAST_FROM_ASCII
9331 */
9332 
9333 /*!
9334     \fn bool QLatin1String::operator<(const QString &other) const
9335 
9336     Returns \c true if this string is lexically less than the \a other
9337     string; otherwise returns \c false.
9338 
9339     \sa {Comparing Strings}
9340 */
9341 
9342 /*!
9343     \fn bool QLatin1String::operator<(const char *other) const
9344     \since 4.3
9345     \overload
9346 
9347     The \a other const char pointer is converted to a QString using
9348     the QString::fromUtf8() function.
9349 
9350     You can disable this operator by defining \c
9351     QT_NO_CAST_FROM_ASCII when you compile your applications. This
9352     can be useful if you want to ensure that all user-visible strings
9353     go through QObject::tr(), for example.
9354 
9355     \sa QT_NO_CAST_FROM_ASCII
9356 */
9357 
9358 /*!
9359     \fn bool QLatin1String::operator<(const QByteArray &other) const
9360     \since 5.0
9361     \overload
9362 
9363     The \a other const char pointer is converted to a QString using
9364     the QString::fromUtf8() function.
9365 
9366     You can disable this operator by defining \c
9367     QT_NO_CAST_FROM_ASCII when you compile your applications. This
9368     can be useful if you want to ensure that all user-visible strings
9369     go through QObject::tr(), for example.
9370 
9371     \sa QT_NO_CAST_FROM_ASCII
9372 */
9373 
9374 /*!
9375     \fn bool QLatin1String::operator>=(const QString &other) const
9376 
9377     Returns \c true if this string is lexically greater than or equal
9378     to string \a other; otherwise returns \c false.
9379 
9380     \sa {Comparing Strings}
9381 */
9382 
9383 /*!
9384     \fn bool QLatin1String::operator>=(const char *other) const
9385     \since 4.3
9386     \overload
9387 
9388     The \a other const char pointer is converted to a QString using
9389     the QString::fromUtf8() function.
9390 
9391     You can disable this operator by defining \c
9392     QT_NO_CAST_FROM_ASCII when you compile your applications. This
9393     can be useful if you want to ensure that all user-visible strings
9394     go through QObject::tr(), for example.
9395 
9396     \sa QT_NO_CAST_FROM_ASCII
9397 */
9398 
9399 /*!
9400     \fn bool QLatin1String::operator>=(const QByteArray &other) const
9401     \since 5.0
9402     \overload
9403 
9404     The \a other array is converted to a QString using
9405     the QString::fromUtf8() function.
9406 
9407     You can disable this operator by defining \c
9408     QT_NO_CAST_FROM_ASCII when you compile your applications. This
9409     can be useful if you want to ensure that all user-visible strings
9410     go through QObject::tr(), for example.
9411 
9412     \sa QT_NO_CAST_FROM_ASCII
9413 */
9414 
9415 /*! \fn bool QLatin1String::operator<=(const QString &other) const
9416 
9417     Returns \c true if this string is lexically less than or equal
9418     to string \a other; otherwise returns \c false.
9419 
9420     \sa {Comparing Strings}
9421 */
9422 
9423 /*!
9424     \fn bool QLatin1String::operator<=(const char *other) const
9425     \since 4.3
9426     \overload
9427 
9428     The \a other const char pointer is converted to a QString using
9429     the QString::fromUtf8() function.
9430 
9431     You can disable this operator by defining \c
9432     QT_NO_CAST_FROM_ASCII when you compile your applications. This
9433     can be useful if you want to ensure that all user-visible strings
9434     go through QObject::tr(), for example.
9435 
9436     \sa QT_NO_CAST_FROM_ASCII
9437 */
9438 
9439 /*!
9440     \fn bool QLatin1String::operator<=(const QByteArray &other) const
9441     \since 5.0
9442     \overload
9443 
9444     The \a other array is converted to a QString using
9445     the QString::fromUtf8() function.
9446 
9447     You can disable this operator by defining \c
9448     QT_NO_CAST_FROM_ASCII when you compile your applications. This
9449     can be useful if you want to ensure that all user-visible strings
9450     go through QObject::tr(), for example.
9451 
9452     \sa QT_NO_CAST_FROM_ASCII
9453 */
9454 
9455 
9456 /*! \fn bool operator==(QLatin1String s1, QLatin1String s2)
9457    \relates QLatin1String
9458 
9459    Returns \c true if string \a s1 is lexically equal to string \a s2; otherwise
9460    returns \c false.
9461 */
9462 /*! \fn bool operator!=(QLatin1String s1, QLatin1String s2)
9463    \relates QLatin1String
9464 
9465    Returns \c true if string \a s1 is lexically unequal to string \a s2; otherwise
9466    returns \c false.
9467 */
9468 /*! \fn bool operator<(QLatin1String s1, QLatin1String s2)
9469    \relates QLatin1String
9470 
9471    Returns \c true if string \a s1 is lexically smaller than string \a s2; otherwise
9472    returns \c false.
9473 */
9474 /*! \fn bool operator<=(QLatin1String s1, QLatin1String s2)
9475    \relates QLatin1String
9476 
9477    Returns \c true if string \a s1 is lexically smaller than or equal to string \a s2; otherwise
9478    returns \c false.
9479 */
9480 /*! \fn bool operator>(QLatin1String s1, QLatin1String s2)
9481    \relates QLatin1String
9482 
9483    Returns \c true if string \a s1 is lexically greater than string \a s2; otherwise
9484    returns \c false.
9485 */
9486 /*! \fn bool operator>=(QLatin1String s1, QLatin1String s2)
9487    \relates QLatin1String
9488 
9489    Returns \c true if string \a s1 is lexically greater than or equal to
9490    string \a s2; otherwise returns \c false.
9491 */
9492 
9493 
9494 #if !defined(QT_NO_DATASTREAM) || (defined(QT_BOOTSTRAPPED) && !defined(QT_BUILD_QMAKE))
9495 /*!
9496     \fn QDataStream &operator<<(QDataStream &stream, const QString &string)
9497     \relates QString
9498 
9499     Writes the given \a string to the specified \a stream.
9500 
9501     \sa {Serializing Qt Data Types}
9502 */
9503 
9504 QDataStream &operator<<(QDataStream &out, const QString &str)
9505 {
9506     if (out.version() == 1) {
9507         out << str.toLatin1();
9508     } else {
9509         if (!str.isNull() || out.version() < 3) {
9510             if ((out.byteOrder() == QDataStream::BigEndian) == (QSysInfo::ByteOrder == QSysInfo::BigEndian)) {
9511                 out.writeBytes(reinterpret_cast<const char *>(str.unicode()), size_t(sizeof(QChar) * str.length()));
9512             } else {
9513                 QVarLengthArray<char16_t> buffer(str.length());
9514                 qbswap<sizeof(char16_t)>(str.constData(), str.length(), buffer.data());
9515                 out.writeBytes(reinterpret_cast<const char *>(buffer.data()), size_t(sizeof(char16_t) * buffer.size()));
9516             }
9517         } else {
9518             // write null marker
9519             out << (quint32)0xffffffff;
9520         }
9521     }
9522     return out;
9523 }
9524 
9525 /*!
9526     \fn QDataStream &operator>>(QDataStream &stream, QString &string)
9527     \relates QString
9528 
9529     Reads a string from the specified \a stream into the given \a string.
9530 
9531     \sa {Serializing Qt Data Types}
9532 */
9533 
9534 QDataStream &operator>>(QDataStream &in, QString &str)
9535 {
9536     if (in.version() == 1) {
9537         QByteArray l;
9538         in >> l;
9539         str = QString::fromLatin1(l);
9540     } else {
9541         quint32 bytes = 0;
9542         in >> bytes;                                  // read size of string
9543         if (bytes == 0xffffffff) {                    // null string
9544             str.clear();
9545         } else if (bytes > 0) {                       // not empty
9546             if (bytes & 0x1) {
9547                 str.clear();
9548                 in.setStatus(QDataStream::ReadCorruptData);
9549                 return in;
9550             }
9551 
9552             const quint32 Step = 1024 * 1024;
9553             quint32 len = bytes / 2;
9554             quint32 allocated = 0;
9555 
9556             while (allocated < len) {
9557                 int blockSize = qMin(Step, len - allocated);
9558                 str.resize(allocated + blockSize);
9559                 if (in.readRawData(reinterpret_cast<char *>(str.data()) + allocated * 2,
9560                                    blockSize * 2) != blockSize * 2) {
9561                     str.clear();
9562                     in.setStatus(QDataStream::ReadPastEnd);
9563                     return in;
9564                 }
9565                 allocated += blockSize;
9566             }
9567 
9568             if ((in.byteOrder() == QDataStream::BigEndian)
9569                     != (QSysInfo::ByteOrder == QSysInfo::BigEndian)) {
9570                 char16_t *data = reinterpret_cast<char16_t *>(str.data());
9571                 qbswap<sizeof(*data)>(data, len, data);
9572             }
9573         } else {
9574             str = QString(QLatin1String(""));
9575         }
9576     }
9577     return in;
9578 }
9579 #endif // QT_NO_DATASTREAM
9580 
9581 /*!
9582     \typedef QString::Data
9583     \internal
9584 */
9585 
9586 /*!
9587     \typedef QString::DataPtr
9588     \internal
9589 */
9590 
9591 /*!
9592     \fn DataPtr & QString::data_ptr()
9593     \internal
9594 */
9595 
9596 /*!
9597     \since 5.11
9598     \internal
9599     \relates QStringView
9600 
9601     Returns \c true if the string is read right to left.
9602 
9603     \sa QString::isRightToLeft()
9604 */
9605 bool QtPrivate::isRightToLeft(QStringView string) noexcept
9606 {
9607     const char16_t *p = string.utf16();
9608     const char16_t * const end = p + string.size();
9609     int isolateLevel = 0;
9610     while (p < end) {
9611         uint ucs4 = *p;
9612         if (QChar::isHighSurrogate(ucs4) && p < end - 1) {
9613             char16_t low = p[1];
9614             if (QChar::isLowSurrogate(low)) {
9615                 ucs4 = QChar::surrogateToUcs4(ucs4, low);
9616                 ++p;
9617             }
9618         }
9619         switch (QChar::direction(ucs4))
9620         {
9621         case QChar::DirRLI:
9622         case QChar::DirLRI:
9623         case QChar::DirFSI:
9624             ++isolateLevel;
9625             break;
9626         case QChar::DirPDI:
9627             if (isolateLevel)
9628                 --isolateLevel;
9629             break;
9630         case QChar::DirL:
9631             if (isolateLevel)
9632                 break;
9633             return false;
9634         case QChar::DirR:
9635         case QChar::DirAL:
9636             if (isolateLevel)
9637                 break;
9638             return true;
9639         default:
9640             break;
9641         }
9642         ++p;
9643     }
9644     return false;
9645 }
9646 
9647 qsizetype QtPrivate::count(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs) noexcept
9648 {
9649     qsizetype num = 0;
9650     qsizetype i = -1;
9651     if (haystack.size() > 500 && needle.size() > 5) {
9652         QStringMatcher matcher(needle, cs);
9653         while ((i = matcher.indexIn(haystack, i + 1)) != -1)
9654             ++num;
9655     } else {
9656         while ((i = QtPrivate::findString(haystack, i + 1, needle, cs)) != -1)
9657             ++num;
9658     }
9659     return num;
9660 }
9661 
9662 qsizetype QtPrivate::count(QStringView haystack, QChar ch, Qt::CaseSensitivity cs) noexcept
9663 {
9664     qsizetype num = 0;
9665     if (cs == Qt::CaseSensitive) {
9666         for (QChar c : haystack) {
9667             if (c == ch)
9668                 ++num;
9669         }
9670     } else {
9671         ch = foldCase(ch);
9672         for (QChar c : haystack) {
9673             if (foldCase(c) == ch)
9674                 ++num;
9675         }
9676     }
9677     return num;
9678 }
9679 
9680 template <typename Haystack, typename Needle>
9681 bool qt_starts_with_impl(Haystack haystack, Needle needle, Qt::CaseSensitivity cs) noexcept
9682 {
9683     if (haystack.isNull())
9684         return needle.isNull(); // historical behavior, consider changing in ### Qt 6.
9685     const auto haystackLen = haystack.size();
9686     const auto needleLen = needle.size();
9687     if (haystackLen == 0)
9688         return needleLen == 0;
9689     if (needleLen > haystackLen)
9690         return false;
9691 
9692     return qt_compare_strings(haystack.left(needleLen), needle, cs) == 0;
9693 }
9694 
9695 static inline bool qt_starts_with(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs)
9696 {
9697     return qt_starts_with_impl(haystack, needle, cs);
9698 }
9699 
9700 static inline bool qt_starts_with(QStringView haystack, QLatin1String needle, Qt::CaseSensitivity cs)
9701 {
9702     return qt_starts_with_impl(haystack, needle, cs);
9703 }
9704 
9705 static inline bool qt_starts_with(QStringView haystack, QChar needle, Qt::CaseSensitivity cs)
9706 {
9707     return haystack.size()
9708            && (cs == Qt::CaseSensitive ? haystack.front() == needle
9709                                        : foldCase(haystack.front()) == foldCase(needle));
9710 }
9711 
9712 /*!
9713     \fn bool QtPrivate::startsWith(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs)
9714     \since 5.10
9715     \fn bool QtPrivate::startsWith(QStringView haystack, QLatin1String needle, Qt::CaseSensitivity cs)
9716     \since 5.10
9717     \fn bool QtPrivate::startsWith(QLatin1String haystack, QStringView needle, Qt::CaseSensitivity cs)
9718     \since 5.10
9719     \fn bool QtPrivate::startsWith(QLatin1String haystack, QLatin1String needle, Qt::CaseSensitivity cs)
9720     \since 5.10
9721     \internal
9722     \relates QStringView
9723 
9724     Returns \c true if \a haystack starts with \a needle,
9725     otherwise returns \c false.
9726 
9727     If \a cs is Qt::CaseSensitive (the default), the search is case-sensitive;
9728     otherwise the search is case-insensitive.
9729 
9730     \sa QtPrivate::endsWith(), QString::endsWith(), QStringView::endsWith(), QLatin1String::endsWith()
9731 */
9732 
9733 bool QtPrivate::startsWith(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs) noexcept
9734 {
9735     return qt_starts_with_impl(haystack, needle, cs);
9736 }
9737 
9738 bool QtPrivate::startsWith(QStringView haystack, QLatin1String needle, Qt::CaseSensitivity cs) noexcept
9739 {
9740     return qt_starts_with_impl(haystack, needle, cs);
9741 }
9742 
9743 bool QtPrivate::startsWith(QLatin1String haystack, QStringView needle, Qt::CaseSensitivity cs) noexcept
9744 {
9745     return qt_starts_with_impl(haystack, needle, cs);
9746 }
9747 
9748 bool QtPrivate::startsWith(QLatin1String haystack, QLatin1String needle, Qt::CaseSensitivity cs) noexcept
9749 {
9750     return qt_starts_with_impl(haystack, needle, cs);
9751 }
9752 
9753 template <typename Haystack, typename Needle>
9754 bool qt_ends_with_impl(Haystack haystack, Needle needle, Qt::CaseSensitivity cs) noexcept
9755 {
9756     if (haystack.isNull())
9757         return needle.isNull(); // historical behavior, consider changing in ### Qt 6.
9758     const auto haystackLen = haystack.size();
9759     const auto needleLen = needle.size();
9760     if (haystackLen == 0)
9761         return needleLen == 0;
9762     if (haystackLen < needleLen)
9763         return false;
9764 
9765     return qt_compare_strings(haystack.right(needleLen), needle, cs) == 0;
9766 }
9767 
9768 static inline bool qt_ends_with(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs)
9769 {
9770     return qt_ends_with_impl(haystack, needle, cs);
9771 }
9772 
9773 static inline bool qt_ends_with(QStringView haystack, QLatin1String needle, Qt::CaseSensitivity cs)
9774 {
9775     return qt_ends_with_impl(haystack, needle, cs);
9776 }
9777 
9778 static inline bool qt_ends_with(QStringView haystack, QChar needle, Qt::CaseSensitivity cs)
9779 {
9780     return haystack.size()
9781            && (cs == Qt::CaseSensitive ? haystack.back() == needle
9782                                        : foldCase(haystack.back()) == foldCase(needle));
9783 }
9784 
9785 /*!
9786     \fn bool QtPrivate::endsWith(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs)
9787     \since 5.10
9788     \fn bool QtPrivate::endsWith(QStringView haystack, QLatin1String needle, Qt::CaseSensitivity cs)
9789     \since 5.10
9790     \fn bool QtPrivate::endsWith(QLatin1String haystack, QStringView needle, Qt::CaseSensitivity cs)
9791     \since 5.10
9792     \fn bool QtPrivate::endsWith(QLatin1String haystack, QLatin1String needle, Qt::CaseSensitivity cs)
9793     \since 5.10
9794     \internal
9795     \relates QStringView
9796 
9797     Returns \c true if \a haystack ends with \a needle,
9798     otherwise returns \c false.
9799 
9800     If \a cs is Qt::CaseSensitive (the default), the search is case-sensitive;
9801     otherwise the search is case-insensitive.
9802 
9803     \sa QtPrivate::startsWith(), QString::endsWith(), QStringView::endsWith(), QLatin1String::endsWith()
9804 */
9805 
9806 bool QtPrivate::endsWith(QStringView haystack, QStringView needle, Qt::CaseSensitivity cs) noexcept
9807 {
9808     return qt_ends_with_impl(haystack, needle, cs);
9809 }
9810 
9811 bool QtPrivate::endsWith(QStringView haystack, QLatin1String needle, Qt::CaseSensitivity cs) noexcept
9812 {
9813     return qt_ends_with_impl(haystack, needle, cs);
9814 }
9815 
9816 bool QtPrivate::endsWith(QLatin1String haystack, QStringView needle, Qt::CaseSensitivity cs) noexcept
9817 {
9818     return qt_ends_with_impl(haystack, needle, cs);
9819 }
9820 
9821 bool QtPrivate::endsWith(QLatin1String haystack, QLatin1String needle, Qt::CaseSensitivity cs) noexcept
9822 {
9823     return qt_ends_with_impl(haystack, needle, cs);
9824 }
9825 
9826 namespace {
9827 template <typename Pointer>
9828 char32_t foldCaseHelper(Pointer ch, Pointer start) = delete;
9829 
9830 template <>
9831 char32_t foldCaseHelper<const QChar*>(const QChar* ch, const QChar* start)
9832 {
9833     return foldCase(reinterpret_cast<const char16_t*>(ch),
9834                     reinterpret_cast<const char16_t*>(start));
9835 }
9836 
9837 template <>
9838 char32_t foldCaseHelper<const char*>(const char* ch, const char*)
9839 {
9840     return foldCase(char16_t(uchar(*ch)));
9841 }
9842 
9843 template <typename T>
9844 char16_t valueTypeToUtf16(T t) = delete;
9845 
9846 template <>
9847 char16_t valueTypeToUtf16<QChar>(QChar t)
9848 {
9849     return t.unicode();
9850 }
9851 
9852 template <>
9853 char16_t valueTypeToUtf16<char>(char t)
9854 {
9855     return char16_t{uchar(t)};
9856 }
9857 }
9858 
9859 /*!
9860     \internal
9861 
9862     Returns the index position of the first occurrence of the
9863     character \a ch in the string given by \a str and \a len,
9864     searching forward from index
9865     position \a from. Returns -1 if \a ch could not be found.
9866 */
9867 
9868 static inline qsizetype qFindChar(QStringView str, QChar ch, qsizetype from, Qt::CaseSensitivity cs) noexcept
9869 {
9870     if (from < 0)
9871         from = qMax(from + str.size(), qsizetype(0));
9872     if (from < str.size()) {
9873         const char16_t *s = str.utf16();
9874         char16_t c = ch.unicode();
9875         const char16_t *n = s + from;
9876         const char16_t *e = s + str.size();
9877         if (cs == Qt::CaseSensitive) {
9878             n = QtPrivate::qustrchr(QStringView(n, e), c);
9879             if (n != e)
9880                 return n - s;
9881         } else {
9882             c = foldCase(c);
9883             --n;
9884             while (++n != e)
9885                 if (foldCase(*n) == c)
9886                     return n - s;
9887         }
9888     }
9889     return -1;
9890 }
9891 
9892 qsizetype QtPrivate::findString(QStringView haystack0, qsizetype from, QStringView needle0, Qt::CaseSensitivity cs) noexcept
9893 {
9894     const qsizetype l = haystack0.size();
9895     const qsizetype sl = needle0.size();
9896     if (from < 0)
9897         from += l;
9898     if (std::size_t(sl + from) > std::size_t(l))
9899         return -1;
9900     if (!sl)
9901         return from;
9902     if (!l)
9903         return -1;
9904 
9905     if (sl == 1)
9906         return qFindChar(haystack0, needle0[0], from, cs);
9907 
9908     /*
9909         We use the Boyer-Moore algorithm in cases where the overhead
9910         for the skip table should pay off, otherwise we use a simple
9911         hash function.
9912     */
9913     if (l > 500 && sl > 5)
9914         return qFindStringBoyerMoore(haystack0, from, needle0, cs);
9915 
9916     auto sv = [sl](const char16_t *v) { return QStringView(v, sl); };
9917     /*
9918         We use some hashing for efficiency's sake. Instead of
9919         comparing strings, we compare the hash value of str with that
9920         of a part of this QString. Only if that matches, we call
9921         qt_string_compare().
9922     */
9923     const char16_t *needle = needle0.utf16();
9924     const char16_t *haystack = haystack0.utf16() + from;
9925     const char16_t *end = haystack0.utf16() + (l - sl);
9926     const std::size_t sl_minus_1 = sl - 1;
9927     std::size_t hashNeedle = 0, hashHaystack = 0;
9928     qsizetype idx;
9929 
9930     if (cs == Qt::CaseSensitive) {
9931         for (idx = 0; idx < sl; ++idx) {
9932             hashNeedle = ((hashNeedle<<1) + needle[idx]);
9933             hashHaystack = ((hashHaystack<<1) + haystack[idx]);
9934         }
9935         hashHaystack -= haystack[sl_minus_1];
9936 
9937         while (haystack <= end) {
9938             hashHaystack += haystack[sl_minus_1];
9939             if (hashHaystack == hashNeedle
9940                  && qt_compare_strings(needle0, sv(haystack), Qt::CaseSensitive) == 0)
9941                 return haystack - haystack0.utf16();
9942 
9943             REHASH(*haystack);
9944             ++haystack;
9945         }
9946     } else {
9947         const char16_t *haystack_start = haystack0.utf16();
9948         for (idx = 0; idx < sl; ++idx) {
9949             hashNeedle = (hashNeedle<<1) + foldCase(needle + idx, needle);
9950             hashHaystack = (hashHaystack<<1) + foldCase(haystack + idx, haystack_start);
9951         }
9952         hashHaystack -= foldCase(haystack + sl_minus_1, haystack_start);
9953 
9954         while (haystack <= end) {
9955             hashHaystack += foldCase(haystack + sl_minus_1, haystack_start);
9956             if (hashHaystack == hashNeedle
9957                  && qt_compare_strings(needle0, sv(haystack), Qt::CaseInsensitive) == 0)
9958                 return haystack - haystack0.utf16();
9959 
9960             REHASH(foldCase(haystack, haystack_start));
9961             ++haystack;
9962         }
9963     }
9964     return -1;
9965 }
9966 
9967 template <typename Haystack>
9968 static inline qsizetype qLastIndexOf(Haystack haystack, QChar needle,
9969                                      qsizetype from, Qt::CaseSensitivity cs) noexcept
9970 {
9971     if (from < 0)
9972         from += haystack.size();
9973     if (std::size_t(from) >= std::size_t(haystack.size()))
9974         return -1;
9975     if (from >= 0) {
9976         char16_t c = needle.unicode();
9977         const auto b = haystack.data();
9978         auto n = b + from;
9979         if (cs == Qt::CaseSensitive) {
9980             for (; n >= b; --n)
9981                 if (valueTypeToUtf16(*n) == c)
9982                     return n - b;
9983         } else {
9984             c = foldCase(c);
9985             for (; n >= b; --n)
9986                 if (foldCase(valueTypeToUtf16(*n)) == c)
9987                     return n - b;
9988         }
9989     }
9990     return -1;
9991 }
9992 
9993 template<typename Haystack, typename Needle>
9994 static qsizetype qLastIndexOf(Haystack haystack0, qsizetype from,
9995                               Needle needle0, Qt::CaseSensitivity cs) noexcept
9996 {
9997     const qsizetype sl = needle0.size();
9998     if (sl == 1)
9999         return qLastIndexOf(haystack0, needle0.front(), from, cs);
10000 
10001     const qsizetype l = haystack0.size();
10002     if (from < 0)
10003         from += l;
10004     if (from == l && sl == 0)
10005         return from;
10006     const qsizetype delta = l - sl;
10007     if (std::size_t(from) >= std::size_t(l) || delta < 0)
10008         return -1;
10009     if (from > delta)
10010         from = delta;
10011 
10012     auto sv = [sl](const typename Haystack::value_type *v) { return Haystack(v, sl); };
10013 
10014     auto haystack = haystack0.data();
10015     const auto needle = needle0.data();
10016     const auto *end = haystack;
10017     haystack += from;
10018     const std::size_t sl_minus_1 = sl - 1;
10019     const auto *n = needle + sl_minus_1;
10020     const auto *h = haystack + sl_minus_1;
10021     std::size_t hashNeedle = 0, hashHaystack = 0;
10022     qsizetype idx;
10023 
10024     if (cs == Qt::CaseSensitive) {
10025         for (idx = 0; idx < sl; ++idx) {
10026             hashNeedle = (hashNeedle << 1) + valueTypeToUtf16(*(n - idx));
10027             hashHaystack = (hashHaystack << 1) + valueTypeToUtf16(*(h - idx));
10028         }
10029         hashHaystack -= valueTypeToUtf16(*haystack);
10030 
10031         while (haystack >= end) {
10032             hashHaystack += valueTypeToUtf16(*haystack);
10033             if (hashHaystack == hashNeedle
10034                  && qt_compare_strings(needle0, sv(haystack), Qt::CaseSensitive) == 0)
10035                 return haystack - end;
10036             --haystack;
10037             REHASH(valueTypeToUtf16(haystack[sl]));
10038         }
10039     } else {
10040         for (idx = 0; idx < sl; ++idx) {
10041             hashNeedle = (hashNeedle << 1) + foldCaseHelper(n - idx, needle);
10042             hashHaystack = (hashHaystack << 1) + foldCaseHelper(h - idx, end);
10043         }
10044         hashHaystack -= foldCaseHelper(haystack, end);
10045 
10046         while (haystack >= end) {
10047             hashHaystack += foldCaseHelper(haystack, end);
10048             if (hashHaystack == hashNeedle
10049                  && qt_compare_strings(sv(haystack), needle0, Qt::CaseInsensitive) == 0)
10050                 return haystack - end;
10051             --haystack;
10052             REHASH(foldCaseHelper(haystack + sl, end));
10053         }
10054     }
10055     return -1;
10056 }
10057 
10058 qsizetype QtPrivate::findString(QStringView haystack, qsizetype from, QLatin1String needle, Qt::CaseSensitivity cs) noexcept
10059 {
10060     if (haystack.size() < needle.size())
10061         return -1;
10062 
10063     QVarLengthArray<char16_t> s(needle.size());
10064     qt_from_latin1(s.data(), needle.latin1(), needle.size());
10065     return QtPrivate::findString(haystack, from, QStringView(reinterpret_cast<const QChar*>(s.constData()), s.size()), cs);
10066 }
10067 
10068 qsizetype QtPrivate::findString(QLatin1String haystack, qsizetype from, QStringView needle, Qt::CaseSensitivity cs) noexcept
10069 {
10070     if (haystack.size() < needle.size())
10071         return -1;
10072 
10073     QVarLengthArray<char16_t> s(haystack.size());
10074     qt_from_latin1(s.data(), haystack.latin1(), haystack.size());
10075     return QtPrivate::findString(QStringView(reinterpret_cast<const QChar*>(s.constData()), s.size()), from, needle, cs);
10076 }
10077 
10078 qsizetype QtPrivate::findString(QLatin1String haystack, qsizetype from, QLatin1String needle, Qt::CaseSensitivity cs) noexcept
10079 {
10080     if (haystack.size() < needle.size())
10081         return -1;
10082 
10083     QVarLengthArray<char16_t> h(haystack.size());
10084     qt_from_latin1(h.data(), haystack.latin1(), haystack.size());
10085     QVarLengthArray<char16_t> n(needle.size());
10086     qt_from_latin1(n.data(), needle.latin1(), needle.size());
10087     return QtPrivate::findString(QStringView(reinterpret_cast<const QChar*>(h.constData()), h.size()), from,
10088                                  QStringView(reinterpret_cast<const QChar*>(n.constData()), n.size()), cs);
10089 }
10090 
10091 qsizetype QtPrivate::lastIndexOf(QStringView haystack, qsizetype from, QStringView needle, Qt::CaseSensitivity cs) noexcept
10092 {
10093     return qLastIndexOf(haystack, from, needle, cs);
10094 }
10095 
10096 qsizetype QtPrivate::lastIndexOf(QStringView haystack, qsizetype from, QLatin1String needle, Qt::CaseSensitivity cs) noexcept
10097 {
10098     return qLastIndexOf(haystack, from, needle, cs);
10099 }
10100 
10101 qsizetype QtPrivate::lastIndexOf(QLatin1String haystack, qsizetype from, QStringView needle, Qt::CaseSensitivity cs) noexcept
10102 {
10103     return qLastIndexOf(haystack, from, needle, cs);
10104 }
10105 
10106 qsizetype QtPrivate::lastIndexOf(QLatin1String haystack, qsizetype from, QLatin1String needle, Qt::CaseSensitivity cs) noexcept
10107 {
10108     return qLastIndexOf(haystack, from, needle, cs);
10109 }
10110 
10111 /*!
10112     \since 5.0
10113 
10114     Converts a plain text string to an HTML string with
10115     HTML metacharacters \c{<}, \c{>}, \c{&}, and \c{"} replaced by HTML
10116     entities.
10117 
10118     Example:
10119 
10120     \snippet code/src_corelib_text_qstring.cpp 7
10121 */
10122 QString QString::toHtmlEscaped() const
10123 {
10124     QString rich;
10125     const int len = length();
10126     rich.reserve(qsizetype(len * 1.1));
10127     for (int i = 0; i < len; ++i) {
10128         if (at(i) == QLatin1Char('<'))
10129             rich += QLatin1String("&lt;");
10130         else if (at(i) == QLatin1Char('>'))
10131             rich += QLatin1String("&gt;");
10132         else if (at(i) == QLatin1Char('&'))
10133             rich += QLatin1String("&amp;");
10134         else if (at(i) == QLatin1Char('"'))
10135             rich += QLatin1String("&quot;");
10136         else
10137             rich += at(i);
10138     }
10139     rich.squeeze();
10140     return rich;
10141 }
10142 
10143 /*!
10144   \macro QStringLiteral(str)
10145   \relates QString
10146 
10147   The macro generates the data for a QString out of the string literal \a str
10148   at compile time. Creating a QString from it is free in this case, and the
10149   generated string data is stored in the read-only segment of the compiled
10150   object file.
10151 
10152   If you have code that looks like this:
10153 
10154   \snippet code/src_corelib_text_qstring.cpp 9
10155 
10156   then a temporary QString will be created to be passed as the \c{hasAttribute}
10157   function parameter. This can be quite expensive, as it involves a memory
10158   allocation and the copy/conversion of the data into QString's internal
10159   encoding.
10160 
10161   This cost can be avoided by using QStringLiteral instead:
10162 
10163   \snippet code/src_corelib_text_qstring.cpp 10
10164 
10165   In this case, QString's internal data will be generated at compile time; no
10166   conversion or allocation will occur at runtime.
10167 
10168   Using QStringLiteral instead of a double quoted plain C++ string literal can
10169   significantly speed up creation of QString instances from data known at
10170   compile time.
10171 
10172   \note QLatin1String can still be more efficient than QStringLiteral
10173   when the string is passed to a function that has an overload taking
10174   QLatin1String and this overload avoids conversion to QString.  For
10175   instance, QString::operator==() can compare to a QLatin1String
10176   directly:
10177 
10178   \snippet code/src_corelib_text_qstring.cpp 11
10179 
10180   \note Some compilers have bugs encoding strings containing characters outside
10181   the US-ASCII character set. Make sure you prefix your string with \c{u} in
10182   those cases. It is optional otherwise.
10183 
10184   \sa QByteArrayLiteral
10185 */
10186 
10187 /*!
10188     \internal
10189  */
10190 void QAbstractConcatenable::appendLatin1To(const char *a, int len, QChar *out) noexcept
10191 {
10192     qt_from_latin1(reinterpret_cast<char16_t *>(out), a, size_t(len));
10193 }
10194 
10195 double QStringView::toDouble(bool *ok) const
10196 {
10197     return QLocaleData::c()->stringToDouble(*this, ok, QLocale::RejectGroupSeparator);
10198 }
10199 
10200 float QStringView::toFloat(bool *ok) const
10201 {
10202     return QLocaleData::convertDoubleToFloat(toDouble(ok), ok);
10203 }
10204 
10205 QT_END_NAMESPACE
