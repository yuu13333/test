Please review the code below for security defects using the CWE (Common Weakness Enumeration) as a reference standard. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, state: 'No security defects are detected in the code'.

1 # Copyright (c) 2011 X.commerce, a business unit of eBay Inc.
2 # Copyright 2010 United States Government as represented by the
3 # Administrator of the National Aeronautics and Space Administration.
4 # All Rights Reserved.
5 # Copyright 2013 Red Hat, Inc.
6 #
7 #    Licensed under the Apache License, Version 2.0 (the "License"); you may
8 #    not use this file except in compliance with the License. You may obtain
9 #    a copy of the License at
10 #
11 #         http://www.apache.org/licenses/LICENSE-2.0
12 #
13 #    Unless required by applicable law or agreed to in writing, software
14 #    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
15 #    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
16 #    License for the specific language governing permissions and limitations
17 #    under the License.
18 
19 # Interactive shell based on Django:
20 #
21 # Copyright (c) 2005, the Lawrence Journal-World
22 # All rights reserved.
23 #
24 # Redistribution and use in source and binary forms, with or without
25 # modification, are permitted provided that the following conditions are met:
26 #
27 #     1. Redistributions of source code must retain the above copyright notice,
28 #        this list of conditions and the following disclaimer.
29 #
30 #     2. Redistributions in binary form must reproduce the above copyright
31 #        notice, this list of conditions and the following disclaimer in the
32 #        documentation and/or other materials provided with the distribution.
33 #
34 #     3. Neither the name of Django nor the names of its contributors may be
35 #        used to endorse or promote products derived from this software without
36 #        specific prior written permission.
37 #
38 # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
39 # "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
40 # LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
41 # A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
42 # OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
43 # SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
44 # LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
45 # DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
46 # THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
47 # (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
48 # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
49 
50 
51 """
52   CLI interface for nova management.
53 """
54 
55 from __future__ import print_function
56 
57 import argparse
58 import os
59 import sys
60 import urllib
61 
62 import decorator
63 import netaddr
64 from oslo_config import cfg
65 from oslo_db import exception as db_exc
66 from oslo_log import log as logging
67 import oslo_messaging as messaging
68 from oslo_utils import importutils
69 import six
70 
71 from nova.api.ec2 import ec2utils
72 from nova import availability_zones
73 from nova import config
74 from nova import context
75 from nova import db
76 from nova.db import migration
77 from nova import exception
78 from nova.i18n import _
79 from nova import objects
80 from nova.openstack.common import cliutils
81 from nova import quota
82 from nova import rpc
83 from nova import servicegroup
84 from nova import utils
85 from nova import version
86 
87 CONF = cfg.CONF
88 CONF.import_opt('network_manager', 'nova.service')
89 CONF.import_opt('service_down_time', 'nova.service')
90 CONF.import_opt('flat_network_bridge', 'nova.network.manager')
91 CONF.import_opt('num_networks', 'nova.network.manager')
92 CONF.import_opt('multi_host', 'nova.network.manager')
93 CONF.import_opt('network_size', 'nova.network.manager')
94 CONF.import_opt('vlan_start', 'nova.network.manager')
95 CONF.import_opt('vpn_start', 'nova.network.manager')
96 CONF.import_opt('default_floating_pool', 'nova.network.floating_ips')
97 CONF.import_opt('public_interface', 'nova.network.linux_net')
98 
99 QUOTAS = quota.QUOTAS
100 
101 _DEFAULT_LOG_LEVELS = config._DEFAULT_LOG_LEVELS + ['oslo_db=INFO']
102 
103 
104 # Decorators for actions
105 def args(*args, **kwargs):
106     def _decorator(func):
107         func.__dict__.setdefault('args', []).insert(0, (args, kwargs))
108         return func
109     return _decorator
110 
111 
112 def deprecate(msg):
113     """Decorator which print the deprecation message before the decorated
114     function is called
115     """
116     @decorator.decorator
117     def _deprecate(f, *args, **kwargs):
118         print(msg, file=sys.stderr)
119         return f(*args, **kwargs)
120     return _deprecate
121 
122 
123 def param2id(object_id):
124     """Helper function to convert various volume id types to internal id.
125     args: [object_id], e.g. 'vol-0000000a' or 'volume-0000000a' or '10'
126     """
127     if '-' in object_id:
128         return ec2utils.ec2_vol_id_to_uuid(object_id)
129     else:
130         return object_id
131 
132 
133 class VpnCommands(object):
134     """Class for managing VPNs."""
135 
136     @args('--project', dest='project_id', metavar='<Project name>',
137             help='Project name')
138     @args('--ip', metavar='<IP Address>', help='IP Address')
139     @args('--port', metavar='<Port>', help='Port')
140     def change(self, project_id, ip, port):
141         """Change the IP and port for a VPN.
142 
143         This will update all networks associated with a project
144         not sure if that's the desired behavior or not, patches accepted.
145 
146         """
147         # TODO(tr3buchet): perhaps this shouldn't update all networks
148         # associated with a project in the future
149         admin_context = context.get_admin_context()
150         networks = db.project_get_networks(admin_context, project_id)
151         for network in networks:
152             db.network_update(admin_context,
153                               network['id'],
154                               {'vpn_public_address': ip,
155                                'vpn_public_port': int(port)})
156 
157 
158 class ShellCommands(object):
159     def bpython(self):
160         """Runs a bpython shell.
161 
162         Falls back to Ipython/python shell if unavailable
163         """
164         self.run('bpython')
165 
166     def ipython(self):
167         """Runs an Ipython shell.
168 
169         Falls back to Python shell if unavailable
170         """
171         self.run('ipython')
172 
173     def python(self):
174         """Runs a python shell.
175 
176         Falls back to Python shell if unavailable
177         """
178         self.run('python')
179 
180     @args('--shell', metavar='<bpython|ipython|python >',
181             help='Python shell')
182     def run(self, shell=None):
183         """Runs a Python interactive interpreter."""
184         if not shell:
185             shell = 'bpython'
186 
187         if shell == 'bpython':
188             try:
189                 import bpython
190                 bpython.embed()
191             except ImportError:
192                 shell = 'ipython'
193         if shell == 'ipython':
194             try:
195                 from IPython import embed
196                 embed()
197             except ImportError:
198                 try:
199                     # Ipython < 0.11
200                     # Explicitly pass an empty list as arguments, because
201                     # otherwise IPython would use sys.argv from this script.
202                     import IPython
203 
204                     shell = IPython.Shell.IPShell(argv=[])
205                     shell.mainloop()
206                 except ImportError:
207                     # no IPython module
208                     shell = 'python'
209 
210         if shell == 'python':
211             import code
212             try:
213                 # Try activating rlcompleter, because it's handy.
214                 import readline
215             except ImportError:
216                 pass
217             else:
218                 # We don't have to wrap the following import in a 'try',
219                 # because we already know 'readline' was imported successfully.
220                 readline.parse_and_bind("tab:complete")
221             code.interact()
222 
223     @args('--path', metavar='<path>', help='Script path')
224     def script(self, path):
225         """Runs the script from the specified path with flags set properly.
226 
227         arguments: path
228         """
229         exec(compile(open(path).read(), path, 'exec'), locals(), globals())
230 
231 
232 def _db_error(caught_exception):
233     print(caught_exception)
234     print(_("The above error may show that the database has not "
235             "been created.\nPlease create a database using "
236             "'nova-manage db sync' before running this command."))
237     exit(1)
238 
239 
240 class ProjectCommands(object):
241     """Class for managing projects."""
242 
243     @args('--project', dest='project_id', metavar='<Project name>',
244             help='Project name')
245     @args('--user', dest='user_id', metavar='<User name>',
246             help='User name')
247     @args('--key', metavar='<key>', help='Key')
248     @args('--value', metavar='<value>', help='Value')
249     def quota(self, project_id, user_id=None, key=None, value=None):
250         """Create, update or display quotas for project/user
251 
252         If no quota key is provided, the quota will be displayed.
253         If a valid quota key is provided and it does not exist,
254         it will be created. Otherwise, it will be updated.
255         """
256 
257         ctxt = context.get_admin_context()
258         if user_id:
259             quota = QUOTAS.get_user_quotas(ctxt, project_id, user_id)
260         else:
261             user_id = None
262             quota = QUOTAS.get_project_quotas(ctxt, project_id)
263         # if key is None, that means we need to show the quotas instead
264         # of updating them
265         if key:
266             settable_quotas = QUOTAS.get_settable_quotas(ctxt,
267                                                          project_id,
268                                                          user_id=user_id)
269             if key in quota:
270                 minimum = settable_quotas[key]['minimum']
271                 maximum = settable_quotas[key]['maximum']
272                 if value.lower() == 'unlimited':
273                     value = -1
274                 if int(value) < -1:
275                     print(_('Quota limit must be -1 or greater.'))
276                     return(2)
277                 if ((int(value) < minimum) and
278                    (maximum != -1 or (maximum == -1 and int(value) != -1))):
279                     print(_('Quota limit must be greater than %s.') % minimum)
280                     return(2)
281                 if maximum != -1 and int(value) > maximum:
282                     print(_('Quota limit must be less than %s.') % maximum)
283                     return(2)
284                 try:
285                     db.quota_create(ctxt, project_id, key, value,
286                                     user_id=user_id)
287                 except exception.QuotaExists:
288                     db.quota_update(ctxt, project_id, key, value,
289                                     user_id=user_id)
290             else:
291                 print(_('%(key)s is not a valid quota key. Valid options are: '
292                         '%(options)s.') % {'key': key,
293                                            'options': ', '.join(quota)})
294                 return(2)
295         print_format = "%-36s %-10s %-10s %-10s"
296         print(print_format % (
297                     _('Quota'),
298                     _('Limit'),
299                     _('In Use'),
300                     _('Reserved')))
301         # Retrieve the quota after update
302         if user_id:
303             quota = QUOTAS.get_user_quotas(ctxt, project_id, user_id)
304         else:
305             quota = QUOTAS.get_project_quotas(ctxt, project_id)
306         for key, value in six.iteritems(quota):
307             if value['limit'] < 0 or value['limit'] is None:
308                 value['limit'] = 'unlimited'
309             print(print_format % (key, value['limit'], value['in_use'],
310                                   value['reserved']))
311 
312     @args('--project', dest='project_id', metavar='<Project name>',
313             help='Project name')
314     def scrub(self, project_id):
315         """Deletes data associated with project."""
316         admin_context = context.get_admin_context()
317         networks = db.project_get_networks(admin_context, project_id)
318         for network in networks:
319             db.network_disassociate(admin_context, network['id'])
320         groups = db.security_group_get_by_project(admin_context, project_id)
321         for group in groups:
322             db.security_group_destroy(admin_context, group['id'])
323 
324 
325 AccountCommands = ProjectCommands
326 
327 
328 class FixedIpCommands(object):
329     """Class for managing fixed IP."""
330 
331     @args('--host', metavar='<host>', help='Host')
332     def list(self, host=None):
333         """Lists all fixed IPs (optionally by host)."""
334         ctxt = context.get_admin_context()
335 
336         try:
337             if host is None:
338                 fixed_ips = db.fixed_ip_get_all(ctxt)
339             else:
340                 fixed_ips = db.fixed_ip_get_by_host(ctxt, host)
341 
342         except exception.NotFound as ex:
343             print(_("error: %s") % ex)
344             return(2)
345 
346         instances = db.instance_get_all(context.get_admin_context())
347         instances_by_uuid = {}
348         for instance in instances:
349             instances_by_uuid[instance['uuid']] = instance
350 
351         print("%-18s\t%-15s\t%-15s\t%s" % (_('network'),
352                                               _('IP address'),
353                                               _('hostname'),
354                                               _('host')))
355 
356         all_networks = {}
357         try:
358             # use network_get_all to retrieve all existing networks
359             # this is to ensure that IPs associated with deleted networks
360             # will not throw exceptions.
361             for network in db.network_get_all(context.get_admin_context()):
362                 all_networks[network.id] = network
363         except exception.NoNetworksFound:
364             # do not have any networks, so even if there are IPs, these
365             # IPs should have been deleted ones, so return.
366             print(_('No fixed IP found.'))
367             return
368 
369         has_ip = False
370         for fixed_ip in fixed_ips:
371             hostname = None
372             host = None
373             network = all_networks.get(fixed_ip['network_id'])
374             if network:
375                 has_ip = True
376                 if fixed_ip.get('instance_uuid'):
377                     instance = instances_by_uuid.get(fixed_ip['instance_uuid'])
378                     if instance:
379                         hostname = instance['hostname']
380                         host = instance['host']
381                     else:
382                         print(_('WARNING: fixed IP %s allocated to missing'
383                                 ' instance') % str(fixed_ip['address']))
384                 print("%-18s\t%-15s\t%-15s\t%s" % (
385                         network['cidr'],
386                         fixed_ip['address'],
387                         hostname, host))
388 
389         if not has_ip:
390             print(_('No fixed IP found.'))
391 
392     @args('--address', metavar='<ip address>', help='IP address')
393     def reserve(self, address):
394         """Mark fixed IP as reserved
395 
396         arguments: address
397         """
398         return self._set_reserved(address, True)
399 
400     @args('--address', metavar='<ip address>', help='IP address')
401     def unreserve(self, address):
402         """Mark fixed IP as free to use
403 
404         arguments: address
405         """
406         return self._set_reserved(address, False)
407 
408     def _set_reserved(self, address, reserved):
409         ctxt = context.get_admin_context()
410 
411         try:
412             fixed_ip = db.fixed_ip_get_by_address(ctxt, address)
413             if fixed_ip is None:
414                 raise exception.NotFound('Could not find address')
415             db.fixed_ip_update(ctxt, fixed_ip['address'],
416                                 {'reserved': reserved})
417         except exception.NotFound as ex:
418             print(_("error: %s") % ex)
419             return(2)
420 
421 
422 class FloatingIpCommands(object):
423     """Class for managing floating IP."""
424 
425     @staticmethod
426     def address_to_hosts(addresses):
427         """Iterate over hosts within an address range.
428 
429         If an explicit range specifier is missing, the parameter is
430         interpreted as a specific individual address.
431         """
432         try:
433             return [netaddr.IPAddress(addresses)]
434         except ValueError:
435             net = netaddr.IPNetwork(addresses)
436             if net.size < 4:
437                 reason = _("/%s should be specified as single address(es) "
438                            "not in cidr format") % net.prefixlen
439                 raise exception.InvalidInput(reason=reason)
440             elif net.size >= 1000000:
441                 # NOTE(dripton): If we generate a million IPs and put them in
442                 # the database, the system will slow to a crawl and/or run
443                 # out of memory and crash.  This is clearly a misconfiguration.
444                 reason = _("Too many IP addresses will be generated.  Please "
445                            "increase /%s to reduce the number generated."
446                           ) % net.prefixlen
447                 raise exception.InvalidInput(reason=reason)
448             else:
449                 return net.iter_hosts()
450 
451     @args('--ip_range', metavar='<range>', help='IP range')
452     @args('--pool', metavar='<pool>', help='Optional pool')
453     @args('--interface', metavar='<interface>', help='Optional interface')
454     def create(self, ip_range, pool=None, interface=None):
455         """Creates floating IPs for zone by range."""
456         admin_context = context.get_admin_context()
457         if not pool:
458             pool = CONF.default_floating_pool
459         if not interface:
460             interface = CONF.public_interface
461 
462         ips = [{'address': str(address), 'pool': pool, 'interface': interface}
463                for address in self.address_to_hosts(ip_range)]
464         try:
465             db.floating_ip_bulk_create(admin_context, ips, want_result=False)
466         except exception.FloatingIpExists as exc:
467             # NOTE(simplylizz): Maybe logging would be better here
468             # instead of printing, but logging isn't used here and I
469             # don't know why.
470             print('error: %s' % exc)
471             return(1)
472 
473     @args('--ip_range', metavar='<range>', help='IP range')
474     def delete(self, ip_range):
475         """Deletes floating IPs by range."""
476         admin_context = context.get_admin_context()
477 
478         ips = ({'address': str(address)}
479                for address in self.address_to_hosts(ip_range))
480         db.floating_ip_bulk_destroy(admin_context, ips)
481 
482     @args('--host', metavar='<host>', help='Host')
483     def list(self, host=None):
484         """Lists all floating IPs (optionally by host).
485 
486         Note: if host is given, only active floating IPs are returned
487         """
488         ctxt = context.get_admin_context()
489         try:
490             if host is None:
491                 floating_ips = db.floating_ip_get_all(ctxt)
492             else:
493                 floating_ips = db.floating_ip_get_all_by_host(ctxt, host)
494         except exception.NoFloatingIpsDefined:
495             print(_("No floating IP addresses have been defined."))
496             return
497         for floating_ip in floating_ips:
498             instance_uuid = None
499             if floating_ip['fixed_ip_id']:
500                 fixed_ip = db.fixed_ip_get(ctxt, floating_ip['fixed_ip_id'])
501                 instance_uuid = fixed_ip['instance_uuid']
502 
503             print("%s\t%s\t%s\t%s\t%s" % (floating_ip['project_id'],
504                                           floating_ip['address'],
505                                           instance_uuid,
506                                           floating_ip['pool'],
507                                           floating_ip['interface']))
508 
509 
510 @decorator.decorator
511 def validate_network_plugin(f, *args, **kwargs):
512     """Decorator to validate the network plugin."""
513     if utils.is_neutron():
514         print(_("ERROR: Network commands are not supported when using the "
515                 "Neutron API.  Use python-neutronclient instead."))
516         return(2)
517     return f(*args, **kwargs)
518 
519 
520 class NetworkCommands(object):
521     """Class for managing networks."""
522 
523     @validate_network_plugin
524     @args('--label', metavar='<label>', help='Label for network (ex: public)')
525     @args('--fixed_range_v4', dest='cidr', metavar='<x.x.x.x/yy>',
526             help='IPv4 subnet (ex: 10.0.0.0/8)')
527     @args('--num_networks', metavar='<number>',
528             help='Number of networks to create')
529     @args('--network_size', metavar='<number>',
530             help='Number of IPs per network')
531     @args('--vlan', metavar='<vlan id>', help='vlan id')
532     @args('--vlan_start', dest='vlan_start', metavar='<vlan start id>',
533           help='vlan start id')
534     @args('--vpn', dest='vpn_start', help='vpn start')
535     @args('--fixed_range_v6', dest='cidr_v6',
536           help='IPv6 subnet (ex: fe80::/64')
537     @args('--gateway', help='gateway')
538     @args('--gateway_v6', help='ipv6 gateway')
539     @args('--bridge', metavar='<bridge>',
540             help='VIFs on this network are connected to this bridge')
541     @args('--bridge_interface', metavar='<bridge interface>',
542             help='the bridge is connected to this interface')
543     @args('--multi_host', metavar="<'T'|'F'>",
544             help='Multi host')
545     @args('--dns1', metavar="<DNS Address>", help='First DNS')
546     @args('--dns2', metavar="<DNS Address>", help='Second DNS')
547     @args('--uuid', metavar="<network uuid>", help='Network UUID')
548     @args('--fixed_cidr', metavar='<x.x.x.x/yy>',
549             help='IPv4 subnet for fixed IPs (ex: 10.20.0.0/16)')
550     @args('--project_id', metavar="<project id>",
551           help='Project id')
552     @args('--priority', metavar="<number>", help='Network interface priority')
553     def create(self, label=None, cidr=None, num_networks=None,
554                network_size=None, multi_host=None, vlan=None,
555                vlan_start=None, vpn_start=None, cidr_v6=None, gateway=None,
556                gateway_v6=None, bridge=None, bridge_interface=None,
557                dns1=None, dns2=None, project_id=None, priority=None,
558                uuid=None, fixed_cidr=None):
559         """Creates fixed IPs for host by range."""
560         kwargs = {k: v for k, v in six.iteritems(locals())
561                   if v and k != "self"}
562         if multi_host is not None:
563             kwargs['multi_host'] = multi_host == 'T'
564         net_manager = importutils.import_object(CONF.network_manager)
565         net_manager.create_networks(context.get_admin_context(), **kwargs)
566 
567     @validate_network_plugin
568     def list(self):
569         """List all created networks."""
570         _fmt = "%-5s\t%-18s\t%-15s\t%-15s\t%-15s\t%-15s\t%-15s\t%-15s\t%-15s"
571         print(_fmt % (_('id'),
572                           _('IPv4'),
573                           _('IPv6'),
574                           _('start address'),
575                           _('DNS1'),
576                           _('DNS2'),
577                           _('VlanID'),
578                           _('project'),
579                           _("uuid")))
580         try:
581             # Since network_get_all can throw exception.NoNetworksFound
582             # for this command to show a nice result, this exception
583             # should be caught and handled as such.
584             networks = db.network_get_all(context.get_admin_context())
585         except exception.NoNetworksFound:
586             print(_('No networks found'))
587         else:
588             for network in networks:
589                 print(_fmt % (network.id,
590                               network.cidr,
591                               network.cidr_v6,
592                               network.dhcp_start,
593                               network.dns1,
594                               network.dns2,
595                               network.vlan,
596                               network.project_id,
597                               network.uuid))
598 
599     @validate_network_plugin
600     @args('--fixed_range', metavar='<x.x.x.x/yy>', help='Network to delete')
601     @args('--uuid', metavar='<uuid>', help='UUID of network to delete')
602     def delete(self, fixed_range=None, uuid=None):
603         """Deletes a network."""
604         if fixed_range is None and uuid is None:
605             raise Exception(_("Please specify either fixed_range or uuid"))
606 
607         net_manager = importutils.import_object(CONF.network_manager)
608         if "NeutronManager" in CONF.network_manager:
609             if uuid is None:
610                 raise Exception(_("UUID is required to delete "
611                                   "Neutron Networks"))
612             if fixed_range:
613                 raise Exception(_("Deleting by fixed_range is not supported "
614                                 "with the NeutronManager"))
615         # delete the network
616         net_manager.delete_network(context.get_admin_context(),
617             fixed_range, uuid)
618 
619     @validate_network_plugin
620     @args('--fixed_range', metavar='<x.x.x.x/yy>', help='Network to modify')
621     @args('--project', metavar='<project name>',
622             help='Project name to associate')
623     @args('--host', metavar='<host>', help='Host to associate')
624     @args('--disassociate-project', action="store_true", dest='dis_project',
625           default=False, help='Disassociate Network from Project')
626     @args('--disassociate-host', action="store_true", dest='dis_host',
627           default=False, help='Disassociate Host from Project')
628     def modify(self, fixed_range, project=None, host=None,
629                dis_project=None, dis_host=None):
630         """Associate/Disassociate Network with Project and/or Host
631         arguments: network project host
632         leave any field blank to ignore it
633         """
634         admin_context = context.get_admin_context()
635         network = db.network_get_by_cidr(admin_context, fixed_range)
636         net = {}
637         # User can choose the following actions each for project and host.
638         # 1) Associate (set not None value given by project/host parameter)
639         # 2) Disassociate (set None by disassociate parameter)
640         # 3) Keep unchanged (project/host key is not added to 'net')
641         if dis_project:
642             net['project_id'] = None
643         if dis_host:
644             net['host'] = None
645 
646         # The --disassociate-X are boolean options, but if they user
647         # mistakenly provides a value, it will be used as a positional argument
648         # and be erroneously interepreted as some other parameter (e.g.
649         # a project instead of host value). The safest thing to do is error-out
650         # with a message indicating that there is probably a problem with
651         # how the disassociate modifications are being used.
652         if dis_project or dis_host:
653             if project or host:
654                 error_msg = "ERROR: Unexpected arguments provided. Please " \
655                     "use separate commands."
656                 print(error_msg)
657                 return(1)
658             db.network_update(admin_context, network['id'], net)
659             return
660 
661         if project:
662             net['project_id'] = project
663         if host:
664             net['host'] = host
665 
666         db.network_update(admin_context, network['id'], net)
667 
668 
669 class VmCommands(object):
670     """Class for managing VM instances."""
671 
672     @args('--host', metavar='<host>', help='Host')
673     def list(self, host=None):
674         """Show a list of all instances."""
675 
676         print(("%-10s %-15s %-10s %-10s %-26s %-9s %-9s %-9s"
677                "  %-10s %-10s %-10s %-5s" % (_('instance'),
678                                              _('node'),
679                                              _('type'),
680                                              _('state'),
681                                              _('launched'),
682                                              _('image'),
683                                              _('kernel'),
684                                              _('ramdisk'),
685                                              _('project'),
686                                              _('user'),
687                                              _('zone'),
688                                              _('index'))))
689 
690         if host is None:
691             instances = objects.InstanceList.get_by_filters(
692                 context.get_admin_context(), {}, expected_attrs=['flavor'])
693         else:
694             instances = objects.InstanceList.get_by_host(
695                 context.get_admin_context(), host, expected_attrs=['flavor'])
696 
697         for instance in instances:
698             instance_type = instance.get_flavor()
699             print(("%-10s %-15s %-10s %-10s %-26s %-9s %-9s %-9s"
700                    " %-10s %-10s %-10s %-5d" % (instance.display_name,
701                                                 instance.host,
702                                                 instance_type.name,
703                                                 instance.vm_state,
704                                                 instance.launched_at,
705                                                 instance.image_ref,
706                                                 instance.kernel_id,
707                                                 instance.ramdisk_id,
708                                                 instance.project_id,
709                                                 instance.user_id,
710                                                 instance.availability_zone,
711                                                 instance.launch_index or 0)))
712 
713 
714 class ServiceCommands(object):
715     """Enable and disable running services."""
716 
717     description = ('DEPRECATED: Use the nova service-* commands from '
718                    'python-novaclient instead or the os-services REST '
719                    'resource. The service subcommand will be '
720                    'removed in the 14.0 release.')
721 
722     @deprecate(description)
723     @args('--host', metavar='<host>', help='Host')
724     @args('--service', metavar='<service>', help='Nova service')
725     def list(self, host=None, service=None):
726         """Show a list of all running services. Filter by host & service
727         name
728         """
729         servicegroup_api = servicegroup.API()
730         ctxt = context.get_admin_context()
731         services = db.service_get_all(ctxt)
732         services = availability_zones.set_availability_zones(ctxt, services)
733         if host:
734             services = [s for s in services if s['host'] == host]
735         if service:
736             services = [s for s in services if s['binary'] == service]
737         print_format = "%-16s %-36s %-16s %-10s %-5s %-10s"
738         print(print_format % (
739                     _('Binary'),
740                     _('Host'),
741                     _('Zone'),
742                     _('Status'),
743                     _('State'),
744                     _('Updated_At')))
745         for svc in services:
746             alive = servicegroup_api.service_is_up(svc)
747             art = (alive and ":-)") or "XXX"
748             active = 'enabled'
749             if svc['disabled']:
750                 active = 'disabled'
751             print(print_format % (svc['binary'], svc['host'],
752                                   svc['availability_zone'], active, art,
753                                   svc['updated_at']))
754 
755     @deprecate(description)
756     @args('--host', metavar='<host>', help='Host')
757     @args('--service', metavar='<service>', help='Nova service')
758     def enable(self, host, service):
759         """Enable scheduling for a service."""
760         ctxt = context.get_admin_context()
761         try:
762             svc = db.service_get_by_host_and_binary(ctxt, host, service)
763             db.service_update(ctxt, svc['id'], {'disabled': False})
764         except exception.NotFound as ex:
765             print(_("error: %s") % ex)
766             return(2)
767         print((_("Service %(service)s on host %(host)s enabled.") %
768                {'service': service, 'host': host}))
769 
770     @deprecate(description)
771     @args('--host', metavar='<host>', help='Host')
772     @args('--service', metavar='<service>', help='Nova service')
773     def disable(self, host, service):
774         """Disable scheduling for a service."""
775         ctxt = context.get_admin_context()
776         try:
777             svc = db.service_get_by_host_and_binary(ctxt, host, service)
778             db.service_update(ctxt, svc['id'], {'disabled': True})
779         except exception.NotFound as ex:
780             print(_("error: %s") % ex)
781             return(2)
782         print((_("Service %(service)s on host %(host)s disabled.") %
783                {'service': service, 'host': host}))
784 
785     def _show_host_resources(self, context, host):
786         """Shows the physical/usage resource given by hosts.
787 
788         :param context: security context
789         :param host: hostname
790         :returns:
791             example format is below::
792 
793                 {'resource':D, 'usage':{proj_id1:D, proj_id2:D}}
794                 D: {'vcpus': 3, 'memory_mb': 2048, 'local_gb': 2048,
795                     'vcpus_used': 12, 'memory_mb_used': 10240,
796                     'local_gb_used': 64}
797 
798         """
799         # Getting compute node info and related instances info
800         compute_ref = (
801             objects.ComputeNode.get_first_node_by_host_for_old_compat(context,
802                                                                       host))
803         instance_refs = db.instance_get_all_by_host(context, host)
804 
805         # Getting total available/used resource
806         resource = {'vcpus': compute_ref.vcpus,
807                     'memory_mb': compute_ref.memory_mb,
808                     'local_gb': compute_ref.local_gb,
809                     'vcpus_used': compute_ref.vcpus_used,
810                     'memory_mb_used': compute_ref.memory_mb_used,
811                     'local_gb_used': compute_ref.local_gb_used}
812         usage = dict()
813         if not instance_refs:
814             return {'resource': resource, 'usage': usage}
815 
816         # Getting usage resource per project
817         project_ids = [i['project_id'] for i in instance_refs]
818         project_ids = list(set(project_ids))
819         for project_id in project_ids:
820             vcpus = [i['vcpus'] for i in instance_refs
821                      if i['project_id'] == project_id]
822 
823             mem = [i['memory_mb'] for i in instance_refs
824                    if i['project_id'] == project_id]
825 
826             root = [i['root_gb'] for i in instance_refs
827                     if i['project_id'] == project_id]
828 
829             ephemeral = [i['ephemeral_gb'] for i in instance_refs
830                          if i['project_id'] == project_id]
831 
832             usage[project_id] = {'vcpus': sum(vcpus),
833                                  'memory_mb': sum(mem),
834                                  'root_gb': sum(root),
835                                  'ephemeral_gb': sum(ephemeral)}
836 
837         return {'resource': resource, 'usage': usage}
838 
839     @deprecate(description)
840     @args('--host', metavar='<host>', help='Host')
841     def describe_resource(self, host):
842         """Describes cpu/memory/hdd info for host.
843 
844         :param host: hostname.
845 
846         """
847         try:
848             result = self._show_host_resources(context.get_admin_context(),
849                                                host=host)
850         except exception.NovaException as ex:
851             print(_("error: %s") % ex)
852             return 2
853 
854         if not isinstance(result, dict):
855             print(_('An unexpected error has occurred.'))
856             print(_('[Result]'), result)
857         else:
858             # Printing a total and used_now
859             # (NOTE)The host name width 16 characters
860             print('%(a)-25s%(b)16s%(c)8s%(d)8s%(e)8s' % {"a": _('HOST'),
861                                                          "b": _('PROJECT'),
862                                                          "c": _('cpu'),
863                                                          "d": _('mem(mb)'),
864                                                          "e": _('hdd')})
865             print(('%(a)-16s(total)%(b)26s%(c)8s%(d)8s' %
866                    {"a": host,
867                     "b": result['resource']['vcpus'],
868                     "c": result['resource']['memory_mb'],
869                     "d": result['resource']['local_gb']}))
870 
871             print(('%(a)-16s(used_now)%(b)23s%(c)8s%(d)8s' %
872                    {"a": host,
873                     "b": result['resource']['vcpus_used'],
874                     "c": result['resource']['memory_mb_used'],
875                     "d": result['resource']['local_gb_used']}))
876 
877             # Printing a used_max
878             cpu_sum = 0
879             mem_sum = 0
880             hdd_sum = 0
881             for p_id, val in result['usage'].items():
882                 cpu_sum += val['vcpus']
883                 mem_sum += val['memory_mb']
884                 hdd_sum += val['root_gb']
885                 hdd_sum += val['ephemeral_gb']
886             print('%(a)-16s(used_max)%(b)23s%(c)8s%(d)8s' % {"a": host,
887                                                              "b": cpu_sum,
888                                                              "c": mem_sum,
889                                                              "d": hdd_sum})
890 
891             for p_id, val in result['usage'].items():
892                 print('%(a)-25s%(b)16s%(c)8s%(d)8s%(e)8s' % {
893                         "a": host,
894                         "b": p_id,
895                         "c": val['vcpus'],
896                         "d": val['memory_mb'],
897                         "e": val['root_gb'] + val['ephemeral_gb']})
898 
899 
900 class HostCommands(object):
901     """List hosts."""
902 
903     def list(self, zone=None):
904         """Show a list of all physical hosts. Filter by zone.
905         args: [zone]
906         """
907         print("%-25s\t%-15s" % (_('host'),
908                                 _('zone')))
909         ctxt = context.get_admin_context()
910         services = db.service_get_all(ctxt)
911         services = availability_zones.set_availability_zones(ctxt, services)
912         if zone:
913             services = [s for s in services if s['availability_zone'] == zone]
914         hosts = []
915         for srv in services:
916             if not [h for h in hosts if h['host'] == srv['host']]:
917                 hosts.append(srv)
918 
919         for h in hosts:
920             print("%-25s\t%-15s" % (h['host'], h['availability_zone']))
921 
922 
923 class DbCommands(object):
924     """Class for managing the main database."""
925 
926     def __init__(self):
927         pass
928 
929     @args('--version', metavar='<version>', help='Database version')
930     def sync(self, version=None):
931         """Sync the database up to the most recent version."""
932         return migration.db_sync(version)
933 
934     def version(self):
935         """Print the current database version."""
936         print(migration.db_version())
937 
938     @args('--max_rows', metavar='<number>',
939             help='Maximum number of deleted rows to archive')
940     @args('--verbose', action='store_true', dest='verbose', default=False,
941           help='Print how many rows were archived per table.')
942     def archive_deleted_rows(self, max_rows, verbose=False):
943         """Move up to max_rows deleted rows from production tables to shadow
944         tables.
945         """
946         if max_rows is not None:
947             max_rows = int(max_rows)
948             if max_rows < 0:
949                 print(_("Must supply a positive value for max_rows"))
950                 return(1)
951         table_to_rows_archived = db.archive_deleted_rows(max_rows)
952         if verbose:
953             if table_to_rows_archived:
954                 cliutils.print_dict(table_to_rows_archived, _('Table'),
955                                     dict_value=_('Number of Rows Archived'))
956             else:
957                 print(_('Nothing was archived.'))
958 
959     @args('--delete', action='store_true', dest='delete',
960           help='If specified, automatically delete any records found where '
961                'instance_uuid is NULL.')
962     def null_instance_uuid_scan(self, delete=False):
963         """Lists and optionally deletes database records where
964         instance_uuid is NULL.
965         """
966         hits = migration.db_null_instance_uuid_scan(delete)
967         records_found = False
968         for table_name, records in six.iteritems(hits):
969             # Don't print anything for 0 hits
970             if records:
971                 records_found = True
972                 if delete:
973                     print(_("Deleted %(records)d records "
974                             "from table '%(table_name)s'.") %
975                           {'records': records, 'table_name': table_name})
976                 else:
977                     print(_("There are %(records)d records in the "
978                             "'%(table_name)s' table where the uuid or "
979                             "instance_uuid column is NULL. Run this "
980                             "command again with the --delete option after you "
981                             "have backed up any necessary data.") %
982                           {'records': records, 'table_name': table_name})
983         # check to see if we didn't find anything
984         if not records_found:
985             print(_('There were no records found where '
986                     'instance_uuid was NULL.'))
987 
988     @args('--dry-run', action='store_true', dest='dry_run',
989           default=False, help='Print SQL statements instead of executing')
990     @args('--older-than', dest='older_than',
991           default=90, help='Days from today to begin purging')
992     @args('--max-number', metavar='<number>', dest='max_number',
993           help='Maximum number of instances to consider')
994     def purge_deleted_instances(self, dry_run=False, older_than=90,
995                                 max_number=None):
996         """Removes soft deleted instance data"""
997         admin_context = context.get_admin_context(read_deleted='yes')
998         instance_count = db.instances_purge_deleted(admin_context, dry_run,
999                                                     older_than,
1000                                                     max_number)
1001         if not dry_run:
1002             print(_("Purged %d instances from the DB") % instance_count)
1003         else:
1004             print (_("There are at least %d instances in the DB that are soft "
1005                      "deleted.  Run this command again without the dry-run "
1006                      "option to purge these soft-deleted instances.")
1007                      % instance_count)
1008 
1009 
1010 class ApiDbCommands(object):
1011     """Class for managing the api database."""
1012 
1013     def __init__(self):
1014         pass
1015 
1016     @args('--version', metavar='<version>', help='Database version')
1017     def sync(self, version=None):
1018         """Sync the database up to the most recent version."""
1019         return migration.db_sync(version, database='api')
1020 
1021     def version(self):
1022         """Print the current database version."""
1023         print(migration.db_version(database='api'))
1024 
1025 
1026 class AgentBuildCommands(object):
1027     """Class for managing agent builds."""
1028 
1029     @args('--os', metavar='<os>', help='os')
1030     @args('--architecture', dest='architecture',
1031             metavar='<architecture>', help='architecture')
1032     @args('--version', metavar='<version>', help='version')
1033     @args('--url', metavar='<url>', help='url')
1034     @args('--md5hash', metavar='<md5hash>', help='md5hash')
1035     @args('--hypervisor', metavar='<hypervisor>',
1036             help='hypervisor(default: xen)')
1037     def create(self, os, architecture, version, url, md5hash,
1038                 hypervisor='xen'):
1039         """Creates a new agent build."""
1040         ctxt = context.get_admin_context()
1041         db.agent_build_create(ctxt, {'hypervisor': hypervisor,
1042                                      'os': os,
1043                                      'architecture': architecture,
1044                                      'version': version,
1045                                      'url': url,
1046                                      'md5hash': md5hash})
1047 
1048     @args('--os', metavar='<os>', help='os')
1049     @args('--architecture', dest='architecture',
1050             metavar='<architecture>', help='architecture')
1051     @args('--hypervisor', metavar='<hypervisor>',
1052             help='hypervisor(default: xen)')
1053     def delete(self, os, architecture, hypervisor='xen'):
1054         """Deletes an existing agent build."""
1055         ctxt = context.get_admin_context()
1056         agent_build_ref = db.agent_build_get_by_triple(ctxt,
1057                                   hypervisor, os, architecture)
1058         db.agent_build_destroy(ctxt, agent_build_ref['id'])
1059 
1060     @args('--hypervisor', metavar='<hypervisor>',
1061             help='hypervisor(default: None)')
1062     def list(self, hypervisor=None):
1063         """Lists all agent builds.
1064 
1065         arguments: <none>
1066         """
1067         fmt = "%-10s  %-8s  %12s  %s"
1068         ctxt = context.get_admin_context()
1069         by_hypervisor = {}
1070         for agent_build in db.agent_build_get_all(ctxt):
1071             buildlist = by_hypervisor.get(agent_build.hypervisor)
1072             if not buildlist:
1073                 buildlist = by_hypervisor[agent_build.hypervisor] = []
1074 
1075             buildlist.append(agent_build)
1076 
1077         for key, buildlist in six.iteritems(by_hypervisor):
1078             if hypervisor and key != hypervisor:
1079                 continue
1080 
1081             print(_('Hypervisor: %s') % key)
1082             print(fmt % ('-' * 10, '-' * 8, '-' * 12, '-' * 32))
1083             for agent_build in buildlist:
1084                 print(fmt % (agent_build.os, agent_build.architecture,
1085                              agent_build.version, agent_build.md5hash))
1086                 print('    %s' % agent_build.url)
1087 
1088             print()
1089 
1090     @args('--os', metavar='<os>', help='os')
1091     @args('--architecture', dest='architecture',
1092             metavar='<architecture>', help='architecture')
1093     @args('--version', metavar='<version>', help='version')
1094     @args('--url', metavar='<url>', help='url')
1095     @args('--md5hash', metavar='<md5hash>', help='md5hash')
1096     @args('--hypervisor', metavar='<hypervisor>',
1097             help='hypervisor(default: xen)')
1098     def modify(self, os, architecture, version, url, md5hash,
1099                hypervisor='xen'):
1100         """Update an existing agent build."""
1101         ctxt = context.get_admin_context()
1102         agent_build_ref = db.agent_build_get_by_triple(ctxt,
1103                                   hypervisor, os, architecture)
1104         db.agent_build_update(ctxt, agent_build_ref['id'],
1105                               {'version': version,
1106                                'url': url,
1107                                'md5hash': md5hash})
1108 
1109 
1110 class GetLogCommands(object):
1111     """Get logging information."""
1112 
1113     def errors(self):
1114         """Get all of the errors from the log files."""
1115         error_found = 0
1116         if CONF.log_dir:
1117             logs = [x for x in os.listdir(CONF.log_dir) if x.endswith('.log')]
1118             for file in logs:
1119                 log_file = os.path.join(CONF.log_dir, file)
1120                 lines = [line.strip() for line in open(log_file, "r")]
1121                 lines.reverse()
1122                 print_name = 0
1123                 for index, line in enumerate(lines):
1124                     if line.find(" ERROR ") > 0:
1125                         error_found += 1
1126                         if print_name == 0:
1127                             print(log_file + ":-")
1128                             print_name = 1
1129                         linenum = len(lines) - index
1130                         print((_('Line %(linenum)d : %(line)s') %
1131                                {'linenum': linenum, 'line': line}))
1132         if error_found == 0:
1133             print(_('No errors in logfiles!'))
1134 
1135     @args('--num_entries', metavar='<number of entries>',
1136             help='number of entries(default: 10)')
1137     def syslog(self, num_entries=10):
1138         """Get <num_entries> of the nova syslog events."""
1139         entries = int(num_entries)
1140         count = 0
1141         log_file = ''
1142         if os.path.exists('/var/log/syslog'):
1143             log_file = '/var/log/syslog'
1144         elif os.path.exists('/var/log/messages'):
1145             log_file = '/var/log/messages'
1146         else:
1147             print(_('Unable to find system log file!'))
1148             return(1)
1149         lines = [line.strip() for line in open(log_file, "r")]
1150         lines.reverse()
1151         print(_('Last %s nova syslog entries:-') % (entries))
1152         for line in lines:
1153             if line.find("nova") > 0:
1154                 count += 1
1155                 print("%s" % (line))
1156             if count == entries:
1157                 break
1158 
1159         if count == 0:
1160             print(_('No nova entries in syslog!'))
1161 
1162 
1163 class CellCommands(object):
1164     """Commands for managing cells."""
1165 
1166     def _create_transport_hosts(self, username, password,
1167                                 broker_hosts=None, hostname=None, port=None):
1168         """Returns a list of oslo.messaging.TransportHost objects."""
1169         transport_hosts = []
1170         # Either broker-hosts or hostname should be set
1171         if broker_hosts:
1172             hosts = broker_hosts.split(',')
1173             for host in hosts:
1174                 host = host.strip()
1175                 broker_hostname, broker_port = utils.parse_server_string(host)
1176                 if not broker_port:
1177                     msg = _('Invalid broker_hosts value: %s. It should be'
1178                             ' in hostname:port format') % host
1179                     raise ValueError(msg)
1180                 try:
1181                     broker_port = int(broker_port)
1182                 except ValueError:
1183                     msg = _('Invalid port value: %s. It should be '
1184                              'an integer') % broker_port
1185                     raise ValueError(msg)
1186                 transport_hosts.append(
1187                                messaging.TransportHost(
1188                                    hostname=broker_hostname,
1189                                    port=broker_port,
1190                                    username=username,
1191                                    password=password))
1192         else:
1193             try:
1194                 port = int(port)
1195             except ValueError:
1196                 msg = _("Invalid port value: %s. Should be an integer") % port
1197                 raise ValueError(msg)
1198             transport_hosts.append(
1199                            messaging.TransportHost(
1200                                hostname=hostname,
1201                                port=port,
1202                                username=username,
1203                                password=password))
1204         return transport_hosts
1205 
1206     @args('--name', metavar='<name>', help='Name for the new cell')
1207     @args('--cell_type', metavar='<parent|api|child|compute>',
1208          help='Whether the cell is parent/api or child/compute')
1209     @args('--username', metavar='<username>',
1210          help='Username for the message broker in this cell')
1211     @args('--password', metavar='<password>',
1212          help='Password for the message broker in this cell')
1213     @args('--broker_hosts', metavar='<broker_hosts>',
1214          help='Comma separated list of message brokers in this cell. '
1215               'Each Broker is specified as hostname:port with both '
1216               'mandatory. This option overrides the --hostname '
1217               'and --port options (if provided). ')
1218     @args('--hostname', metavar='<hostname>',
1219          help='Address of the message broker in this cell')
1220     @args('--port', metavar='<number>',
1221          help='Port number of the message broker in this cell')
1222     @args('--virtual_host', metavar='<virtual_host>',
1223          help='The virtual host of the message broker in this cell')
1224     @args('--woffset', metavar='<float>')
1225     @args('--wscale', metavar='<float>')
1226     def create(self, name, cell_type='child', username=None, broker_hosts=None,
1227                password=None, hostname=None, port=None, virtual_host=None,
1228                woffset=None, wscale=None):
1229 
1230         if cell_type not in ['parent', 'child', 'api', 'compute']:
1231             print("Error: cell type must be 'parent'/'api' or "
1232                 "'child'/'compute'")
1233             return(2)
1234 
1235         # Set up the transport URL
1236         transport_hosts = self._create_transport_hosts(
1237                                                  username, password,
1238                                                  broker_hosts, hostname,
1239                                                  port)
1240         transport_url = rpc.get_transport_url()
1241         transport_url.hosts.extend(transport_hosts)
1242         transport_url.virtual_host = virtual_host
1243 
1244         is_parent = False
1245         if cell_type in ['api', 'parent']:
1246             is_parent = True
1247         values = {'name': name,
1248                   'is_parent': is_parent,
1249                   'transport_url': urllib.unquote(str(transport_url)),
1250                   'weight_offset': float(woffset),
1251                   'weight_scale': float(wscale)}
1252         ctxt = context.get_admin_context()
1253         db.cell_create(ctxt, values)
1254 
1255     @args('--cell_name', metavar='<cell_name>',
1256           help='Name of the cell to delete')
1257     def delete(self, cell_name):
1258         ctxt = context.get_admin_context()
1259         db.cell_delete(ctxt, cell_name)
1260 
1261     def list(self):
1262         ctxt = context.get_admin_context()
1263         cells = db.cell_get_all(ctxt)
1264         fmt = "%3s  %-10s  %-6s  %-10s  %-15s  %-5s  %-10s"
1265         print(fmt % ('Id', 'Name', 'Type', 'Username', 'Hostname',
1266                 'Port', 'VHost'))
1267         print(fmt % ('-' * 3, '-' * 10, '-' * 6, '-' * 10, '-' * 15,
1268                 '-' * 5, '-' * 10))
1269         for cell in cells:
1270             url = rpc.get_transport_url(cell.transport_url)
1271             host = url.hosts[0] if url.hosts else messaging.TransportHost()
1272             print(fmt % (cell.id, cell.name,
1273                     'parent' if cell.is_parent else 'child',
1274                     host.username, host.hostname,
1275                     host.port, url.virtual_host))
1276         print(fmt % ('-' * 3, '-' * 10, '-' * 6, '-' * 10, '-' * 15,
1277                 '-' * 5, '-' * 10))
1278 
1279 
1280 class CellV2Commands(object):
1281     """Commands for managing cells v2."""
1282 
1283     @args('--cell_uuid', metavar='<cell_uuid>', help='The cell uuid')
1284     @args('--limit', metavar='<limit>',
1285           help='Maximum number of instances to map')
1286     @args('--marker', metavar='<marker',
1287           help='The last updated instance UUID')
1288     @args('--verbose', metavar='<verbose>',
1289           help='Provide output for the registration')
1290     def map_instances(self, cell_uuid=None, limit=None,
1291                       marker=None, verbose=0):
1292         if limit is not None:
1293             limit = int(limit)
1294             if limit < 0:
1295                 print('Must supply a positive value for limit')
1296                 return(1)
1297         ctxt = context.get_admin_context(read_deleted='yes')
1298         if cell_uuid is None:
1299             raise Exception(_("cell_uuid must be set"))
1300         else:
1301             # Validate the the cell exists
1302             cell_mapping = objects.CellMapping.get_by_uuid(ctxt, cell_uuid)
1303         filters = {}
1304         instances = objects.InstanceList.get_by_filters(
1305                 ctxt, filters, sort_key='created_at', sort_dir='asc',
1306                 limit=limit, marker=marker)
1307         if verbose:
1308             fmt = "%s instances retrieved to be mapped to cell %s"
1309             print(fmt % (len(instances), cell_uuid))
1310 
1311         mapped = 0
1312         for instance in instances:
1313             try:
1314                 mapping = objects.InstanceMapping(ctxt)
1315                 mapping.instance_uuid = instance.uuid
1316                 mapping.cell_id = cell_mapping.id
1317                 mapping.project_id = instance.project_id
1318                 mapping.create()
1319             except db_exc.DBDuplicateEntry:
1320                 if verbose:
1321                     print("%s already mapped to cell" % instance.uuid)
1322                 continue
1323             mapped += 1
1324 
1325         fmt = "%s instances registered to cell %s"
1326         print(fmt % (mapped, cell_mapping.uuid))
1327         if instances:
1328             instance = instances[-1]
1329             print('Next marker: - %s' % instance.uuid)
1330 
1331 
1332 CATEGORIES = {
1333     'account': AccountCommands,
1334     'agent': AgentBuildCommands,
1335     'api_db': ApiDbCommands,
1336     'cell': CellCommands,
1337     'cell_v2': CellV2Commands,
1338     'db': DbCommands,
1339     'fixed': FixedIpCommands,
1340     'floating': FloatingIpCommands,
1341     'host': HostCommands,
1342     'logs': GetLogCommands,
1343     'network': NetworkCommands,
1344     'project': ProjectCommands,
1345     'service': ServiceCommands,
1346     'shell': ShellCommands,
1347     'vm': VmCommands,
1348     'vpn': VpnCommands,
1349 }
1350 
1351 
1352 def methods_of(obj):
1353     """Get all callable methods of an object that don't start with underscore
1354 
1355     returns a list of tuples of the form (method_name, method)
1356     """
1357     result = []
1358     for i in dir(obj):
1359         if callable(getattr(obj, i)) and not i.startswith('_'):
1360             result.append((i, getattr(obj, i)))
1361     return result
1362 
1363 
1364 def add_command_parsers(subparsers):
1365     parser = subparsers.add_parser('version')
1366 
1367     parser = subparsers.add_parser('bash-completion')
1368     parser.add_argument('query_category', nargs='?')
1369 
1370     for category in CATEGORIES:
1371         command_object = CATEGORIES[category]()
1372 
1373         desc = getattr(command_object, 'description', None)
1374         parser = subparsers.add_parser(category, description=desc)
1375         parser.set_defaults(command_object=command_object)
1376 
1377         category_subparsers = parser.add_subparsers(dest='action')
1378 
1379         for (action, action_fn) in methods_of(command_object):
1380             parser = category_subparsers.add_parser(action, description=desc)
1381 
1382             action_kwargs = []
1383             for args, kwargs in getattr(action_fn, 'args', []):
1384                 # FIXME(markmc): hack to assume dest is the arg name without
1385                 # the leading hyphens if no dest is supplied
1386                 kwargs.setdefault('dest', args[0][2:])
1387                 if kwargs['dest'].startswith('action_kwarg_'):
1388                     action_kwargs.append(
1389                             kwargs['dest'][len('action_kwarg_'):])
1390                 else:
1391                     action_kwargs.append(kwargs['dest'])
1392                     kwargs['dest'] = 'action_kwarg_' + kwargs['dest']
1393 
1394                 parser.add_argument(*args, **kwargs)
1395 
1396             parser.set_defaults(action_fn=action_fn)
1397             parser.set_defaults(action_kwargs=action_kwargs)
1398 
1399             parser.add_argument('action_args', nargs='*',
1400                                 help=argparse.SUPPRESS)
1401 
1402 
1403 category_opt = cfg.SubCommandOpt('category',
1404                                  title='Command categories',
1405                                  help='Available categories',
1406                                  handler=add_command_parsers)
1407 
1408 
1409 def main():
1410     """Parse options and call the appropriate class/method."""
1411     CONF.register_cli_opt(category_opt)
1412     try:
1413         config.parse_args(sys.argv)
1414         logging.set_defaults(default_log_levels=_DEFAULT_LOG_LEVELS)
1415         logging.setup(CONF, "nova")
1416     except cfg.ConfigFilesNotFoundError:
1417         cfgfile = CONF.config_file[-1] if CONF.config_file else None
1418         if cfgfile and not os.access(cfgfile, os.R_OK):
1419             st = os.stat(cfgfile)
1420             print(_("Could not read %s. Re-running with sudo") % cfgfile)
1421             try:
1422                 os.execvp('sudo', ['sudo', '-u', '#%s' % st.st_uid] + sys.argv)
1423             except Exception:
1424                 print(_('sudo failed, continuing as if nothing happened'))
1425 
1426         print(_('Please re-run nova-manage as root.'))
1427         return(2)
1428 
1429     objects.register_all()
1430 
1431     if CONF.category.name == "version":
1432         print(version.version_string_with_package())
1433         return(0)
1434 
1435     if CONF.category.name == "bash-completion":
1436         if not CONF.category.query_category:
1437             print(" ".join(CATEGORIES.keys()))
1438         elif CONF.category.query_category in CATEGORIES:
1439             fn = CATEGORIES[CONF.category.query_category]
1440             command_object = fn()
1441             actions = methods_of(command_object)
1442             print(" ".join([k for (k, v) in actions]))
1443         return(0)
1444 
1445     fn = CONF.category.action_fn
1446     fn_args = [arg.decode('utf-8') for arg in CONF.category.action_args]
1447     fn_kwargs = {}
1448     for k in CONF.category.action_kwargs:
1449         v = getattr(CONF.category, 'action_kwarg_' + k)
1450         if v is None:
1451             continue
1452         if isinstance(v, six.string_types):
1453             v = v.decode('utf-8')
1454         fn_kwargs[k] = v
1455 
1456     # call the action with the remaining arguments
1457     # check arguments
1458     try:
1459         cliutils.validate_args(fn, *fn_args, **fn_kwargs)
1460     except cliutils.MissingArgs as e:
1461         # NOTE(mikal): this isn't the most helpful error message ever. It is
1462         # long, and tells you a lot of things you probably don't want to know
1463         # if you just got a single arg wrong.
1464         print(fn.__doc__)
1465         CONF.print_help()
1466         print(e)
1467         return(1)
1468     try:
1469         ret = fn(*fn_args, **fn_kwargs)
1470         rpc.cleanup()
1471         return(ret)
1472     except Exception:
1473         print(_("Command failed, please check log for more info"))
1474         raise
