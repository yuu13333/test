Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 # Copyright (c) 2014 Red Hat, Inc.
2 # All Rights Reserved.
3 #
4 #    Licensed under the Apache License, Version 2.0 (the "License"); you may
5 #    not use this file except in compliance with the License. You may obtain
6 #    a copy of the License at
7 #
8 #         http://www.apache.org/licenses/LICENSE-2.0
9 #
10 #    Unless required by applicable law or agreed to in writing, software
11 #    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
12 #    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
13 #    License for the specific language governing permissions and limitations
14 #    under the License.
15 
16 import contextlib
17 import copy
18 import functools
19 import re
20 import time
21 
22 from keystoneauth1 import exceptions as ks_exc
23 import os_traits
24 from oslo_log import log as logging
25 from oslo_middleware import request_id
26 from oslo_utils import versionutils
27 from six.moves.urllib import parse
28 
29 from nova.compute import provider_tree
30 from nova.compute import utils as compute_utils
31 import nova.conf
32 from nova import exception
33 from nova.i18n import _
34 from nova import objects
35 from nova import rc_fields as fields
36 from nova.scheduler import utils as scheduler_utils
37 from nova import utils
38 
39 CONF = nova.conf.CONF
40 LOG = logging.getLogger(__name__)
41 VCPU = fields.ResourceClass.VCPU
42 MEMORY_MB = fields.ResourceClass.MEMORY_MB
43 DISK_GB = fields.ResourceClass.DISK_GB
44 _RE_INV_IN_USE = re.compile("Inventory for (.+) on resource provider "
45                             "(.+) in use")
46 WARN_EVERY = 10
47 PLACEMENT_CLIENT_SEMAPHORE = 'placement_client'
48 # Number of seconds between attempts to update a provider's aggregates and
49 # traits
50 ASSOCIATION_REFRESH = 300
51 POST_RPS_RETURNS_PAYLOAD_API_VERSION = '1.20'
52 NESTED_PROVIDER_API_VERSION = '1.14'
53 POST_ALLOCATIONS_API_VERSION = '1.13'
54 
55 
56 def warn_limit(self, msg):
57     if self._warn_count:
58         self._warn_count -= 1
59     else:
60         self._warn_count = WARN_EVERY
61         LOG.warning(msg)
62 
63 
64 def safe_connect(f):
65     @functools.wraps(f)
66     def wrapper(self, *a, **k):
67         try:
68             return f(self, *a, **k)
69         except ks_exc.EndpointNotFound:
70             warn_limit(
71                 self, 'The placement API endpoint was not found.')
72             # Reset client session so there is a new catalog, which
73             # gets cached when keystone is first successfully contacted.
74             self._client = self._create_client()
75         except ks_exc.MissingAuthPlugin:
76             warn_limit(
77                 self, 'No authentication information found for placement API.')
78         except ks_exc.Unauthorized:
79             warn_limit(
80                 self, 'Placement service credentials do not work.')
81         except ks_exc.DiscoveryFailure:
82             # TODO(_gryf): Looks like DiscoveryFailure is not the only missing
83             # exception here. In Pike we should take care about keystoneauth1
84             # failures handling globally.
85             warn_limit(self,
86                        'Discovering suitable URL for placement API failed.')
87         except ks_exc.ConnectFailure:
88             LOG.warning('Placement API service is not responding.')
89     return wrapper
90 
91 
92 class Retry(Exception):
93     def __init__(self, operation, reason):
94         self.operation = operation
95         self.reason = reason
96 
97 
98 def retries(f):
99     """Decorator to retry a call three times if it raises Retry
100 
101     Note that this returns the actual value of the inner call on success
102     or returns False if all the retries fail.
103     """
104     @functools.wraps(f)
105     def wrapper(self, *a, **k):
106         for retry in range(0, 3):
107             try:
108                 return f(self, *a, **k)
109             except Retry as e:
110                 LOG.debug(
111                     'Unable to %(op)s because %(reason)s; retrying...',
112                     {'op': e.operation, 'reason': e.reason})
113         LOG.error('Failed scheduler client operation %s: out of retries',
114                   f.__name__)
115         return False
116     return wrapper
117 
118 
119 def _compute_node_to_inventory_dict(compute_node):
120     """Given a supplied `objects.ComputeNode` object, return a dict, keyed
121     by resource class, of various inventory information.
122 
123     :param compute_node: `objects.ComputeNode` object to translate
124     """
125     result = {}
126 
127     # NOTE(jaypipes): Ironic virt driver will return 0 values for vcpus,
128     # memory_mb and disk_gb if the Ironic node is not available/operable
129     if compute_node.vcpus > 0:
130         result[VCPU] = {
131             'total': compute_node.vcpus,
132             'reserved': CONF.reserved_host_cpus,
133             'min_unit': 1,
134             'max_unit': compute_node.vcpus,
135             'step_size': 1,
136             'allocation_ratio': compute_node.cpu_allocation_ratio,
137         }
138     if compute_node.memory_mb > 0:
139         result[MEMORY_MB] = {
140             'total': compute_node.memory_mb,
141             'reserved': CONF.reserved_host_memory_mb,
142             'min_unit': 1,
143             'max_unit': compute_node.memory_mb,
144             'step_size': 1,
145             'allocation_ratio': compute_node.ram_allocation_ratio,
146         }
147     if compute_node.local_gb > 0:
148         # TODO(johngarbutt) We should either move to reserved_host_disk_gb
149         # or start tracking DISK_MB.
150         reserved_disk_gb = compute_utils.convert_mb_to_ceil_gb(
151             CONF.reserved_host_disk_mb)
152         result[DISK_GB] = {
153             'total': compute_node.local_gb,
154             'reserved': reserved_disk_gb,
155             'min_unit': 1,
156             'max_unit': compute_node.local_gb,
157             'step_size': 1,
158             'allocation_ratio': compute_node.disk_allocation_ratio,
159         }
160     return result
161 
162 
163 def _instance_to_allocations_dict(instance):
164     """Given an `objects.Instance` object, return a dict, keyed by resource
165     class of the amount used by the instance.
166 
167     :param instance: `objects.Instance` object to translate
168     """
169     alloc_dict = scheduler_utils.resources_from_flavor(instance,
170         instance.flavor)
171 
172     # Remove any zero allocations.
173     return {key: val for key, val in alloc_dict.items() if val}
174 
175 
176 def _move_operation_alloc_request(source_allocs, dest_alloc_req):
177     """Given existing allocations for a source host and a new allocation
178     request for a destination host, return a new allocation_request that
179     contains resources claimed against both source and destination, accounting
180     for shared providers.
181 
182     Also accounts for a resize to the same host where the source and dest
183     compute node resource providers are going to be the same. In that case
184     we sum the resource allocations for the single provider.
185 
186     :param source_allocs: Dict, keyed by resource provider UUID, of resources
187                           allocated on the source host
188     :param dest_alloc_req: The allocation_request for resources against the
189                            destination host
190     """
191     LOG.debug("Doubling-up allocation_request for move operation.")
192     # Remove any allocations against resource providers that are
193     # already allocated against on the source host (like shared storage
194     # providers)
195     cur_rp_uuids = set(source_allocs.keys())
196     new_rp_uuids = set(dest_alloc_req['allocations']) - cur_rp_uuids
197 
198     current_allocs = {
199         cur_rp_uuid: {'resources': alloc['resources']}
200             for cur_rp_uuid, alloc in source_allocs.items()
201     }
202     new_alloc_req = {'allocations': current_allocs}
203     for rp_uuid in dest_alloc_req['allocations']:
204         if rp_uuid in new_rp_uuids:
205             new_alloc_req['allocations'][rp_uuid] = dest_alloc_req[
206                 'allocations'][rp_uuid]
207         elif not new_rp_uuids:
208             # If there are no new_rp_uuids that means we're resizing to
209             # the same host so we need to sum the allocations for
210             # the compute node (and possibly shared providers) using both
211             # the current and new allocations.
212             # Note that we sum the allocations rather than take the max per
213             # resource class between the current and new allocations because
214             # the compute node/resource tracker is going to adjust for
215             # decrementing any old allocations as necessary, the scheduler
216             # shouldn't make assumptions about that.
217             scheduler_utils.merge_resources(
218                 new_alloc_req['allocations'][rp_uuid]['resources'],
219                 dest_alloc_req['allocations'][rp_uuid]['resources'])
220 
221     LOG.debug("New allocation_request containing both source and "
222               "destination hosts in move operation: %s", new_alloc_req)
223     return new_alloc_req
224 
225 
226 def _extract_inventory_in_use(body):
227     """Given an HTTP response body, extract the resource classes that were
228     still in use when we tried to delete inventory.
229 
230     :returns: String of resource classes or None if there was no InventoryInUse
231               error in the response body.
232     """
233     match = _RE_INV_IN_USE.search(body)
234     if match:
235         return match.group(1)
236     return None
237 
238 
239 def get_placement_request_id(response):
240     if response is not None:
241         return response.headers.get(request_id.HTTP_RESP_HEADER_REQUEST_ID)
242 
243 
244 class SchedulerReportClient(object):
245     """Client class for updating the scheduler."""
246 
247     def __init__(self):
248         # An object that contains a nova-compute-side cache of resource
249         # provider and inventory information
250         self._provider_tree = provider_tree.ProviderTree()
251         # Track the last time we updated providers' aggregates and traits
252         self._association_refresh_time = {}
253         self._client = self._create_client()
254         # NOTE(danms): Keep track of how naggy we've been
255         self._warn_count = 0
256 
257     @utils.synchronized(PLACEMENT_CLIENT_SEMAPHORE)
258     def _create_client(self):
259         """Create the HTTP session accessing the placement service."""
260         # Flush provider tree and associations so we start from a clean slate.
261         self._provider_tree = provider_tree.ProviderTree()
262         self._association_refresh_time = {}
263         client = utils.get_ksa_adapter('placement')
264         # Set accept header on every request to ensure we notify placement
265         # service of our response body media type preferences.
266         client.additional_headers = {'accept': 'application/json'}
267         return client
268 
269     def get(self, url, version=None, global_request_id=None):
270         headers = ({request_id.INBOUND_HEADER: global_request_id}
271                    if global_request_id else {})
272         return self._client.get(url, raise_exc=False, microversion=version,
273                                 headers=headers)
274 
275     def post(self, url, data, version=None, global_request_id=None):
276         headers = ({request_id.INBOUND_HEADER: global_request_id}
277                    if global_request_id else {})
278         # NOTE(sdague): using json= instead of data= sets the
279         # media type to application/json for us. Placement API is
280         # more sensitive to this than other APIs in the OpenStack
281         # ecosystem.
282         return self._client.post(url, json=data, raise_exc=False,
283                                  microversion=version, headers=headers)
284 
285     def put(self, url, data, version=None, global_request_id=None):
286         # NOTE(sdague): using json= instead of data= sets the
287         # media type to application/json for us. Placement API is
288         # more sensitive to this than other APIs in the OpenStack
289         # ecosystem.
290         kwargs = {'microversion': version,
291                   'headers': {request_id.INBOUND_HEADER:
292                               global_request_id} if global_request_id else {}}
293         if data is not None:
294             kwargs['json'] = data
295         return self._client.put(url, raise_exc=False, **kwargs)
296 
297     def delete(self, url, version=None, global_request_id=None):
298         headers = ({request_id.INBOUND_HEADER: global_request_id}
299                    if global_request_id else {})
300         return self._client.delete(url, raise_exc=False, microversion=version,
301                                    headers=headers)
302 
303     @safe_connect
304     def get_allocation_candidates(self, context, resources):
305         """Returns a tuple of (allocation_requests, provider_summaries,
306         allocation_request_version).
307 
308         The allocation_requests are a collection of potential JSON objects that
309         can be passed to the PUT /allocations/{consumer_uuid} Placement REST
310         API to claim resources against one or more resource providers that meet
311         the requested resource constraints.
312 
313         The provider summaries is a dict, keyed by resource provider UUID, of
314         inventory and capacity information and traits for any resource
315         provider involved in the allocation_requests.
316 
317         :returns: A tuple with a list of allocation_request dicts, a dict of
318                   provider information, and the microversion used to request
319                   this data from placement, or (None, None, None) if the
320                   request failed
321 
322         :param context: The security context
323         :param nova.scheduler.utils.ResourceRequest resources:
324             A ResourceRequest object representing the requested resources,
325             traits, and aggregates from the request spec.
326 
327         Example member_of (aggregates) value in resources:
328 
329             [('foo', 'bar'), ('baz',)]
330 
331         translates to:
332 
333             "Candidates are in either 'foo' or 'bar', but definitely in 'baz'"
334 
335         """
336         # TODO(efried): For now, just use the unnumbered group to retain
337         # existing behavior.  Once the GET /allocation_candidates API is
338         # prepped to accept the whole shebang, we'll join up all the resources
339         # and traits in the query string (via a new method on ResourceRequest).
340         res = resources.get_request_group(None).resources
341         required_traits = resources.get_request_group(None).required_traits
342         forbidden_traits = resources.get_request_group(None).forbidden_traits
343         aggregates = resources.get_request_group(None).member_of
344 
345         resource_query = ",".join(
346             sorted("%s:%s" % (rc, amount)
347             for (rc, amount) in res.items()))
348         qs_params = {
349             'resources': resource_query,
350             'limit': CONF.scheduler.max_placement_results,
351         }
352         if required_traits:
353             qs_params['required'] = ",".join(required_traits)
354         if forbidden_traits:
355             # Sorted to make testing easier to manage and for
356             # predictability.
357             forbiddens = ',!'.join(sorted(forbidden_traits))
358             if qs_params['required']:
359                 qs_params['required'] += ',!' + forbiddens
360             else:
361                 qs_params['required'] = '!' + forbiddens
362         if aggregates:
363             # NOTE(danms): In 1.21, placement cannot take an AND'd
364             # set of aggregates, only an OR'd set. Thus, if we have
365             # required and optional sets, we must do the naive thing
366             # and AND ours together. That will not achieve the same
367             # result, but we can't do it from the client side. When
368             # placement supports AND'ing multiple sets, we can fix this.
369             # TODO(danms): Update this when placement can take multiple
370             # member_of query parameters.
371             required_agg = set.intersection(*[set(x) for x in aggregates])
372             qs_params['member_of'] = 'in:' + ','.join(sorted(required_agg))
373 
374         version = '1.21'
375         url = "/allocation_candidates?%s" % parse.urlencode(qs_params)
376         resp = self.get(url, version=version,
377                         global_request_id=context.global_id)
378         if resp.status_code == 200:
379             data = resp.json()
380             return (data['allocation_requests'], data['provider_summaries'],
381                     version)
382 
383         args = {
384             'resources': res,
385             'status_code': resp.status_code,
386             'err_text': resp.text,
387         }
388         msg = ("Failed to retrieve allocation candidates from placement "
389                "API for filters %(resources)s, traits %(traits)s, "
390                "aggregates %(aggregates)s. Got "
391                "%(status_code)d: %(err_text)s.")
392         args['traits'] = qs_params.get('required', '(none)')
393         args['aggregates'] = qs_params.get('aggregates', '(none)')
394         LOG.error(msg, args)
395         return None, None, None
396 
397     @safe_connect
398     def _get_provider_aggregates(self, context, rp_uuid):
399         """Queries the placement API for a resource provider's aggregates.
400 
401         :param rp_uuid: UUID of the resource provider to grab aggregates for.
402         :return: A set() of aggregate UUIDs, which may be empty if the
403                  specified provider has no aggregate associations.
404         :raise: ResourceProviderAggregateRetrievalFailed on errors.  In
405                 particular, we raise this exception (as opposed to returning
406                 None or the empty set()) if the specified resource provider
407                 does not exist.
408         """
409         resp = self.get("/resource_providers/%s/aggregates" % rp_uuid,
410                         version='1.1', global_request_id=context.global_id)
411         if resp.status_code == 200:
412             data = resp.json()
413             return set(data['aggregates'])
414 
415         placement_req_id = get_placement_request_id(resp)
416         msg = ("[%(placement_req_id)s] Failed to retrieve aggregates from "
417                "placement API for resource provider with UUID %(uuid)s. "
418                "Got %(status_code)d: %(err_text)s.")
419         args = {
420             'placement_req_id': placement_req_id,
421             'uuid': rp_uuid,
422             'status_code': resp.status_code,
423             'err_text': resp.text,
424         }
425         LOG.error(msg, args)
426         raise exception.ResourceProviderAggregateRetrievalFailed(uuid=rp_uuid)
427 
428     @safe_connect
429     def _get_provider_traits(self, context, rp_uuid):
430         """Queries the placement API for a resource provider's traits.
431 
432         :param context: The security context
433         :param rp_uuid: UUID of the resource provider to grab traits for.
434         :return: A set() of string trait names, which may be empty if the
435                  specified provider has no traits.
436         :raise: ResourceProviderTraitRetrievalFailed on errors.  In particular,
437                 we raise this exception (as opposed to returning None or the
438                 empty set()) if the specified resource provider does not exist.
439         """
440         resp = self.get("/resource_providers/%s/traits" % rp_uuid,
441                         version='1.6', global_request_id=context.global_id)
442 
443         if resp.status_code == 200:
444             return set(resp.json()['traits'])
445 
446         placement_req_id = get_placement_request_id(resp)
447         LOG.error(
448             "[%(placement_req_id)s] Failed to retrieve traits from "
449             "placement API for resource provider with UUID %(uuid)s. Got "
450             "%(status_code)d: %(err_text)s.",
451             {'placement_req_id': placement_req_id, 'uuid': rp_uuid,
452              'status_code': resp.status_code, 'err_text': resp.text})
453         raise exception.ResourceProviderTraitRetrievalFailed(uuid=rp_uuid)
454 
455     @safe_connect
456     def _get_resource_provider(self, context, uuid):
457         """Queries the placement API for a resource provider record with the
458         supplied UUID.
459 
460         :param context: The security context
461         :param uuid: UUID identifier for the resource provider to look up
462         :return: A dict of resource provider information if found or None if no
463                  such resource provider could be found.
464         :raise: ResourceProviderRetrievalFailed on error.
465         """
466         resp = self.get("/resource_providers/%s" % uuid,
467                         version=NESTED_PROVIDER_API_VERSION,
468                         global_request_id=context.global_id)
469         if resp.status_code == 200:
470             data = resp.json()
471             return data
472         elif resp.status_code == 404:
473             return None
474         else:
475             placement_req_id = get_placement_request_id(resp)
476             msg = ("[%(placement_req_id)s] Failed to retrieve resource "
477                    "provider record from placement API for UUID %(uuid)s. Got "
478                    "%(status_code)d: %(err_text)s.")
479             args = {
480                 'uuid': uuid,
481                 'status_code': resp.status_code,
482                 'err_text': resp.text,
483                 'placement_req_id': placement_req_id,
484             }
485             LOG.error(msg, args)
486             raise exception.ResourceProviderRetrievalFailed(uuid=uuid)
487 
488     @safe_connect
489     def _get_sharing_providers(self, context, agg_uuids):
490         """Queries the placement API for a list of the resource providers
491         associated with any of the specified aggregates and possessing the
492         MISC_SHARES_VIA_AGGREGATE trait.
493 
494         :param context: The security context
495         :param agg_uuids: Iterable of string UUIDs of aggregates to filter on.
496         :return: A list of dicts of resource provider information, which may be
497                  empty if no provider exists with the specified UUID.
498         :raise: ResourceProviderRetrievalFailed on error.
499         """
500         if not agg_uuids:
501             return []
502 
503         aggs = ','.join(agg_uuids)
504         url = "/resource_providers?member_of=in:%s&required=%s" % (
505             aggs, os_traits.MISC_SHARES_VIA_AGGREGATE)
506         resp = self.get(url, version='1.18',
507                         global_request_id=context.global_id)
508         if resp.status_code == 200:
509             return resp.json()['resource_providers']
510 
511         msg = _("[%(placement_req_id)s] Failed to retrieve sharing resource "
512                 "providers associated with the following aggregates from "
513                 "placement API: %(aggs)s. Got %(status_code)d: %(err_text)s.")
514         args = {
515             'aggs': aggs,
516             'status_code': resp.status_code,
517             'err_text': resp.text,
518             'placement_req_id': get_placement_request_id(resp),
519         }
520         LOG.error(msg, args)
521         raise exception.ResourceProviderRetrievalFailed(message=msg % args)
522 
523     @safe_connect
524     def _get_providers_in_tree(self, context, uuid):
525         """Queries the placement API for a list of the resource providers in
526         the tree associated with the specified UUID.
527 
528         :param context: The security context
529         :param uuid: UUID identifier for the resource provider to look up
530         :return: A list of dicts of resource provider information, which may be
531                  empty if no provider exists with the specified UUID.
532         :raise: ResourceProviderRetrievalFailed on error.
533         """
534         resp = self.get("/resource_providers?in_tree=%s" % uuid,
535                         version=NESTED_PROVIDER_API_VERSION,
536                         global_request_id=context.global_id)
537 
538         if resp.status_code == 200:
539             return resp.json()['resource_providers']
540 
541         # Some unexpected error
542         placement_req_id = get_placement_request_id(resp)
543         msg = ("[%(placement_req_id)s] Failed to retrieve resource provider "
544                "tree from placement API for UUID %(uuid)s. Got "
545                "%(status_code)d: %(err_text)s.")
546         args = {
547             'uuid': uuid,
548             'status_code': resp.status_code,
549             'err_text': resp.text,
550             'placement_req_id': placement_req_id,
551         }
552         LOG.error(msg, args)
553         raise exception.ResourceProviderRetrievalFailed(uuid=uuid)
554 
555     @safe_connect
556     def _create_resource_provider(self, context, uuid, name,
557                                   parent_provider_uuid=None):
558         """Calls the placement API to create a new resource provider record.
559 
560         :param context: The security context
561         :param uuid: UUID of the new resource provider
562         :param name: Name of the resource provider
563         :param parent_provider_uuid: Optional UUID of the immediate parent
564         :return: A dict of resource provider information object representing
565                  the newly-created resource provider.
566         :raise: ResourceProviderCreationFailed or
567                 ResourceProviderRetrievalFailed on error.
568         """
569         url = "/resource_providers"
570         payload = {
571             'uuid': uuid,
572             'name': name,
573         }
574         if parent_provider_uuid is not None:
575             payload['parent_provider_uuid'] = parent_provider_uuid
576 
577         # Bug #1746075: First try the microversion that returns the new
578         # provider's payload.
579         resp = self.post(url, payload,
580                          version=POST_RPS_RETURNS_PAYLOAD_API_VERSION,
581                          global_request_id=context.global_id)
582 
583         placement_req_id = get_placement_request_id(resp)
584 
585         if resp:
586             msg = ("[%(placement_req_id)s] Created resource provider record "
587                    "via placement API for resource provider with UUID "
588                    "%(uuid)s and name %(name)s.")
589             args = {
590                 'uuid': uuid,
591                 'name': name,
592                 'placement_req_id': placement_req_id,
593             }
594             LOG.info(msg, args)
595             return resp.json()
596 
597         # TODO(efried): Push error codes from placement, and use 'em.
598         name_conflict = 'Conflicting resource provider name:'
599         if resp.status_code == 409 and name_conflict not in resp.text:
600             # Another thread concurrently created a resource provider with the
601             # same UUID. Log a warning and then just return the resource
602             # provider object from _get_resource_provider()
603             msg = ("[%(placement_req_id)s] Another thread already created a "
604                    "resource provider with the UUID %(uuid)s. Grabbing that "
605                    "record from the placement API.")
606             args = {
607                 'uuid': uuid,
608                 'placement_req_id': placement_req_id,
609             }
610             LOG.info(msg, args)
611             return self._get_resource_provider(context, uuid)
612 
613         # A provider with the same *name* already exists, or some other error.
614         msg = ("[%(placement_req_id)s] Failed to create resource provider "
615                "record in placement API for UUID %(uuid)s. Got "
616                "%(status_code)d: %(err_text)s.")
617         args = {
618             'uuid': uuid,
619             'status_code': resp.status_code,
620             'err_text': resp.text,
621             'placement_req_id': placement_req_id,
622         }
623         LOG.error(msg, args)
624         raise exception.ResourceProviderCreationFailed(name=name)
625 
626     def _ensure_resource_provider(self, context, uuid, name=None,
627                                   parent_provider_uuid=None):
628         """Ensures that the placement API has a record of a resource provider
629         with the supplied UUID. If not, creates the resource provider record in
630         the placement API for the supplied UUID, passing in a name for the
631         resource provider.
632 
633         If found or created, the provider's UUID is returned from this method.
634         If the resource provider for the supplied uuid was not found and the
635         resource provider record could not be created in the placement API, an
636         exception is raised.
637 
638         If this method returns successfully, callers are assured that the
639         placement API contains a record of the provider; and that the local
640         cache of resource provider information contains a record of:
641         - The specified provider
642         - All providers in its tree
643         - All providers associated via aggregate with all providers in said
644           tree
645         and for each of those providers:
646         - The UUIDs of its aggregates
647         - The trait strings associated with the provider
648 
649         Note that if the provider did not exist prior to this call, the above
650         reduces to just the specified provider as a root, with no aggregates or
651         traits.
652 
653         :param context: The security context
654         :param uuid: UUID identifier for the resource provider to ensure exists
655         :param name: Optional name for the resource provider if the record
656                      does not exist. If empty, the name is set to the UUID
657                      value
658         :param parent_provider_uuid: Optional UUID of the immediate parent,
659                                      which must have been previously _ensured.
660         """
661         # NOTE(efried): We currently have no code path where we need to set the
662         # parent_provider_uuid on a previously-parent-less provider - so we do
663         # NOT handle that scenario here.
664         # TODO(efried): Reinstate this optimization if possible.
665         # For now, this is removed due to the following:
666         # - update_provider_tree adds a child with some bogus inventory (bad
667         #   resource class) or trait (invalid trait name).
668         # - update_from_provider_tree creates the child in placement and adds
669         #   it to the cache, then attempts to add the bogus inventory/trait.
670         #   The latter fails, so update_from_provider_tree invalidates the
671         #   cache entry by removing the child from the cache.
672         # - Ordinarily, we would rely on the code below (_get_providers_in_tree
673         #   and _provider_tree.populate_from_iterable) to restore the child to
674         #   the cache on the next iteration.  BUT since the root is still
675         #   present in the cache, the commented-out block will cause that part
676         #   of this method to be skipped.
677         # if self._provider_tree.exists(uuid):
678         #     # If we had the requested provider locally, refresh it and its
679         #     # descendants, but only if stale.
680         #     for u in self._provider_tree.get_provider_uuids(uuid):
681         #         self._refresh_associations(context, u, force=False)
682         #     return uuid
683 
684         # We don't have it locally; check placement or create it.
685         created_rp = None
686         rps_to_refresh = self._get_providers_in_tree(context, uuid)
687         if not rps_to_refresh:
688             created_rp = self._create_resource_provider(
689                 context, uuid, name or uuid,
690                 parent_provider_uuid=parent_provider_uuid)
691             # Don't add the created_rp to rps_to_refresh.  Since we just
692             # created it, it has no aggregates or traits.
693 
694         self._provider_tree.populate_from_iterable(
695             rps_to_refresh or [created_rp])
696 
697         # At this point, the whole tree exists in the local cache.
698 
699         for rp_to_refresh in rps_to_refresh:
700             # NOTE(efried): _refresh_associations doesn't refresh inventory
701             # (yet) - see that method's docstring for the why.
702             self._refresh_and_get_inventory(context, rp_to_refresh['uuid'])
703             self._refresh_associations(
704                 context, rp_to_refresh['uuid'],
705                 generation=rp_to_refresh.get('generation'), force=True)
706 
707         return uuid
708 
709     @safe_connect
710     def _delete_provider(self, rp_uuid, global_request_id=None):
711         resp = self.delete('/resource_providers/%s' % rp_uuid,
712                            global_request_id=global_request_id)
713         # Check for 404 since we don't need to warn/raise if we tried to delete
714         # something which doesn"t actually exist.
715         if resp or resp.status_code == 404:
716             if resp:
717                 LOG.info("Deleted resource provider %s", rp_uuid)
718             # clean the caches
719             try:
720                 self._provider_tree.remove(rp_uuid)
721             except ValueError:
722                 pass
723             self._association_refresh_time.pop(rp_uuid, None)
724             return
725 
726         msg = ("[%(placement_req_id)s] Failed to delete resource provider "
727                "with UUID %(uuid)s from the placement API. Got "
728                "%(status_code)d: %(err_text)s.")
729         args = {
730             'placement_req_id': get_placement_request_id(resp),
731             'uuid': rp_uuid,
732             'status_code': resp.status_code,
733             'err_text': resp.text
734         }
735         LOG.error(msg, args)
736         # On conflict, the caller may wish to delete allocations and
737         # redrive.  (Note that this is not the same as a
738         # PlacementAPIConflict case.)
739         if resp.status_code == 409:
740             raise exception.ResourceProviderInUse()
741         raise exception.ResourceProviderDeletionFailed(uuid=rp_uuid)
742 
743     def _get_inventory(self, context, rp_uuid):
744         url = '/resource_providers/%s/inventories' % rp_uuid
745         result = self.get(url, global_request_id=context.global_id)
746         if not result:
747             return None
748         return result.json()
749 
750     def _refresh_and_get_inventory(self, context, rp_uuid):
751         """Helper method that retrieves the current inventory for the supplied
752         resource provider according to the placement API.
753 
754         If the cached generation of the resource provider is not the same as
755         the generation returned from the placement API, we update the cached
756         generation and attempt to update inventory if any exists, otherwise
757         return empty inventories.
758         """
759         curr = self._get_inventory(context, rp_uuid)
760         if curr is None:
761             return None
762 
763         cur_gen = curr['resource_provider_generation']
764         # TODO(efried): This condition banks on the generation for a new RP
765         # starting at zero, which isn't part of the API.  It also is only
766         # useful as an optimization on a freshly-created RP to which nothing
767         # has ever been done.  And it's not much of an optimization, because
768         # updating the cache is super cheap.  We should remove the condition.
769         if cur_gen:
770             curr_inv = curr['inventories']
771             self._provider_tree.update_inventory(rp_uuid, curr_inv,
772                                                  generation=cur_gen)
773         return curr
774 
775     def _refresh_associations(self, context, rp_uuid, generation=None,
776                               force=False, refresh_sharing=True):
777         """Refresh aggregates, traits, and (optionally) aggregate-associated
778         sharing providers for the specified resource provider uuid.
779 
780         Only refresh if there has been no refresh during the lifetime of
781         this process, ASSOCIATION_REFRESH seconds have passed, or the force arg
782         has been set to True.
783 
784         Note that we do *not* refresh inventories.  The reason is largely
785         historical: all code paths that get us here are doing inventory refresh
786         themselves.
787 
788         :param context: The security context
789         :param rp_uuid: UUID of the resource provider to check for fresh
790                         aggregates and traits
791         :param generation: The resource provider generation to set.  If None,
792                            the provider's generation is not updated.
793         :param force: If True, force the refresh
794         :param refresh_sharing: If True, fetch all the providers associated
795                                 by aggregate with the specified provider,
796                                 including their traits and aggregates (but not
797                                 *their* sharing providers).
798         :raise: On various placement API errors, one of:
799                 - ResourceProviderAggregateRetrievalFailed
800                 - ResourceProviderTraitRetrievalFailed
801                 - ResourceProviderRetrievalFailed
802         """
803         if force or self._associations_stale(rp_uuid):
804             # Refresh aggregates
805             aggs = self._get_provider_aggregates(context, rp_uuid)
806             msg = ("Refreshing aggregate associations for resource provider "
807                    "%s, aggregates: %s")
808             LOG.debug(msg, rp_uuid, ','.join(aggs or ['None']))
809 
810             # NOTE(efried): This will blow up if called for a RP that doesn't
811             # exist in our _provider_tree.
812             self._provider_tree.update_aggregates(
813                 rp_uuid, aggs, generation=generation)
814 
815             # Refresh traits
816             traits = self._get_provider_traits(context, rp_uuid)
817             msg = ("Refreshing trait associations for resource provider %s, "
818                    "traits: %s")
819             LOG.debug(msg, rp_uuid, ','.join(traits or ['None']))
820             # NOTE(efried): This will blow up if called for a RP that doesn't
821             # exist in our _provider_tree.
822             self._provider_tree.update_traits(
823                 rp_uuid, traits, generation=generation)
824 
825             if refresh_sharing:
826                 # Refresh providers associated by aggregate
827                 for rp in self._get_sharing_providers(context, aggs):
828                     if not self._provider_tree.exists(rp['uuid']):
829                         # NOTE(efried): Right now sharing providers are always
830                         # treated as roots. This is deliberate. From the
831                         # context of this compute's RP, it doesn't matter if a
832                         # sharing RP is part of a tree.
833                         self._provider_tree.new_root(
834                             rp['name'], rp['uuid'],
835                             generation=rp['generation'])
836                     # Now we have to (populate or) refresh that guy's traits
837                     # and aggregates (but not *his* aggregate-associated
838                     # providers).  No need to override force=True for newly-
839                     # added providers - the missing timestamp will always
840                     # trigger them to refresh.
841                     self._refresh_associations(context, rp['uuid'],
842                                                force=force,
843                                                refresh_sharing=False)
844             self._association_refresh_time[rp_uuid] = time.time()
845 
846     def _associations_stale(self, uuid):
847         """Respond True if aggregates and traits have not been refreshed
848         "recently".
849 
850         Associations are stale if association_refresh_time for this uuid is not
851         set or is more than ASSOCIATION_REFRESH seconds ago.
852         """
853         refresh_time = self._association_refresh_time.get(uuid, 0)
854         return (time.time() - refresh_time) > ASSOCIATION_REFRESH
855 
856     def _update_inventory_attempt(self, context, rp_uuid, inv_data):
857         """Update the inventory for this resource provider if needed.
858 
859         :param context: The security context
860         :param rp_uuid: The resource provider UUID for the operation
861         :param inv_data: The new inventory for the resource provider
862         :returns: True if the inventory was updated (or did not need to be),
863                   False otherwise.
864         """
865         # TODO(jaypipes): Should we really be calling the placement API to get
866         # the current inventory for every resource provider each and every time
867         # update_resource_stats() is called? :(
868         curr = self._refresh_and_get_inventory(context, rp_uuid)
869         if curr is None:
870             return False
871 
872         cur_gen = curr['resource_provider_generation']
873 
874         # Check to see if we need to update placement's view
875         if not self._provider_tree.has_inventory_changed(rp_uuid, inv_data):
876             return True
877 
878         payload = {
879             'resource_provider_generation': cur_gen,
880             'inventories': inv_data,
881         }
882         url = '/resource_providers/%s/inventories' % rp_uuid
883         result = self.put(url, payload, global_request_id=context.global_id)
884         if result.status_code == 409:
885             LOG.info('[%(placement_req_id)s] Inventory update conflict for '
886                      '%(resource_provider_uuid)s with generation ID '
887                      '%(generation)s',
888                      {'placement_req_id': get_placement_request_id(result),
889                       'resource_provider_uuid': rp_uuid,
890                       'generation': cur_gen})
891             # NOTE(jaypipes): There may be cases when we try to set a
892             # provider's inventory that results in attempting to delete an
893             # inventory record for a resource class that has an active
894             # allocation. We need to catch this particular case and raise an
895             # exception here instead of returning False, since we should not
896             # re-try the operation in this case.
897             #
898             # A use case for where this can occur is the following:
899             #
900             # 1) Provider created for each Ironic baremetal node in Newton
901             # 2) Inventory records for baremetal node created for VCPU,
902             #    MEMORY_MB and DISK_GB
903             # 3) A Nova instance consumes the baremetal node and allocation
904             #    records are created for VCPU, MEMORY_MB and DISK_GB matching
905             #    the total amount of those resource on the baremetal node.
906             # 3) Upgrade to Ocata and now resource tracker wants to set the
907             #    provider's inventory to a single record of resource class
908             #    CUSTOM_IRON_SILVER (or whatever the Ironic node's
909             #    "resource_class" attribute is)
910             # 4) Scheduler report client sends the inventory list containing a
911             #    single CUSTOM_IRON_SILVER record and placement service
912             #    attempts to delete the inventory records for VCPU, MEMORY_MB
913             #    and DISK_GB. An exception is raised from the placement service
914             #    because allocation records exist for those resource classes,
915             #    and a 409 Conflict is returned to the compute node. We need to
916             #    trigger a delete of the old allocation records and then set
917             #    the new inventory, and then set the allocation record to the
918             #    new CUSTOM_IRON_SILVER record.
919             rc = _extract_inventory_in_use(result.text)
920             if rc is not None:
921                 raise exception.InventoryInUse(
922                     resource_classes=rc,
923                     resource_provider=rp_uuid,
924                 )
925 
926             # Invalidate our cache and re-fetch the resource provider
927             # to be sure to get the latest generation.
928             self._provider_tree.remove(rp_uuid)
929             # NOTE(jaypipes): We don't need to pass a name parameter to
930             # _ensure_resource_provider() because we know the resource provider
931             # record already exists. We're just reloading the record here.
932             self._ensure_resource_provider(context, rp_uuid)
933             return False
934         elif not result:
935             placement_req_id = get_placement_request_id(result)
936             LOG.warning('[%(placement_req_id)s] Failed to update inventory '
937                         'for resource provider %(uuid)s: %(status)i %(text)s',
938                         {'placement_req_id': placement_req_id,
939                          'uuid': rp_uuid,
940                          'status': result.status_code,
941                          'text': result.text})
942             # log the body at debug level
943             LOG.debug('[%(placement_req_id)s] Failed inventory update request '
944                       'for resource provider %(uuid)s with body: %(payload)s',
945                       {'placement_req_id': placement_req_id,
946                        'uuid': rp_uuid,
947                        'payload': payload})
948             return False
949 
950         if result.status_code != 200:
951             placement_req_id = get_placement_request_id(result)
952             LOG.info('[%(placement_req_id)s] Received unexpected response '
953                      'code %(code)i while trying to update inventory for '
954                      'resource provider %(uuid)s: %(text)s',
955                      {'placement_req_id': placement_req_id,
956                       'uuid': rp_uuid,
957                       'code': result.status_code,
958                       'text': result.text})
959             return False
960 
961         # Update our view of the generation for next time
962         updated_inventories_result = result.json()
963         new_gen = updated_inventories_result['resource_provider_generation']
964 
965         self._provider_tree.update_inventory(rp_uuid, inv_data,
966                                              generation=new_gen)
967         LOG.debug('Updated inventory for %s at generation %i',
968                   rp_uuid, new_gen)
969         return True
970 
971     @safe_connect
972     def _update_inventory(self, context, rp_uuid, inv_data):
973         for attempt in (1, 2, 3):
974             if not self._provider_tree.exists(rp_uuid):
975                 # NOTE(danms): Either we failed to fetch/create the RP
976                 # on our first attempt, or a previous attempt had to
977                 # invalidate the cache, and we were unable to refresh
978                 # it. Bail and try again next time.
979                 LOG.warning('Unable to refresh my resource provider record')
980                 return False
981             if self._update_inventory_attempt(context, rp_uuid, inv_data):
982                 return True
983             time.sleep(1)
984         return False
985 
986     def get_provider_tree_and_ensure_root(self, context, rp_uuid, name=None,
987                                           parent_provider_uuid=None):
988         """Returns a fresh ProviderTree representing all providers which are in
989         the same tree or in the same aggregate as the specified provider,
990         including their aggregates, traits, and inventories.
991 
992         If the specified provider does not exist, it is created with the
993         specified UUID, name, and parent provider (which *must* already exist).
994 
995         :param context: The security context
996         :param rp_uuid: UUID of the resource provider for which to populate the
997                         tree.  (This doesn't need to be the UUID of the root.)
998         :param name: Optional name for the resource provider if the record
999                      does not exist. If empty, the name is set to the UUID
1000                      value
1001         :param parent_provider_uuid: Optional UUID of the immediate parent,
1002                                      which must have been previously _ensured.
1003         :return: A new ProviderTree object.
1004         """
1005         # TODO(efried): We would like to have the caller handle create-and/or-
1006         # cache-if-not-already, but the resource tracker is currently
1007         # structured to handle initialization and update in a single path.  At
1008         # some point this should be refactored, and this method can *just*
1009         # return a deep copy of the local _provider_tree cache.
1010         # (Re)populate the local ProviderTree
1011         self._ensure_resource_provider(
1012             context, rp_uuid, name=name,
1013             parent_provider_uuid=parent_provider_uuid)
1014         # Ensure inventories are up to date (for *all* cached RPs)
1015         for uuid in self._provider_tree.get_provider_uuids():
1016             self._refresh_and_get_inventory(context, uuid)
1017         # Return a *copy* of the tree.
1018         return copy.deepcopy(self._provider_tree)
1019 
1020     def set_inventory_for_provider(self, context, rp_uuid, rp_name, inv_data,
1021                                    parent_provider_uuid=None):
1022         """Given the UUID of a provider, set the inventory records for the
1023         provider to the supplied dict of resources.
1024 
1025         :param context: The security context
1026         :param rp_uuid: UUID of the resource provider to set inventory for
1027         :param rp_name: Name of the resource provider in case we need to create
1028                         a record for it in the placement API
1029         :param inv_data: Dict, keyed by resource class name, of inventory data
1030                          to set against the provider
1031         :param parent_provider_uuid:
1032                 If the provider is not a root, this is required, and represents
1033                 the UUID of the immediate parent, which is a provider for which
1034                 this method has already been invoked.
1035 
1036         :raises: exc.InvalidResourceClass if a supplied custom resource class
1037                  name does not meet the placement API's format requirements.
1038         """
1039         self._ensure_resource_provider(
1040             context, rp_uuid, rp_name,
1041             parent_provider_uuid=parent_provider_uuid)
1042 
1043         # Auto-create custom resource classes coming from a virt driver
1044         self._ensure_resource_classes(context, set(inv_data))
1045 
1046         # NOTE(efried): Do not use the DELETE API introduced in microversion
1047         # 1.5, even if the new inventory is empty.  It provides no way of
1048         # sending the generation down, so no way to trigger/detect a conflict
1049         # if an out-of-band update occurs between when we GET the latest and
1050         # when we invoke the DELETE.  See bug #1746374.
1051         self._update_inventory(context, rp_uuid, inv_data)
1052 
1053     def _set_inventory_for_provider(self, context, rp_uuid, inv_data):
1054         """Given the UUID of a provider, set the inventory records for the
1055         provider to the supplied dict of resources.
1056 
1057         Compare and contrast with set_inventory_for_provider above.  This one
1058         is specially formulated for use by update_from_provider_tree.  Like the
1059         other method, we DO need to _ensure_resource_class - i.e. automatically
1060         create new resource classes specified in the inv_data.  However, UNLIKE
1061         the other method:
1062         - We don't use the DELETE API when inventory is empty, because that guy
1063           doesn't return content, and we need to update the cached provider
1064           tree with the new generation.
1065         - We raise exceptions (rather than returning a boolean) which are
1066           handled in a consistent fashion by update_from_provider_tree.
1067         - We don't invalidate the cache on failure.  That's controlled at a
1068           broader scope (based on errors from ANY of the set_*_for_provider
1069           methods, etc.) by update_from_provider_tree.
1070         - We don't retry.  In this code path, retries happen at the level of
1071           the resource tracker on the next iteration.
1072         - We take advantage of the cache and no-op if inv_data isn't different
1073           from what we have locally.  This is an optimization, not essential.
1074         - We don't _ensure_resource_provider or refresh_and_get_inventory,
1075           because that's already been done in the code paths leading up to
1076           update_from_provider_tree (by get_provider_tree).  This is an
1077           optimization, not essential.
1078 
1079         In short, this version is more in the spirit of set_traits_for_provider
1080         and set_aggregates_for_provider.
1081 
1082         :param context: The security context
1083         :param rp_uuid: The UUID of the provider whose inventory is to be
1084                         updated.
1085         :param inv_data: Dict, keyed by resource class name, of inventory data
1086                          to set for the provider.  Use None or the empty dict
1087                          to remove all inventory for the provider.
1088         :raises: InventoryInUse if inv_data indicates removal of inventory in a
1089                  resource class which has active allocations for this provider.
1090         :raises: InvalidResourceClass if inv_data contains a resource class
1091                  which cannot be created.
1092         :raises: ResourceProviderUpdateConflict if the provider's generation
1093                  doesn't match the generation in the cache.  Callers may choose
1094                  to retrieve the provider and its associations afresh and
1095                  redrive this operation.
1096         :raises: ResourceProviderUpdateFailed on any other placement API
1097                  failure.
1098         """
1099         # TODO(efried): Consolidate/refactor to one set_inventory_for_provider.
1100 
1101         # NOTE(efried): This is here because _ensure_resource_class already has
1102         # @safe_connect, so we don't want to decorate this whole method with it
1103         @safe_connect
1104         def do_put(url, payload):
1105             return self.put(url, payload, global_request_id=context.global_id)
1106 
1107         # If not different from what we've got, short out
1108         if not self._provider_tree.has_inventory_changed(rp_uuid, inv_data):
1109             return
1110 
1111         # Ensure non-standard resource classes exist, creating them if needed.
1112         self._ensure_resource_classes(context, set(inv_data))
1113 
1114         url = '/resource_providers/%s/inventories' % rp_uuid
1115         inv_data = inv_data or {}
1116         generation = self._provider_tree.data(rp_uuid).generation
1117         payload = {
1118             'resource_provider_generation': generation,
1119             'inventories': inv_data,
1120         }
1121         resp = do_put(url, payload)
1122 
1123         if resp.status_code == 200:
1124             json = resp.json()
1125             self._provider_tree.update_inventory(
1126                 rp_uuid, json['inventories'],
1127                 generation=json['resource_provider_generation'])
1128             return
1129 
1130         # Some error occurred; log it
1131         msg = ("[%(placement_req_id)s] Failed to update inventory to "
1132                "[%(inv_data)s] for resource provider with UUID %(uuid)s.  Got "
1133                "%(status_code)d: %(err_text)s")
1134         args = {
1135             'placement_req_id': get_placement_request_id(resp),
1136             'uuid': rp_uuid,
1137             'inv_data': str(inv_data),
1138             'status_code': resp.status_code,
1139             'err_text': resp.text,
1140         }
1141         LOG.error(msg, args)
1142 
1143         if resp.status_code == 409:
1144             # If a conflict attempting to remove inventory in a resource class
1145             # with active allocations, raise InventoryInUse
1146             rc = _extract_inventory_in_use(resp.text)
1147             if rc is not None:
1148                 raise exception.InventoryInUse(
1149                     resource_classes=rc,
1150                     resource_provider=rp_uuid,
1151                 )
1152             # Other conflicts are generation mismatch: raise conflict exception
1153             raise exception.ResourceProviderUpdateConflict(
1154                 uuid=rp_uuid, generation=generation, error=resp.text)
1155 
1156         # Otherwise, raise generic exception
1157         raise exception.ResourceProviderUpdateFailed(url=url, error=resp.text)
1158 
1159     @safe_connect
1160     def _ensure_traits(self, context, traits):
1161         """Make sure all specified traits exist in the placement service.
1162 
1163         :param context: The security context
1164         :param traits: Iterable of trait strings to ensure exist.
1165         :raises: TraitCreationFailed if traits contains a trait that did not
1166                  exist in placement, and couldn't be created.  When this
1167                  exception is raised, it is possible that *some* of the
1168                  requested traits were created.
1169         :raises: TraitRetrievalFailed if the initial query of existing traits
1170                  was unsuccessful.  In this scenario, it is guaranteed that
1171                  no traits were created.
1172         """
1173         if not traits:
1174             return
1175 
1176         # Query for all the requested traits.  Whichever ones we *don't* get
1177         # back, we need to create.
1178         # NOTE(efried): We don't attempt to filter based on our local idea of
1179         # standard traits, which may not be in sync with what the placement
1180         # service knows.  If the caller tries to ensure a nonexistent
1181         # "standard" trait, they deserve the TraitCreationFailed exception
1182         # they'll get.
1183         resp = self.get('/traits?name=in:' + ','.join(traits), version='1.6',
1184                         global_request_id=context.global_id)
1185         if resp.status_code == 200:
1186             traits_to_create = set(traits) - set(resp.json()['traits'])
1187             # Might be neat to have a batch create.  But creating multiple
1188             # traits will generally happen once, at initial startup, if at all.
1189             for trait in traits_to_create:
1190                 resp = self.put('/traits/' + trait, None, version='1.6',
1191                                 global_request_id=context.global_id)
1192                 if not resp:
1193                     raise exception.TraitCreationFailed(name=trait,
1194                                                         error=resp.text)
1195             return
1196 
1197         # The initial GET failed
1198         msg = ("[%(placement_req_id)s] Failed to retrieve the list of traits. "
1199                "Got %(status_code)d: %(err_text)s")
1200         args = {
1201             'placement_req_id': get_placement_request_id(resp),
1202             'status_code': resp.status_code,
1203             'err_text': resp.text,
1204         }
1205         LOG.error(msg, args)
1206         raise exception.TraitRetrievalFailed(error=resp.text)
1207 
1208     @safe_connect
1209     def set_traits_for_provider(self, context, rp_uuid, traits):
1210         """Replace a provider's traits with those specified.
1211 
1212         The provider must exist - this method does not attempt to create it.
1213 
1214         :param context: The security context
1215         :param rp_uuid: The UUID of the provider whose traits are to be updated
1216         :param traits: Iterable of traits to set on the provider
1217         :raises: ResourceProviderUpdateConflict if the provider's generation
1218                  doesn't match the generation in the cache.  Callers may choose
1219                  to retrieve the provider and its associations afresh and
1220                  redrive this operation.
1221         :raises: ResourceProviderUpdateFailed on any other placement API
1222                  failure.
1223         :raises: TraitCreationFailed if traits contains a trait that did not
1224                  exist in placement, and couldn't be created.
1225         :raises: TraitRetrievalFailed if the initial query of existing traits
1226                  was unsuccessful.
1227         """
1228         # If not different from what we've got, short out
1229         if not self._provider_tree.have_traits_changed(rp_uuid, traits):
1230             return
1231 
1232         self._ensure_traits(context, traits)
1233 
1234         url = '/resource_providers/%s/traits' % rp_uuid
1235         # NOTE(efried): Don't use the DELETE API when traits is empty, because
1236         # that guy doesn't return content, and we need to update the cached
1237         # provider tree with the new generation.
1238         traits = list(traits) if traits else []
1239         generation = self._provider_tree.data(rp_uuid).generation
1240         payload = {
1241             'resource_provider_generation': generation,
1242             'traits': traits,
1243         }
1244         resp = self.put(url, payload, version='1.6',
1245                         global_request_id=context.global_id)
1246 
1247         if resp.status_code == 200:
1248             json = resp.json()
1249             self._provider_tree.update_traits(
1250                 rp_uuid, json['traits'],
1251                 generation=json['resource_provider_generation'])
1252             return
1253 
1254         # Some error occurred; log it
1255         msg = ("[%(placement_req_id)s] Failed to update traits to "
1256                "[%(traits)s] for resource provider with UUID %(uuid)s.  Got "
1257                "%(status_code)d: %(err_text)s")
1258         args = {
1259             'placement_req_id': get_placement_request_id(resp),
1260             'uuid': rp_uuid,
1261             'traits': ','.join(traits),
1262             'status_code': resp.status_code,
1263             'err_text': resp.text,
1264         }
1265         LOG.error(msg, args)
1266 
1267         # If a conflict, raise special conflict exception
1268         if resp.status_code == 409:
1269             raise exception.ResourceProviderUpdateConflict(
1270                 uuid=rp_uuid, generation=generation, error=resp.text)
1271 
1272         # Otherwise, raise generic exception
1273         raise exception.ResourceProviderUpdateFailed(url=url, error=resp.text)
1274 
1275     @safe_connect
1276     def set_aggregates_for_provider(self, context, rp_uuid, aggregates,
1277             use_cache=True):
1278         """Replace a provider's aggregates with those specified.
1279 
1280         The provider must exist - this method does not attempt to create it.
1281 
1282         :param context: The security context
1283         :param rp_uuid: The UUID of the provider whose aggregates are to be
1284                         updated.
1285         :param aggregates: Iterable of aggregates to set on the provider.
1286         :param use_cache: If False, indicates not to update the cache of
1287                           resource providers.
1288         :raises: ResourceProviderUpdateFailed on any placement API failure.
1289         """
1290         # TODO(efried): Handle generation conflicts when supported by placement
1291         url = '/resource_providers/%s/aggregates' % rp_uuid
1292         aggregates = list(aggregates) if aggregates else []
1293         resp = self.put(url, aggregates, version='1.1',
1294                         global_request_id=context.global_id)
1295 
1296         if resp.status_code == 200:
1297             placement_aggs = resp.json()['aggregates']
1298             if use_cache:
1299                 self._provider_tree.update_aggregates(rp_uuid, placement_aggs)
1300             return
1301 
1302         # Some error occurred; log it
1303         msg = ("[%(placement_req_id)s] Failed to update aggregates to "
1304                "[%(aggs)s] for resource provider with UUID %(uuid)s.  Got "
1305                "%(status_code)d: %(err_text)s")
1306         args = {
1307             'placement_req_id': get_placement_request_id(resp),
1308             'uuid': rp_uuid,
1309             'aggs': ','.join(aggregates),
1310             'status_code': resp.status_code,
1311             'err_text': resp.text,
1312         }
1313         LOG.error(msg, args)
1314 
1315         raise exception.ResourceProviderUpdateFailed(url=url, error=resp.text)
1316 
1317     @safe_connect
1318     def _ensure_resource_classes(self, context, names):
1319         """Make sure resource classes exist.
1320 
1321         :param context: The security context
1322         :param names: Iterable of string names of the resource classes to
1323                       check/create.  Must not be None.
1324         :raises: exception.InvalidResourceClass if an attempt is made to create
1325                  an invalid resource class.
1326         """
1327         # Placement API version that supports PUT /resource_classes/CUSTOM_*
1328         # to create (or validate the existence of) a consumer-specified
1329         # resource class.
1330         version = '1.7'
1331         to_ensure = set(n for n in names
1332                         if n.startswith(fields.ResourceClass.CUSTOM_NAMESPACE))
1333 
1334         for name in to_ensure:
1335             # no payload on the put request
1336             resp = self.put(
1337                 "/resource_classes/%s" % name, None, version=version,
1338                 global_request_id=context.global_id)
1339             if not resp:
1340                 msg = ("Failed to ensure resource class record with placement "
1341                        "API for resource class %(rc_name)s. Got "
1342                        "%(status_code)d: %(err_text)s.")
1343                 args = {
1344                     'rc_name': name,
1345                     'status_code': resp.status_code,
1346                     'err_text': resp.text,
1347                 }
1348                 LOG.error(msg, args)
1349                 raise exception.InvalidResourceClass(resource_class=name)
1350 
1351     def update_compute_node(self, context, compute_node):
1352         """Creates or updates stats for the supplied compute node.
1353 
1354         :param context: The security context
1355         :param compute_node: updated nova.objects.ComputeNode to report
1356         :raises `exception.InventoryInUse` if the compute node has had changes
1357                 to its inventory but there are still active allocations for
1358                 resource classes that would be deleted by an update to the
1359                 placement API.
1360         """
1361         self._ensure_resource_provider(context, compute_node.uuid,
1362                                        compute_node.hypervisor_hostname)
1363         inv_data = _compute_node_to_inventory_dict(compute_node)
1364         # NOTE(efried): Do not use the DELETE API introduced in microversion
1365         # 1.5, even if the new inventory is empty.  It provides no way of
1366         # sending the generation down, so no way to trigger/detect a conflict
1367         # if an out-of-band update occurs between when we GET the latest and
1368         # when we invoke the DELETE.  See bug #1746374.
1369         self._update_inventory(context, compute_node.uuid, inv_data)
1370 
1371     def update_from_provider_tree(self, context, new_tree):
1372         """Flush changes from a specified ProviderTree back to placement.
1373 
1374         The specified ProviderTree is compared against the local cache.  Any
1375         changes are flushed back to the placement service.  Upon successful
1376         completion, the local cache should reflect the specified ProviderTree.
1377 
1378         This method is best-effort and not atomic.  When exceptions are raised,
1379         it is possible that some of the changes have been flushed back, leaving
1380         the placement database in an inconsistent state.  This should be
1381         recoverable through subsequent calls.
1382 
1383         :param context: The security context
1384         :param new_tree: A ProviderTree instance representing the desired state
1385                          of providers in placement.
1386         :raises: ResourceProviderSyncFailed if any errors were encountered
1387                  attempting to perform the necessary API operations.
1388         """
1389         # NOTE(efried): We currently do not handle the "rename" case.  This is
1390         # where new_tree contains a provider named Y whose UUID already exists
1391         # but is named X.  Today the only way the consumer could accomplish
1392         # this is by deleting the provider and recreating it with the new name.
1393 
1394         @contextlib.contextmanager
1395         def catch_all(rp_uuid):
1396             """Convert all "expected" exceptions from placement API helpers to
1397             True or False.  Saves having to do try/except for every helper call
1398             below.
1399             """
1400             class Status(object):
1401                 success = True
1402             s = Status()
1403             # TODO(efried): Make a base exception class from which all these
1404             # can inherit.
1405             helper_exceptions = (
1406                 exception.InvalidResourceClass,
1407                 exception.InventoryInUse,
1408                 exception.ResourceProviderAggregateRetrievalFailed,
1409                 exception.ResourceProviderDeletionFailed,
1410                 exception.ResourceProviderInUse,
1411                 exception.ResourceProviderRetrievalFailed,
1412                 exception.ResourceProviderTraitRetrievalFailed,
1413                 exception.ResourceProviderUpdateConflict,
1414                 exception.ResourceProviderUpdateFailed,
1415                 exception.TraitCreationFailed,
1416                 exception.TraitRetrievalFailed,
1417             )
1418             try:
1419                 yield s
1420             except helper_exceptions:
1421                 s.success = False
1422                 # Invalidate the caches
1423                 try:
1424                     self._provider_tree.remove(rp_uuid)
1425                 except ValueError:
1426                     pass
1427                 self._association_refresh_time.pop(rp_uuid, None)
1428 
1429         # Overall indicator of success.  Will be set to False on any exception.
1430         success = True
1431 
1432         # Helper methods herein will be updating the local cache (this is
1433         # intentional) so we need to grab up front any data we need to operate
1434         # on in its "original" form.
1435         old_tree = self._provider_tree
1436         old_uuids = old_tree.get_provider_uuids()
1437         new_uuids = new_tree.get_provider_uuids()
1438 
1439         # Do provider deletion first, since it has the best chance of failing
1440         # for non-generation-conflict reasons (i.e. allocations).
1441         uuids_to_remove = set(old_uuids) - set(new_uuids)
1442         # We have to do deletions in bottom-up order, so we don't error
1443         # attempting to delete a parent who still has children.
1444         for uuid in reversed(old_uuids):
1445             if uuid not in uuids_to_remove:
1446                 continue
1447             with catch_all(uuid) as status:
1448                 self._delete_provider(uuid)
1449             success = success and status.success
1450 
1451         # Now create (or load) any "new" providers
1452         uuids_to_add = set(new_uuids) - set(old_uuids)
1453         # We have to do additions in top-down order, so we don't error
1454         # attempting to create a child before its parent exists.
1455         for uuid in new_uuids:
1456             if uuid not in uuids_to_add:
1457                 continue
1458             provider = new_tree.data(uuid)
1459             with catch_all(uuid) as status:
1460                 self._ensure_resource_provider(
1461                     context, uuid, name=provider.name,
1462                     parent_provider_uuid=provider.parent_uuid)
1463             success = success and status.success
1464 
1465         # At this point the local cache should have all the same providers as
1466         # new_tree.  Whether we added them or not, walk through and diff/flush
1467         # inventories, traits, and aggregates as necessary (the helper methods
1468         # are set up to check and short out when the relevant property does not
1469         # differ from what's in the cache).
1470         # If we encounter any error and remove a provider from the cache, all
1471         # its descendants are also removed, and set_*_for_provider methods on
1472         # it wouldn't be able to get started. Walking the tree in bottom-up
1473         # order ensures we at least try to process all of the providers.
1474         for uuid in reversed(new_uuids):
1475             pd = new_tree.data(uuid)
1476             with catch_all(pd.uuid) as status:
1477                 self._set_inventory_for_provider(
1478                     context, pd.uuid, pd.inventory)
1479                 self.set_aggregates_for_provider(
1480                     context, pd.uuid, pd.aggregates)
1481                 self.set_traits_for_provider(context, pd.uuid, pd.traits)
1482             success = success and status.success
1483 
1484         if not success:
1485             raise exception.ResourceProviderSyncFailed()
1486 
1487     @safe_connect
1488     def get_allocations_for_consumer(self, context, consumer):
1489         url = '/allocations/%s' % consumer
1490         resp = self.get(url, global_request_id=context.global_id)
1491         if not resp:
1492             return {}
1493         else:
1494             return resp.json()['allocations']
1495 
1496     def get_allocations_for_consumer_by_provider(self, context, rp_uuid,
1497                                                  consumer):
1498         # NOTE(cdent): This trims to just the allocations being
1499         # used on this resource provider. In the future when there
1500         # are shared resources there might be other providers.
1501         allocations = self.get_allocations_for_consumer(context, consumer)
1502         if allocations is None:
1503             # safe_connect can return None on 404
1504             allocations = {}
1505         return allocations.get(
1506             rp_uuid, {}).get('resources', {})
1507 
1508     def _allocate_for_instance(self, context, rp_uuid, instance):
1509         my_allocations = _instance_to_allocations_dict(instance)
1510         current_allocations = self.get_allocations_for_consumer_by_provider(
1511             context, rp_uuid, instance.uuid)
1512         if current_allocations == my_allocations:
1513             allocstr = ','.join(['%s=%s' % (k, v)
1514                                  for k, v in my_allocations.items()])
1515             LOG.debug('Instance %(uuid)s allocations are unchanged: %(alloc)s',
1516                       {'uuid': instance.uuid, 'alloc': allocstr})
1517             return
1518 
1519         LOG.debug('Sending allocation for instance %s',
1520                   my_allocations,
1521                   instance=instance)
1522         res = self.put_allocations(context, rp_uuid, instance.uuid,
1523                                    my_allocations, instance.project_id,
1524                                    instance.user_id)
1525         if res:
1526             LOG.info('Submitted allocation for instance', instance=instance)
1527 
1528     # NOTE(jaypipes): Currently, this method is ONLY used in two places:
1529     # 1. By the scheduler to allocate resources on the selected destination
1530     #    hosts.
1531     # 2. By the conductor LiveMigrationTask to allocate resources on a forced
1532     #    destination host. This is a short-term fix for Pike which should be
1533     #    replaced in Queens by conductor calling the scheduler in the force
1534     #    host case.
1535     # This method should not be called by the resource tracker; instead, the
1536     # _allocate_for_instance() method is used which does not perform any
1537     # checking that a move operation is in place.
1538     @safe_connect
1539     @retries
1540     def claim_resources(self, context, consumer_uuid, alloc_request,
1541                         project_id, user_id, allocation_request_version=None):
1542         """Creates allocation records for the supplied instance UUID against
1543         the supplied resource providers.
1544 
1545         We check to see if resources have already been claimed for this
1546         consumer. If so, we assume that a move operation is underway and the
1547         scheduler is attempting to claim resources against the new (destination
1548         host). In order to prevent compute nodes currently performing move
1549         operations from being scheduled to improperly, we create a "doubled-up"
1550         allocation that consumes resources on *both* the source and the
1551         destination host during the move operation. When the move operation
1552         completes, the destination host (via _allocate_for_instance()) will
1553         end up setting allocations for the instance only on the destination
1554         host thereby freeing up resources on the source host appropriately.
1555 
1556         :param context: The security context
1557         :param consumer_uuid: The instance's UUID.
1558         :param alloc_request: The JSON body of the request to make to the
1559                               placement's PUT /allocations API
1560         :param project_id: The project_id associated with the allocations.
1561         :param user_id: The user_id associated with the allocations.
1562         :param allocation_request_version: The microversion used to request the
1563                                            allocations.
1564         :returns: True if the allocations were created, False otherwise.
1565         """
1566         # Older clients might not send the allocation_request_version, so
1567         # default to 1.10.
1568         # TODO(alex_xu): In the rocky, all the client should send the
1569         # allocation_request_version. So remove this default value.
1570         allocation_request_version = allocation_request_version or '1.10'
1571         # Ensure we don't change the supplied alloc request since it's used in
1572         # a loop within the scheduler against multiple instance claims
1573         ar = copy.deepcopy(alloc_request)
1574 
1575         # If the allocation_request_version less than 1.12, then convert the
1576         # allocation array format to the dict format. This conversion can be
1577         # remove in Rocky release.
1578         if versionutils.convert_version_to_tuple(
1579                 allocation_request_version) < (1, 12):
1580             ar = {
1581                 'allocations': {
1582                     alloc['resource_provider']['uuid']: {
1583                         'resources': alloc['resources']
1584                     } for alloc in ar['allocations']
1585                 }
1586             }
1587             allocation_request_version = '1.12'
1588 
1589         url = '/allocations/%s' % consumer_uuid
1590 
1591         payload = ar
1592 
1593         # We first need to determine if this is a move operation and if so
1594         # create the "doubled-up" allocation that exists for the duration of
1595         # the move operation against both the source and destination hosts
1596         r = self.get(url, global_request_id=context.global_id)
1597         if r.status_code == 200:
1598             current_allocs = r.json()['allocations']
1599             if current_allocs:
1600                 payload = _move_operation_alloc_request(current_allocs, ar)
1601 
1602         payload['project_id'] = project_id
1603         payload['user_id'] = user_id
1604         r = self.put(url, payload, version=allocation_request_version,
1605                      global_request_id=context.global_id)
1606         if r.status_code != 204:
1607             # NOTE(jaypipes): Yes, it sucks doing string comparison like this
1608             # but we have no error codes, only error messages.
1609             if 'concurrently updated' in r.text:
1610                 reason = ('another process changed the resource providers '
1611                           'involved in our attempt to put allocations for '
1612                           'consumer %s' % consumer_uuid)
1613                 raise Retry('claim_resources', reason)
1614             else:
1615                 LOG.warning(
1616                     'Unable to submit allocation for instance '
1617                     '%(uuid)s (%(code)i %(text)s)',
1618                     {'uuid': consumer_uuid,
1619                      'code': r.status_code,
1620                      'text': r.text})
1621         return r.status_code == 204
1622 
1623     @safe_connect
1624     def remove_provider_from_instance_allocation(self, context, consumer_uuid,
1625                                                  rp_uuid, user_id, project_id,
1626                                                  resources):
1627         """Grabs an allocation for a particular consumer UUID, strips parts of
1628         the allocation that refer to a supplied resource provider UUID, and
1629         then PUTs the resulting allocation back to the placement API for the
1630         consumer.
1631 
1632         This is used to reconcile the "doubled-up" allocation that the
1633         scheduler constructs when claiming resources against the destination
1634         host during a move operation.
1635 
1636         If the move was between hosts, the entire allocation for rp_uuid will
1637         be dropped. If the move is a resize on the same host, then we will
1638         subtract resources from the single allocation to ensure we do not
1639         exceed the reserved or max_unit amounts for the resource on the host.
1640 
1641         :param context: The security context
1642         :param consumer_uuid: The instance/consumer UUID
1643         :param rp_uuid: The UUID of the provider whose resources we wish to
1644                         remove from the consumer's allocation
1645         :param user_id: The instance's user
1646         :param project_id: The instance's project
1647         :param resources: The resources to be dropped from the allocation
1648         """
1649         url = '/allocations/%s' % consumer_uuid
1650 
1651         # Grab the "doubled-up" allocation that we will manipulate
1652         r = self.get(url, global_request_id=context.global_id)
1653         if r.status_code != 200:
1654             LOG.warning("Failed to retrieve allocations for %s. Got HTTP %s",
1655                         consumer_uuid, r.status_code)
1656             return False
1657 
1658         current_allocs = r.json()['allocations']
1659         if not current_allocs:
1660             LOG.error("Expected to find current allocations for %s, but "
1661                       "found none.", consumer_uuid)
1662             return False
1663 
1664         # If the host isn't in the current allocation for the instance, don't
1665         # do anything
1666         if rp_uuid not in current_allocs:
1667             LOG.warning("Expected to find allocations referencing resource "
1668                         "provider %s for %s, but found none.",
1669                         rp_uuid, consumer_uuid)
1670             return True
1671 
1672         compute_providers = [uuid for uuid, alloc in current_allocs.items()
1673                              if 'VCPU' in alloc['resources']]
1674         LOG.debug('Current allocations for instance: %s', current_allocs,
1675                   instance_uuid=consumer_uuid)
1676         LOG.debug('Instance %s has resources on %i compute nodes',
1677                   consumer_uuid, len(compute_providers))
1678 
1679         new_allocs = [
1680             {
1681                 'resource_provider': {
1682                     'uuid': alloc_rp_uuid,
1683                 },
1684                 'resources': alloc['resources'],
1685             }
1686             for alloc_rp_uuid, alloc in current_allocs.items()
1687             if alloc_rp_uuid != rp_uuid
1688         ]
1689 
1690         if len(compute_providers) == 1:
1691             # NOTE(danms): We are in a resize to same host scenario. Since we
1692             # are the only provider then we need to merge back in the doubled
1693             # allocation with our part subtracted
1694             peer_alloc = {
1695                 'resource_provider': {
1696                     'uuid': rp_uuid,
1697                 },
1698                 'resources': current_allocs[rp_uuid]['resources']
1699             }
1700             LOG.debug('Original resources from same-host '
1701                       'allocation: %s', peer_alloc['resources'])
1702             scheduler_utils.merge_resources(peer_alloc['resources'],
1703                                             resources, -1)
1704             LOG.debug('Subtracting old resources from same-host '
1705                       'allocation: %s', peer_alloc['resources'])
1706             new_allocs.append(peer_alloc)
1707 
1708         payload = {'allocations': new_allocs}
1709         payload['project_id'] = project_id
1710         payload['user_id'] = user_id
1711         LOG.debug("Sending updated allocation %s for instance %s after "
1712                   "removing resources for %s.",
1713                   new_allocs, consumer_uuid, rp_uuid)
1714         r = self.put(url, payload, version='1.10',
1715                      global_request_id=context.global_id)
1716         if r.status_code != 204:
1717             LOG.warning("Failed to save allocation for %s. Got HTTP %s: %s",
1718                         consumer_uuid, r.status_code, r.text)
1719         return r.status_code == 204
1720 
1721     @safe_connect
1722     @retries
1723     def set_and_clear_allocations(self, context, rp_uuid, consumer_uuid,
1724                                   alloc_data, project_id, user_id,
1725                                   consumer_to_clear=None):
1726         """Create allocation records for the supplied consumer UUID while
1727         simultaneously clearing any allocations identified by the uuid
1728         in consumer_to_clear, for example a migration uuid when moving an
1729         instance to another host. This is for atomically managing so-called
1730         "doubled" migration records.
1731 
1732         :note Currently we only allocate against a single resource provider.
1733               Once shared storage and things like NUMA allocations are a
1734               reality, this will change to allocate against multiple providers.
1735 
1736         :param context: The security context
1737         :param rp_uuid: The UUID of the resource provider to allocate against.
1738         :param consumer_uuid: The consumer UUID for which allocations are
1739                               being set.
1740         :param alloc_data: Dict, keyed by resource class, of amounts to
1741                            consume.
1742         :param project_id: The project_id associated with the allocations.
1743         :param user_id: The user_id associated with the allocations.
1744         :param consumer_to_clear: A UUID identifying allocations for a
1745                                   consumer that should be cleared.
1746         :returns: True if the allocations were created, False otherwise.
1747         :raises: Retry if the operation should be retried due to a concurrent
1748                  update.
1749         """
1750         # FIXME(cdent): Fair amount of duplicate with put in here, but now
1751         # just working things through.
1752         payload = {
1753             consumer_uuid: {
1754                 'allocations': {
1755                     rp_uuid: {
1756                         'resources': alloc_data
1757                     }
1758                 },
1759                 'project_id': project_id,
1760                 'user_id': user_id,
1761             }
1762         }
1763         if consumer_to_clear:
1764             payload[consumer_to_clear] = {
1765                 'allocations': {},
1766                 'project_id': project_id,
1767                 'user_id': user_id,
1768             }
1769         r = self.post('/allocations', payload,
1770                       version=POST_ALLOCATIONS_API_VERSION,
1771                       global_request_id=context.global_id)
1772         if r.status_code != 204:
1773             # NOTE(jaypipes): Yes, it sucks doing string comparison like this
1774             # but we have no error codes, only error messages.
1775             if 'concurrently updated' in r.text:
1776                 reason = ('another process changed the resource providers '
1777                           'involved in our attempt to post allocations for '
1778                           'consumer %s' % consumer_uuid)
1779                 raise Retry('set_and_clear_allocations', reason)
1780             else:
1781                 LOG.warning(
1782                     'Unable to post allocations for instance '
1783                     '%(uuid)s (%(code)i %(text)s)',
1784                     {'uuid': consumer_uuid,
1785                      'code': r.status_code,
1786                      'text': r.text})
1787         return r.status_code == 204
1788 
1789     @safe_connect
1790     @retries
1791     def put_allocations(self, context, rp_uuid, consumer_uuid, alloc_data,
1792                         project_id, user_id):
1793         """Creates allocation records for the supplied instance UUID against
1794         the supplied resource provider.
1795 
1796         :note Currently we only allocate against a single resource provider.
1797               Once shared storage and things like NUMA allocations are a
1798               reality, this will change to allocate against multiple providers.
1799 
1800         :param context: The security context
1801         :param rp_uuid: The UUID of the resource provider to allocate against.
1802         :param consumer_uuid: The instance's UUID.
1803         :param alloc_data: Dict, keyed by resource class, of amounts to
1804                            consume.
1805         :param project_id: The project_id associated with the allocations.
1806         :param user_id: The user_id associated with the allocations.
1807         :returns: True if the allocations were created, False otherwise.
1808         :raises: Retry if the operation should be retried due to a concurrent
1809                  update.
1810         """
1811         payload = {
1812             'allocations': [
1813                 {
1814                     'resource_provider': {
1815                         'uuid': rp_uuid,
1816                     },
1817                     'resources': alloc_data,
1818                 },
1819             ],
1820             'project_id': project_id,
1821             'user_id': user_id,
1822         }
1823         url = '/allocations/%s' % consumer_uuid
1824         r = self.put(url, payload, version='1.8',
1825                      global_request_id=context.global_id)
1826         if r.status_code != 204:
1827             # NOTE(jaypipes): Yes, it sucks doing string comparison like this
1828             # but we have no error codes, only error messages.
1829             if 'concurrently updated' in r.text:
1830                 reason = ('another process changed the resource providers '
1831                           'involved in our attempt to put allocations for '
1832                           'consumer %s' % consumer_uuid)
1833                 raise Retry('put_allocations', reason)
1834             else:
1835                 LOG.warning(
1836                     'Unable to submit allocation for instance '
1837                     '%(uuid)s (%(code)i %(text)s)',
1838                     {'uuid': consumer_uuid,
1839                      'code': r.status_code,
1840                      'text': r.text})
1841         return r.status_code == 204
1842 
1843     @safe_connect
1844     def delete_allocation_for_instance(self, context, uuid):
1845         url = '/allocations/%s' % uuid
1846         r = self.delete(url, global_request_id=context.global_id)
1847         if r:
1848             LOG.info('Deleted allocation for instance %s', uuid)
1849             return True
1850         else:
1851             # Check for 404 since we don't need to log a warning if we tried to
1852             # delete something which doesn't actually exist.
1853             if r.status_code != 404:
1854                 LOG.warning('Unable to delete allocation for instance '
1855                             '%(uuid)s: (%(code)i %(text)s)',
1856                             {'uuid': uuid,
1857                              'code': r.status_code,
1858                              'text': r.text})
1859             return False
1860 
1861     def update_instance_allocation(self, context, compute_node, instance,
1862                                    sign):
1863         if sign > 0:
1864             self._allocate_for_instance(context, compute_node.uuid, instance)
1865         else:
1866             self.delete_allocation_for_instance(context, instance.uuid)
1867 
1868     @safe_connect
1869     def get_allocations_for_resource_provider(self, context, rp_uuid):
1870         url = '/resource_providers/%s/allocations' % rp_uuid
1871         resp = self.get(url, global_request_id=context.global_id)
1872         if not resp:
1873             return {}
1874         else:
1875             return resp.json()['allocations']
1876 
1877     def delete_resource_provider(self, context, compute_node, cascade=False):
1878         """Deletes the ResourceProvider record for the compute_node.
1879 
1880         :param context: The security context
1881         :param compute_node: The nova.objects.ComputeNode object that is the
1882                              resource provider being deleted.
1883         :param cascade: Boolean value that, when True, will first delete any
1884                         associated Allocation and Inventory records for the
1885                         compute node
1886         """
1887         nodename = compute_node.hypervisor_hostname
1888         host = compute_node.host
1889         rp_uuid = compute_node.uuid
1890         if cascade:
1891             # Delete any allocations for this resource provider.
1892             # Since allocations are by consumer, we get the consumers on this
1893             # host, which are its instances.
1894             instances = objects.InstanceList.get_by_host_and_node(context,
1895                     host, nodename)
1896             for instance in instances:
1897                 self.delete_allocation_for_instance(context, instance.uuid)
1898         try:
1899             self._delete_provider(rp_uuid, global_request_id=context.global_id)
1900         except (exception.ResourceProviderInUse,
1901                 exception.ResourceProviderDeletionFailed):
1902             # TODO(efried): Raise these.  Right now this is being left a no-op
1903             # for backward compatibility.
1904             pass
1905 
1906     @safe_connect
1907     def _get_provider_by_name(self, context, name):
1908         """Queries the placement API for resource provider information matching
1909         a supplied name.
1910 
1911         :param context: The security context
1912         :param name: Name of the resource provider to look up
1913         :return: A dict of resource provider information including the
1914                  provider's UUID and generation
1915         :raises: `exception.ResourceProviderNotFound` when no such provider was
1916                  found
1917         """
1918         resp = self.get("/resource_providers?name=%s" % name,
1919                         global_request_id=context.global_id)
1920         if resp.status_code == 200:
1921             data = resp.json()
1922             if len(data['resource_providers']) == 1:
1923                 return data['resource_providers'][0]
1924 
1925         raise exception.ResourceProviderNotFound(name_or_uuid=name)
1926 
1927     def aggregate_add_host(self, context, agg_uuid, host_name):
1928         """Looks up a resource provider by the supplied host name, and adds the
1929         aggregate with supplied UUID to that resource provider.
1930 
1931         :note: This method does NOT use the cached provider tree. It is only
1932                called from the Compute API when a nova host aggregate is
1933                modified
1934 
1935         :param context: The security context
1936         :param agg_uuid: UUID of the aggregate being modified
1937         :param host_name: Name of the nova-compute service worker to look up a
1938                           resource provider for
1939         :raises: `exceptions.ResourceProviderNotFound` if no resource provider
1940                   matching the host name could be found from the placement API
1941         :raises: `exception.ResourceProviderAggregateRetrievalFailed` when
1942                  failing to get a provider's existing aggregates
1943         :raises: `exception.ResourceProviderUpdateFailed` if there was a
1944                  failure attempting to save the provider aggregates
1945         """
1946         rp = self._get_provider_by_name(context, host_name)
1947         rp_uuid = rp['uuid']
1948 
1949         # Now attempt to add the aggregate to the resource provider. We don't
1950         # want to overwrite any other aggregates the provider may be associated
1951         # with, however, so we first grab the list of aggregates for this
1952         # provider and add the aggregate to the list of aggregates it already
1953         # has
1954         existing_aggs = self._get_provider_aggregates(context, rp_uuid)
1955         if agg_uuid in existing_aggs:
1956             return
1957 
1958         new_aggs = existing_aggs | set([agg_uuid])
1959         self.set_aggregates_for_provider(
1960             context, rp_uuid, new_aggs, use_cache=False)
1961 
1962     def aggregate_remove_host(self, context, agg_uuid, host_name):
1963         """Looks up a resource provider by the supplied host name, and removes
1964         the aggregate with supplied UUID from that resource provider.
1965 
1966         :note: This method does NOT use the cached provider tree. It is only
1967                called from the Compute API when a nova host aggregate is
1968                modified
1969 
1970         :param context: The security context
1971         :param agg_uuid: UUID of the aggregate being modified
1972         :param host_name: Name of the nova-compute service worker to look up a
1973                           resource provider for
1974         :raises: `exceptions.ResourceProviderNotFound` if no resource provider
1975                   matching the host name could be found from the placement API
1976         :raises: `exception.ResourceProviderAggregateRetrievalFailed` when
1977                  failing to get a provider's existing aggregates
1978         :raises: `exception.ResourceProviderUpdateFailed` if there was a
1979                  failure attempting to save the provider aggregates
1980         """
1981         rp = self._get_provider_by_name(context, host_name)
1982         rp_uuid = rp['uuid']
1983 
1984         # Now attempt to add the aggregate to the resource provider. We don't
1985         # want to overwrite any other aggregates the provider may be associated
1986         # with, however, so we first grab the list of aggregates for this
1987         # provider and remove the aggregate from the list of aggregates it
1988         # already has
1989         existing_aggs = self._get_provider_aggregates(context, rp_uuid)
1990         if agg_uuid not in existing_aggs:
1991             return
1992 
1993         new_aggs = existing_aggs - set([agg_uuid])
1994         self.set_aggregates_for_provider(
1995             context, rp_uuid, new_aggs, use_cache=False)
