Please review the code below to detect security defects. If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are found, please state '''No security defects are detected in the code'''.

1 # Copyright 2011 Justin Santa Barbara
2 # All Rights Reserved.
3 #
4 #    Licensed under the Apache License, Version 2.0 (the "License"); you may
5 #    not use this file except in compliance with the License. You may obtain
6 #    a copy of the License at
7 #
8 #         http://www.apache.org/licenses/LICENSE-2.0
9 #
10 #    Unless required by applicable law or agreed to in writing, software
11 #    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
12 #    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
13 #    License for the specific language governing permissions and limitations
14 #    under the License.
15 
16 """
17 Driver base-classes:
18 
19     (Beginning of) the contract that compute drivers must follow, and shared
20     types that support that contract
21 """
22 
23 import sys
24 
25 from oslo_log import log as logging
26 from oslo_utils import importutils
27 import six
28 
29 import nova.conf
30 from nova.i18n import _
31 from nova.virt import event as virtevent
32 
33 CONF = nova.conf.CONF
34 LOG = logging.getLogger(__name__)
35 
36 
37 def get_block_device_info(instance, block_device_mapping):
38     """Converts block device mappings for an instance to driver format.
39 
40     Virt drivers expect block device mapping to be presented in the format
41     of a dict containing the following keys:
42 
43     - root_device_name: device name of the root disk
44     - ephemerals: a (potentially empty) list of DriverEphemeralBlockDevice
45                   instances
46     - swap: An instance of DriverSwapBlockDevice or None
47     - block_device_mapping: a (potentially empty) list of
48                             DriverVolumeBlockDevice or any of it's more
49                             specialized subclasses.
50     """
51     from nova.virt import block_device as virt_block_device
52 
53     block_device_info = {
54         'root_device_name': instance.root_device_name,
55         'ephemerals': virt_block_device.convert_ephemerals(
56             block_device_mapping),
57         'block_device_mapping':
58             virt_block_device.convert_all_volumes(*block_device_mapping)
59     }
60     swap_list = virt_block_device.convert_swap(block_device_mapping)
61     block_device_info['swap'] = virt_block_device.get_swap(swap_list)
62 
63     return block_device_info
64 
65 
66 def block_device_info_get_root_device(block_device_info):
67     block_device_info = block_device_info or {}
68     return block_device_info.get('root_device_name')
69 
70 
71 def block_device_info_get_swap(block_device_info):
72     block_device_info = block_device_info or {}
73     return block_device_info.get('swap') or {'device_name': None,
74                                              'swap_size': 0}
75 
76 
77 def swap_is_usable(swap):
78     return swap and swap['device_name'] and swap['swap_size'] > 0
79 
80 
81 def block_device_info_get_ephemerals(block_device_info):
82     block_device_info = block_device_info or {}
83     ephemerals = block_device_info.get('ephemerals') or []
84     return ephemerals
85 
86 
87 def block_device_info_get_mapping(block_device_info):
88     block_device_info = block_device_info or {}
89     block_device_mapping = block_device_info.get('block_device_mapping') or []
90     return block_device_mapping
91 
92 
93 class ComputeDriver(object):
94     """Base class for compute drivers.
95 
96     The interface to this class talks in terms of 'instances' (Amazon EC2 and
97     internal Nova terminology), by which we mean 'running virtual machine'
98     (XenAPI terminology) or domain (Xen or libvirt terminology).
99 
100     An instance has an ID, which is the identifier chosen by Nova to represent
101     the instance further up the stack.  This is unfortunately also called a
102     'name' elsewhere.  As far as this layer is concerned, 'instance ID' and
103     'instance name' are synonyms.
104 
105     Note that the instance ID or name is not human-readable or
106     customer-controlled -- it's an internal ID chosen by Nova.  At the
107     nova.virt layer, instances do not have human-readable names at all -- such
108     things are only known higher up the stack.
109 
110     Most virtualization platforms will also have their own identity schemes,
111     to uniquely identify a VM or domain.  These IDs must stay internal to the
112     platform-specific layer, and never escape the connection interface.  The
113     platform-specific layer is responsible for keeping track of which instance
114     ID maps to which platform-specific ID, and vice versa.
115 
116     Some methods here take an instance of nova.compute.service.Instance.  This
117     is the data structure used by nova.compute to store details regarding an
118     instance, and pass them into this layer.  This layer is responsible for
119     translating that generic data structure into terms that are specific to the
120     virtualization platform.
121 
122     """
123 
124     capabilities = {
125         "has_imagecache": False,
126         "supports_recreate": False,
127         "supports_migrate_to_same_host": False,
128         "supports_attach_interface": False,
129         "supports_device_tagging": False,
130         "supports_tagged_attach_interface": False,
131         "supports_tagged_attach_volume": False,
132         "supports_extend_volume": False,
133         "supports_multiattach": False,
134         "supports_trusted_certs": False,
135     }
136 
137     requires_allocation_refresh = False
138 
139     # Indicates if this driver will rebalance nodes among compute service
140     # hosts. This is really here for ironic and should not be used by any
141     # other driver.
142     rebalances_nodes = False
143 
144     def __init__(self, virtapi):
145         self.virtapi = virtapi
146         self._compute_event_callback = None
147 
148     def init_host(self, host):
149         """Initialize anything that is necessary for the driver to function,
150         including catching up with currently running VM's on the given host.
151         """
152         # TODO(Vek): Need to pass context in for access to auth_token
153         raise NotImplementedError()
154 
155     def cleanup_host(self, host):
156         """Clean up anything that is necessary for the driver gracefully stop,
157         including ending remote sessions. This is optional.
158         """
159         pass
160 
161     def get_info(self, instance):
162         """Get the current status of an instance.
163 
164         :param instance: nova.objects.instance.Instance object
165         :returns: An InstanceInfo object
166         """
167         # TODO(Vek): Need to pass context in for access to auth_token
168         raise NotImplementedError()
169 
170     def get_num_instances(self):
171         """Return the total number of virtual machines.
172 
173         Return the number of virtual machines that the hypervisor knows
174         about.
175 
176         .. note::
177 
178             This implementation works for all drivers, but it is
179             not particularly efficient. Maintainers of the virt drivers are
180             encouraged to override this method with something more
181             efficient.
182         """
183         return len(self.list_instances())
184 
185     def instance_exists(self, instance):
186         """Checks existence of an instance on the host.
187 
188         :param instance: The instance to lookup
189 
190         Returns True if an instance with the supplied ID exists on
191         the host, False otherwise.
192 
193         .. note::
194 
195             This implementation works for all drivers, but it is
196             not particularly efficient. Maintainers of the virt drivers are
197             encouraged to override this method with something more
198             efficient.
199         """
200         try:
201             return instance.uuid in self.list_instance_uuids()
202         except NotImplementedError:
203             return instance.name in self.list_instances()
204 
205     def estimate_instance_overhead(self, instance_info):
206         """Estimate the virtualization overhead required to build an instance
207         of the given flavor.
208 
209         Defaults to zero, drivers should override if per-instance overhead
210         calculations are desired.
211 
212         :param instance_info: Instance/flavor to calculate overhead for.
213         :returns: Dict of estimated overhead values.
214         """
215         return {'memory_mb': 0,
216                 'disk_gb': 0,
217                 'vcpus': 0}
218 
219     def list_instances(self):
220         """Return the names of all the instances known to the virtualization
221         layer, as a list.
222         """
223         # TODO(Vek): Need to pass context in for access to auth_token
224         raise NotImplementedError()
225 
226     def list_instance_uuids(self):
227         """Return the UUIDS of all the instances known to the virtualization
228         layer, as a list.
229         """
230         raise NotImplementedError()
231 
232     def rebuild(self, context, instance, image_meta, injected_files,
233                 admin_password, allocations, bdms, detach_block_devices,
234                 attach_block_devices, network_info=None,
235                 recreate=False, block_device_info=None,
236                 preserve_ephemeral=False):
237         """Destroy and re-make this instance.
238 
239         A 'rebuild' effectively purges all existing data from the system and
240         remakes the VM with given 'metadata' and 'personalities'.
241 
242         This base class method shuts down the VM, detaches all block devices,
243         then spins up the new VM afterwards. It may be overridden by
244         hypervisors that need to - e.g. for optimisations, or when the 'VM'
245         is actually proxied and needs to be held across the shutdown + spin
246         up steps.
247 
248         :param context: security context
249         :param instance: nova.objects.instance.Instance
250                          This function should use the data there to guide
251                          the creation of the new instance.
252         :param nova.objects.ImageMeta image_meta:
253             The metadata of the image of the instance.
254         :param injected_files: User files to inject into instance.
255         :param admin_password: Administrator password to set in instance.
256         :param allocations: Information about resources allocated to the
257                             instance via placement, of the form returned by
258                             SchedulerReportClient.get_allocations_for_consumer.
259         :param bdms: block-device-mappings to use for rebuild
260         :param detach_block_devices: function to detach block devices. See
261             nova.compute.manager.ComputeManager:_rebuild_default_impl for
262             usage.
263         :param attach_block_devices: function to attach block devices. See
264             nova.compute.manager.ComputeManager:_rebuild_default_impl for
265             usage.
266         :param network_info: instance network information
267         :param recreate: True if the instance is being recreated on a new
268             hypervisor - all the cleanup of old state is skipped.
269         :param block_device_info: Information about block devices to be
270                                   attached to the instance.
271         :param preserve_ephemeral: True if the default ephemeral storage
272                                    partition must be preserved on rebuild
273         """
274         raise NotImplementedError()
275 
276     def spawn(self, context, instance, image_meta, injected_files,
277               admin_password, allocations, network_info=None,
278               block_device_info=None):
279         """Create a new instance/VM/domain on the virtualization platform.
280 
281         Once this successfully completes, the instance should be
282         running (power_state.RUNNING).
283 
284         If this fails, any partial instance should be completely
285         cleaned up, and the virtualization platform should be in the state
286         that it was before this call began.
287 
288         :param context: security context
289         :param instance: nova.objects.instance.Instance
290                          This function should use the data there to guide
291                          the creation of the new instance.
292         :param nova.objects.ImageMeta image_meta:
293             The metadata of the image of the instance.
294         :param injected_files: User files to inject into instance.
295         :param admin_password: Administrator password to set in instance.
296         :param allocations: Information about resources allocated to the
297                             instance via placement, of the form returned by
298                             SchedulerReportClient.get_allocations_for_consumer.
299         :param network_info: instance network information
300         :param block_device_info: Information about block devices to be
301                                   attached to the instance.
302         """
303         raise NotImplementedError()
304 
305     def destroy(self, context, instance, network_info, block_device_info=None,
306                 destroy_disks=True):
307         """Destroy the specified instance from the Hypervisor.
308 
309         If the instance is not found (for example if networking failed), this
310         function should still succeed.  It's probably a good idea to log a
311         warning in that case.
312 
313         :param context: security context
314         :param instance: Instance object as returned by DB layer.
315         :param network_info: instance network information
316         :param block_device_info: Information about block devices that should
317                                   be detached from the instance.
318         :param destroy_disks: Indicates if disks should be destroyed
319         """
320         raise NotImplementedError()
321 
322     def cleanup(self, context, instance, network_info, block_device_info=None,
323                 destroy_disks=True, migrate_data=None, destroy_vifs=True):
324         """Cleanup the instance resources .
325 
326         Instance should have been destroyed from the Hypervisor before calling
327         this method.
328 
329         :param context: security context
330         :param instance: Instance object as returned by DB layer.
331         :param network_info: instance network information
332         :param block_device_info: Information about block devices that should
333                                   be detached from the instance.
334         :param destroy_disks: Indicates if disks should be destroyed
335         :param migrate_data: implementation specific params
336         """
337         raise NotImplementedError()
338 
339     def reboot(self, context, instance, network_info, reboot_type,
340                block_device_info=None, bad_volumes_callback=None):
341         """Reboot the specified instance.
342 
343         After this is called successfully, the instance's state
344         goes back to power_state.RUNNING. The virtualization
345         platform should ensure that the reboot action has completed
346         successfully even in cases in which the underlying domain/vm
347         is paused or halted/stopped.
348 
349         :param instance: nova.objects.instance.Instance
350         :param network_info: instance network information
351         :param reboot_type: Either a HARD or SOFT reboot
352         :param block_device_info: Info pertaining to attached volumes
353         :param bad_volumes_callback: Function to handle any bad volumes
354             encountered
355         """
356         raise NotImplementedError()
357 
358     def get_console_pool_info(self, console_type):
359         # TODO(Vek): Need to pass context in for access to auth_token
360         raise NotImplementedError()
361 
362     def get_console_output(self, context, instance):
363         """Get console output for an instance
364 
365         :param context: security context
366         :param instance: nova.objects.instance.Instance
367         """
368         raise NotImplementedError()
369 
370     def get_vnc_console(self, context, instance):
371         """Get connection info for a vnc console.
372 
373         :param context: security context
374         :param instance: nova.objects.instance.Instance
375 
376         :returns: an instance of console.type.ConsoleVNC
377         """
378         raise NotImplementedError()
379 
380     def get_spice_console(self, context, instance):
381         """Get connection info for a spice console.
382 
383         :param context: security context
384         :param instance: nova.objects.instance.Instance
385 
386         :returns: an instance of console.type.ConsoleSpice
387         """
388         raise NotImplementedError()
389 
390     def get_rdp_console(self, context, instance):
391         """Get connection info for a rdp console.
392 
393         :param context: security context
394         :param instance: nova.objects.instance.Instance
395 
396         :returns: an instance of console.type.ConsoleRDP
397         """
398         raise NotImplementedError()
399 
400     def get_serial_console(self, context, instance):
401         """Get connection info for a serial console.
402 
403         :param context: security context
404         :param instance: nova.objects.instance.Instance
405 
406         :returns: an instance of console.type.ConsoleSerial
407         """
408         raise NotImplementedError()
409 
410     def get_mks_console(self, context, instance):
411         """Get connection info for a MKS console.
412 
413         :param context: security context
414         :param instance: nova.objects.instance.Instance
415 
416         :returns an instance of console.type.ConsoleMKS
417         """
418         raise NotImplementedError()
419 
420     def get_diagnostics(self, instance):
421         """Return diagnostics data about the given instance.
422 
423         :param nova.objects.instance.Instance instance:
424             The instance to which the diagnostic data should be returned.
425 
426         :return: Has a big overlap to the return value of the newer interface
427             :func:`get_instance_diagnostics`
428         :rtype: dict
429         """
430         # TODO(Vek): Need to pass context in for access to auth_token
431         raise NotImplementedError()
432 
433     def get_instance_diagnostics(self, instance):
434         """Return diagnostics data about the given instance.
435 
436         :param nova.objects.instance.Instance instance:
437             The instance to which the diagnostic data should be returned.
438 
439         :return: Has a big overlap to the return value of the older interface
440             :func:`get_diagnostics`
441         :rtype: nova.virt.diagnostics.Diagnostics
442         """
443         raise NotImplementedError()
444 
445     def get_all_bw_counters(self, instances):
446         """Return bandwidth usage counters for each interface on each
447            running VM.
448 
449         :param instances: nova.objects.instance.InstanceList
450         """
451         raise NotImplementedError()
452 
453     def get_all_volume_usage(self, context, compute_host_bdms):
454         """Return usage info for volumes attached to vms on
455            a given host.-
456         """
457         raise NotImplementedError()
458 
459     def get_host_ip_addr(self):
460         """Retrieves the IP address of the host running compute service
461         """
462         # TODO(Vek): Need to pass context in for access to auth_token
463         raise NotImplementedError()
464 
465     def attach_volume(self, context, connection_info, instance, mountpoint,
466                       disk_bus=None, device_type=None, encryption=None):
467         """Attach the disk to the instance at mountpoint using info."""
468         raise NotImplementedError()
469 
470     def detach_volume(self, context, connection_info, instance, mountpoint,
471                       encryption=None):
472         """Detach the disk attached to the instance."""
473         raise NotImplementedError()
474 
475     def swap_volume(self, context, old_connection_info, new_connection_info,
476                     instance, mountpoint, resize_to):
477         """Replace the volume attached to the given `instance`.
478 
479         :param context: The request context.
480         :param dict old_connection_info:
481             The volume for this connection gets detached from the given
482             `instance`.
483         :param dict new_connection_info:
484             The volume for this connection gets attached to the given
485             'instance'.
486         :param nova.objects.instance.Instance instance:
487             The instance whose volume gets replaced by another one.
488         :param str mountpoint:
489             The mountpoint in the instance where the volume for
490             `old_connection_info` is attached to.
491         :param int resize_to:
492             If the new volume is larger than the old volume, it gets resized
493             to the given size (in Gigabyte) of `resize_to`.
494 
495         :return: None
496         """
497         raise NotImplementedError()
498 
499     def extend_volume(self, connection_info, instance):
500         """Extend the disk attached to the instance.
501 
502         :param dict connection_info:
503             The connection for the extended volume.
504         :param nova.objects.instance.Instance instance:
505             The instance whose volume gets extended.
506 
507         :return: None
508         """
509         raise NotImplementedError()
510 
511     def prepare_networks_before_block_device_mapping(self, instance,
512                                                      network_info):
513         """Prepare networks before the block devices are mapped to instance.
514 
515         Drivers who need network information for block device preparation can
516         do some network preparation necessary for block device preparation.
517 
518         :param nova.objects.instance.Instance instance:
519             The instance whose networks are prepared.
520         :param nova.network.model.NetworkInfoAsyncWrapper network_info:
521             The network information of the given `instance`.
522         """
523         pass
524 
525     def clean_networks_preparation(self, instance, network_info):
526         """Clean networks preparation when block device mapping is failed.
527 
528         Drivers who need network information for block device preparaion should
529         clean the preparation when block device mapping is failed.
530 
531         :param nova.objects.instance.Instance instance:
532             The instance whose networks are prepared.
533         :param nova.network.model.NetworkInfoAsyncWrapper network_info:
534             The network information of the given `instance`.
535         """
536         pass
537 
538     def attach_interface(self, context, instance, image_meta, vif):
539         """Use hotplug to add a network interface to a running instance.
540 
541         The counter action to this is :func:`detach_interface`.
542 
543         :param context: The request context.
544         :param nova.objects.instance.Instance instance:
545             The instance which will get an additional network interface.
546         :param nova.objects.ImageMeta image_meta:
547             The metadata of the image of the instance.
548         :param nova.network.model.VIF vif:
549             The object which has the information about the interface to attach.
550 
551         :raise nova.exception.NovaException: If the attach fails.
552 
553         :return: None
554         """
555         raise NotImplementedError()
556 
557     def detach_interface(self, context, instance, vif):
558         """Use hotunplug to remove a network interface from a running instance.
559 
560         The counter action to this is :func:`attach_interface`.
561 
562         :param context: The request context.
563         :param nova.objects.instance.Instance instance:
564             The instance which gets a network interface removed.
565         :param nova.network.model.VIF vif:
566             The object which has the information about the interface to detach.
567 
568         :raise nova.exception.NovaException: If the detach fails.
569 
570         :return: None
571         """
572         raise NotImplementedError()
573 
574     def migrate_disk_and_power_off(self, context, instance, dest,
575                                    flavor, network_info,
576                                    block_device_info=None,
577                                    timeout=0, retry_interval=0):
578         """Transfers the disk of a running instance in multiple phases, turning
579         off the instance before the end.
580 
581         :param nova.objects.instance.Instance instance:
582             The instance whose disk should be migrated.
583         :param str dest:
584             The IP address of the destination host.
585         :param nova.objects.flavor.Flavor flavor:
586             The flavor of the instance whose disk get migrated.
587         :param nova.network.model.NetworkInfo network_info:
588             The network information of the given `instance`.
589         :param dict block_device_info:
590             Information about the block devices.
591         :param int timeout:
592             The time in seconds to wait for the guest OS to shutdown.
593         :param int retry_interval:
594             How often to signal guest while waiting for it to shutdown.
595 
596         :return: A list of disk information dicts in JSON format.
597         :rtype: str
598         """
599         raise NotImplementedError()
600 
601     def snapshot(self, context, instance, image_id, update_task_state):
602         """Snapshots the specified instance.
603 
604         :param context: security context
605         :param instance: nova.objects.instance.Instance
606         :param image_id: Reference to a pre-created image that will
607                          hold the snapshot.
608         :param update_task_state: Callback function to update the task_state
609             on the instance while the snapshot operation progresses. The
610             function takes a task_state argument and an optional
611             expected_task_state kwarg which defaults to
612             nova.compute.task_states.IMAGE_SNAPSHOT. See
613             nova.objects.instance.Instance.save for expected_task_state usage.
614         """
615         raise NotImplementedError()
616 
617     def post_interrupted_snapshot_cleanup(self, context, instance):
618         """Cleans up any resources left after an interrupted snapshot.
619 
620         :param context: security context
621         :param instance: nova.objects.instance.Instance
622         """
623         pass
624 
625     def finish_migration(self, context, migration, instance, disk_info,
626                          network_info, image_meta, resize_instance,
627                          block_device_info=None, power_on=True):
628         """Completes a resize/migration.
629 
630         :param context: the context for the migration/resize
631         :param migration: the migrate/resize information
632         :param instance: nova.objects.instance.Instance being migrated/resized
633         :param disk_info: the newly transferred disk information
634         :param network_info: instance network information
635         :param nova.objects.ImageMeta image_meta:
636             The metadata of the image of the instance.
637         :param resize_instance: True if the instance is being resized,
638                                 False otherwise
639         :param block_device_info: instance volume block device info
640         :param power_on: True if the instance should be powered on, False
641                          otherwise
642         """
643         raise NotImplementedError()
644 
645     def confirm_migration(self, context, migration, instance, network_info):
646         """Confirms a resize/migration, destroying the source VM.
647 
648         :param instance: nova.objects.instance.Instance
649         """
650         raise NotImplementedError()
651 
652     def finish_revert_migration(self, context, instance, network_info,
653                                 block_device_info=None, power_on=True):
654         """Finish reverting a resize/migration.
655 
656         :param context: the context for the finish_revert_migration
657         :param instance: nova.objects.instance.Instance being migrated/resized
658         :param network_info: instance network information
659         :param block_device_info: instance volume block device info
660         :param power_on: True if the instance should be powered on, False
661                          otherwise
662         """
663         raise NotImplementedError()
664 
665     def pause(self, instance):
666         """Pause the given instance.
667 
668         A paused instance doesn't use CPU cycles of the host anymore. The
669         state of the VM could be stored in the memory or storage space of the
670         host, depending on the underlying hypervisor technology.
671         A "stronger" version of `pause` is :func:'suspend'.
672         The counter action for `pause` is :func:`unpause`.
673 
674         :param nova.objects.instance.Instance instance:
675             The instance which should be paused.
676 
677         :return: None
678         """
679         # TODO(Vek): Need to pass context in for access to auth_token
680         raise NotImplementedError()
681 
682     def unpause(self, instance):
683         """Unpause the given paused instance.
684 
685         The paused instance gets unpaused and will use CPU cycles of the
686         host again. The counter action for 'unpause' is :func:`pause`.
687         Depending on the underlying hypervisor technology, the guest has the
688         same state as before the 'pause'.
689 
690         :param nova.objects.instance.Instance instance:
691             The instance which should be unpaused.
692 
693         :return: None
694         """
695         # TODO(Vek): Need to pass context in for access to auth_token
696         raise NotImplementedError()
697 
698     def suspend(self, context, instance):
699         """Suspend the specified instance.
700 
701         A suspended instance doesn't use CPU cycles or memory of the host
702         anymore. The state of the instance could be persisted on the host
703         and allocate storage space this way. A "softer" way of `suspend`
704         is :func:`pause`. The counter action for `suspend` is :func:`resume`.
705 
706         :param nova.context.RequestContext context:
707             The context for the suspend.
708         :param nova.objects.instance.Instance instance:
709             The instance to suspend.
710 
711         :return: None
712         """
713         raise NotImplementedError()
714 
715     def resume(self, context, instance, network_info, block_device_info=None):
716         """resume the specified suspended instance.
717 
718         The suspended instance gets resumed and will use CPU cycles and memory
719         of the host again. The counter action for 'resume' is :func:`suspend`.
720         Depending on the underlying hypervisor technology, the guest has the
721         same state as before the 'suspend'.
722 
723         :param nova.context.RequestContext context:
724             The context for the resume.
725         :param nova.objects.instance.Instance instance:
726             The suspended instance to resume.
727         :param nova.network.model.NetworkInfo network_info:
728             Necessary network information for the resume.
729         :param dict block_device_info:
730             Instance volume block device info.
731 
732         :return: None
733         """
734         raise NotImplementedError()
735 
736     def resume_state_on_host_boot(self, context, instance, network_info,
737                                   block_device_info=None):
738         """resume guest state when a host is booted.
739 
740         :param instance: nova.objects.instance.Instance
741         """
742         raise NotImplementedError()
743 
744     def rescue(self, context, instance, network_info, image_meta,
745                rescue_password):
746         """Rescue the specified instance.
747 
748         :param nova.context.RequestContext context:
749             The context for the rescue.
750         :param nova.objects.instance.Instance instance:
751             The instance being rescued.
752         :param nova.network.model.NetworkInfo network_info:
753             Necessary network information for the resume.
754         :param nova.objects.ImageMeta image_meta:
755             The metadata of the image of the instance.
756         :param rescue_password: new root password to set for rescue.
757         """
758         raise NotImplementedError()
759 
760     def set_bootable(self, instance, is_bootable):
761         """Set the ability to power on/off an instance.
762 
763         :param instance: nova.objects.instance.Instance
764         """
765         raise NotImplementedError()
766 
767     def unrescue(self, instance, network_info):
768         """Unrescue the specified instance.
769 
770         :param instance: nova.objects.instance.Instance
771         """
772         # TODO(Vek): Need to pass context in for access to auth_token
773         raise NotImplementedError()
774 
775     def power_off(self, instance, timeout=0, retry_interval=0):
776         """Power off the specified instance.
777 
778         :param instance: nova.objects.instance.Instance
779         :param timeout: time to wait for GuestOS to shutdown
780         :param retry_interval: How often to signal guest while
781                                waiting for it to shutdown
782         """
783         raise NotImplementedError()
784 
785     def power_on(self, context, instance, network_info,
786                  block_device_info=None):
787         """Power on the specified instance.
788 
789         :param instance: nova.objects.instance.Instance
790         """
791         raise NotImplementedError()
792 
793     def trigger_crash_dump(self, instance):
794         """Trigger crash dump mechanism on the given instance.
795 
796         Stalling instances can be triggered to dump the crash data. How the
797         guest OS reacts in details, depends on the configuration of it.
798 
799         :param nova.objects.instance.Instance instance:
800             The instance where the crash dump should be triggered.
801 
802         :return: None
803         """
804         raise NotImplementedError()
805 
806     def soft_delete(self, instance):
807         """Soft delete the specified instance.
808 
809         A soft-deleted instance doesn't allocate any resources anymore, but is
810         still available as a database entry. The counter action :func:`restore`
811         uses the database entry to create a new instance based on that.
812 
813         :param nova.objects.instance.Instance instance:
814             The instance to soft-delete.
815 
816         :return: None
817         """
818         raise NotImplementedError()
819 
820     def restore(self, instance):
821         """Restore the specified soft-deleted instance.
822 
823         The restored instance will be automatically booted. The counter action
824         for `restore` is :func:`soft_delete`.
825 
826         :param nova.objects.instance.Instance instance:
827             The soft-deleted instance which should be restored from the
828             soft-deleted data.
829 
830         :return: None
831         """
832         raise NotImplementedError()
833 
834     def update_provider_tree(self, provider_tree, nodename):
835         """Update a ProviderTree object with current resource provider and
836         inventory information.
837 
838         When this method returns, provider_tree should represent the correct
839         hierarchy of nested resource providers associated with this compute
840         node, as well as the inventory, aggregates, and traits associated with
841         those resource providers.
842 
843         This method supersedes get_inventory(): if this method is implemented,
844         get_inventory() is not used.
845 
846         :note: Renaming a provider (by deleting it from provider_tree and
847         re-adding it with a different name) is not supported at this time.
848 
849         See the developer reference documentation for more details:
850 
851         https://docs.openstack.org/nova/latest/reference/update-provider-tree.html   # noqa
852 
853         :param nova.compute.provider_tree.ProviderTree provider_tree:
854             A nova.compute.provider_tree.ProviderTree object representing all
855             the providers in the tree associated with the compute node, and any
856             sharing providers (those with the ``MISC_SHARES_VIA_AGGREGATE``
857             trait) associated via aggregate with any of those providers (but
858             not *their* tree- or aggregate-associated providers), as currently
859             known by placement. This object is fully owned by the
860             update_provider_tree method, and can therefore be modified without
861             locking/concurrency considerations. In other words, the parameter
862             is passed *by reference* with the expectation that the virt driver
863             will modify the object. Note, however, that it may contain
864             providers not directly owned/controlled by the compute host. Care
865             must be taken not to remove or modify such providers inadvertently.
866             In addition, providers may be associated with traits and/or
867             aggregates maintained by outside agents. The
868             `update_provider_tree`` method must therefore also be careful only
869             to add/remove traits/aggregates it explicitly controls.
870         :param nodename:
871             String name of the compute node (i.e.
872             ComputeNode.hypervisor_hostname) for which the caller is requesting
873             updated provider information. Drivers may use this to help identify
874             the compute node provider in the ProviderTree. Drivers managing
875             more than one node (e.g. ironic) may also use it as a cue to
876             indicate which node is being processed by the caller.
877         """
878         raise NotImplementedError()
879 
880     def get_inventory(self, nodename):
881         """Return a dict, keyed by resource class, of inventory information for
882         the supplied node.
883         """
884         raise NotImplementedError()
885 
886     def get_traits(self, nodename):
887         """Get the traits for a given node.
888 
889         Any custom traits returned are not required to exist in the placement
890         service - the caller will ensure their existence.
891 
892         :param nodename: the name of the node.
893         :returns: an iterable of string trait names for the supplied node.
894         """
895         raise NotImplementedError()
896 
897     def get_available_resource(self, nodename):
898         """Retrieve resource information.
899 
900         This method is called when nova-compute launches, and
901         as part of a periodic task that records the results in the DB.
902 
903         :param nodename:
904             node which the caller want to get resources from
905             a driver that manages only one node can safely ignore this
906         :returns: Dictionary describing resources
907         """
908         raise NotImplementedError()
909 
910     def pre_live_migration(self, context, instance, block_device_info,
911                            network_info, disk_info, migrate_data):
912         """Prepare an instance for live migration
913 
914         :param context: security context
915         :param instance: nova.objects.instance.Instance object
916         :param block_device_info: instance block device information
917         :param network_info: instance network information
918         :param disk_info: instance disk information
919         :param migrate_data: a LiveMigrateData object
920         :returns: migrate_data modified by the driver
921         """
922         raise NotImplementedError()
923 
924     def live_migration(self, context, instance, dest,
925                        post_method, recover_method, block_migration=False,
926                        migrate_data=None):
927         """Live migration of an instance to another host.
928 
929         :param context: security context
930         :param instance:
931             nova.db.sqlalchemy.models.Instance object
932             instance object that is migrated.
933         :param dest: destination host
934         :param post_method:
935             post operation method.
936             expected nova.compute.manager._post_live_migration.
937         :param recover_method:
938             recovery method when any exception occurs.
939             expected nova.compute.manager._rollback_live_migration.
940         :param block_migration: if true, migrate VM disk.
941         :param migrate_data: a LiveMigrateData object
942 
943         """
944         raise NotImplementedError()
945 
946     def live_migration_force_complete(self, instance):
947         """Force live migration to complete
948 
949         :param instance: Instance being live migrated
950 
951         """
952         raise NotImplementedError()
953 
954     def live_migration_abort(self, instance):
955         """Abort an in-progress live migration.
956 
957         :param instance: instance that is live migrating
958 
959         """
960         raise NotImplementedError()
961 
962     def rollback_live_migration_at_destination(self, context, instance,
963                                                network_info,
964                                                block_device_info,
965                                                destroy_disks=True,
966                                                migrate_data=None):
967         """Clean up destination node after a failed live migration.
968 
969         :param context: security context
970         :param instance: instance object that was being migrated
971         :param network_info: instance network information
972         :param block_device_info: instance block device information
973         :param destroy_disks:
974             if true, destroy disks at destination during cleanup
975         :param migrate_data: a LiveMigrateData object
976 
977         """
978         raise NotImplementedError()
979 
980     def post_live_migration(self, context, instance, block_device_info,
981                             migrate_data=None):
982         """Post operation of live migration at source host.
983 
984         :param context: security context
985         :instance: instance object that was migrated
986         :block_device_info: instance block device information
987         :param migrate_data: a LiveMigrateData object
988         """
989         pass
990 
991     def post_live_migration_at_source(self, context, instance, network_info):
992         """Unplug VIFs from networks at source.
993 
994         :param context: security context
995         :param instance: instance object reference
996         :param network_info: instance network information
997         """
998         raise NotImplementedError(_("Hypervisor driver does not support "
999                                     "post_live_migration_at_source method"))
1000 
1001     def post_live_migration_at_destination(self, context, instance,
1002                                            network_info,
1003                                            block_migration=False,
1004                                            block_device_info=None):
1005         """Post operation of live migration at destination host.
1006 
1007         :param context: security context
1008         :param instance: instance object that is migrated
1009         :param network_info: instance network information
1010         :param block_migration: if true, post operation of block_migration.
1011         """
1012         raise NotImplementedError()
1013 
1014     def check_instance_shared_storage_local(self, context, instance):
1015         """Check if instance files located on shared storage.
1016 
1017         This runs check on the destination host, and then calls
1018         back to the source host to check the results.
1019 
1020         :param context: security context
1021         :param instance: nova.objects.instance.Instance object
1022         """
1023         raise NotImplementedError()
1024 
1025     def check_instance_shared_storage_remote(self, context, data):
1026         """Check if instance files located on shared storage.
1027 
1028         :param context: security context
1029         :param data: result of check_instance_shared_storage_local
1030         """
1031         raise NotImplementedError()
1032 
1033     def check_instance_shared_storage_cleanup(self, context, data):
1034         """Do cleanup on host after check_instance_shared_storage calls
1035 
1036         :param context: security context
1037         :param data: result of check_instance_shared_storage_local
1038         """
1039         pass
1040 
1041     def check_can_live_migrate_destination(self, context, instance,
1042                                            src_compute_info, dst_compute_info,
1043                                            block_migration=False,
1044                                            disk_over_commit=False):
1045         """Check if it is possible to execute live migration.
1046 
1047         This runs checks on the destination host, and then calls
1048         back to the source host to check the results.
1049 
1050         :param context: security context
1051         :param instance: nova.db.sqlalchemy.models.Instance
1052         :param src_compute_info: Info about the sending machine
1053         :param dst_compute_info: Info about the receiving machine
1054         :param block_migration: if true, prepare for block migration
1055         :param disk_over_commit: if true, allow disk over commit
1056         :returns: a LiveMigrateData object (hypervisor-dependent)
1057         """
1058         raise NotImplementedError()
1059 
1060     def cleanup_live_migration_destination_check(self, context,
1061                                                  dest_check_data):
1062         """Do required cleanup on dest host after check_can_live_migrate calls
1063 
1064         :param context: security context
1065         :param dest_check_data: result of check_can_live_migrate_destination
1066         """
1067         raise NotImplementedError()
1068 
1069     def check_can_live_migrate_source(self, context, instance,
1070                                       dest_check_data, block_device_info=None):
1071         """Check if it is possible to execute live migration.
1072 
1073         This checks if the live migration can succeed, based on the
1074         results from check_can_live_migrate_destination.
1075 
1076         :param context: security context
1077         :param instance: nova.db.sqlalchemy.models.Instance
1078         :param dest_check_data: result of check_can_live_migrate_destination
1079         :param block_device_info: result of _get_instance_block_device_info
1080         :returns: a LiveMigrateData object
1081         """
1082         raise NotImplementedError()
1083 
1084     def get_instance_disk_info(self, instance,
1085                                block_device_info=None):
1086         """Retrieve information about actual disk sizes of an instance.
1087 
1088         :param instance: nova.objects.Instance
1089         :param block_device_info:
1090             Optional; Can be used to filter out devices which are
1091             actually volumes.
1092         :return:
1093             json strings with below format::
1094 
1095                 "[{'path':'disk',
1096                    'type':'raw',
1097                    'virt_disk_size':'10737418240',
1098                    'backing_file':'backing_file',
1099                    'disk_size':'83886080'
1100                    'over_committed_disk_size':'10737418240'},
1101                    ...]"
1102         """
1103         raise NotImplementedError()
1104 
1105     def refresh_security_group_rules(self, security_group_id):
1106         """This method is called after a change to security groups.
1107 
1108         All security groups and their associated rules live in the datastore,
1109         and calling this method should apply the updated rules to instances
1110         running the specified security group.
1111 
1112         An error should be raised if the operation cannot complete.
1113 
1114         """
1115         # TODO(Vek): Need to pass context in for access to auth_token
1116         raise NotImplementedError()
1117 
1118     def refresh_instance_security_rules(self, instance):
1119         """Refresh security group rules
1120 
1121         Gets called when an instance gets added to or removed from
1122         the security group the instance is a member of or if the
1123         group gains or loses a rule.
1124         """
1125         raise NotImplementedError()
1126 
1127     def reset_network(self, instance):
1128         """reset networking for specified instance."""
1129         # TODO(Vek): Need to pass context in for access to auth_token
1130         pass
1131 
1132     def ensure_filtering_rules_for_instance(self, instance, network_info):
1133         """Setting up filtering rules and waiting for its completion.
1134 
1135         To migrate an instance, filtering rules to hypervisors
1136         and firewalls are inevitable on destination host.
1137         ( Waiting only for filtering rules to hypervisor,
1138         since filtering rules to firewall rules can be set faster).
1139 
1140         Concretely, the below method must be called.
1141         - setup_basic_filtering (for nova-basic, etc.)
1142         - prepare_instance_filter(for nova-instance-instance-xxx, etc.)
1143 
1144         to_xml may have to be called since it defines PROJNET, PROJMASK.
1145         but libvirt migrates those value through migrateToURI(),
1146         so , no need to be called.
1147 
1148         Don't use thread for this method since migration should
1149         not be started when setting-up filtering rules operations
1150         are not completed.
1151 
1152         :param instance: nova.objects.instance.Instance object
1153 
1154         """
1155         # TODO(Vek): Need to pass context in for access to auth_token
1156         raise NotImplementedError()
1157 
1158     def filter_defer_apply_on(self):
1159         """Defer application of IPTables rules."""
1160         pass
1161 
1162     def filter_defer_apply_off(self):
1163         """Turn off deferral of IPTables rules and apply the rules now."""
1164         pass
1165 
1166     def unfilter_instance(self, instance, network_info):
1167         """Stop filtering instance."""
1168         # TODO(Vek): Need to pass context in for access to auth_token
1169         raise NotImplementedError()
1170 
1171     def set_admin_password(self, instance, new_pass):
1172         """Set the root password on the specified instance.
1173 
1174         :param instance: nova.objects.instance.Instance
1175         :param new_pass: the new password
1176         """
1177         raise NotImplementedError()
1178 
1179     def inject_file(self, instance, b64_path, b64_contents):
1180         """Writes a file on the specified instance.
1181 
1182         The first parameter is an instance of nova.compute.service.Instance,
1183         and so the instance is being specified as instance.name. The second
1184         parameter is the base64-encoded path to which the file is to be
1185         written on the instance; the third is the contents of the file, also
1186         base64-encoded.
1187 
1188         NOTE(russellb) This method is deprecated and will be removed once it
1189         can be removed from nova.compute.manager.
1190         """
1191         # TODO(Vek): Need to pass context in for access to auth_token
1192         raise NotImplementedError()
1193 
1194     def change_instance_metadata(self, context, instance, diff):
1195         """Applies a diff to the instance metadata.
1196 
1197         This is an optional driver method which is used to publish
1198         changes to the instance's metadata to the hypervisor.  If the
1199         hypervisor has no means of publishing the instance metadata to
1200         the instance, then this method should not be implemented.
1201 
1202         :param context: security context
1203         :param instance: nova.objects.instance.Instance
1204         """
1205         pass
1206 
1207     def inject_network_info(self, instance, nw_info):
1208         """inject network info for specified instance."""
1209         # TODO(Vek): Need to pass context in for access to auth_token
1210         pass
1211 
1212     def poll_rebooting_instances(self, timeout, instances):
1213         """Perform a reboot on all given 'instances'.
1214 
1215         Reboots the given `instances` which are longer in the rebooting state
1216         than `timeout` seconds.
1217 
1218         :param int timeout:
1219             The timeout (in seconds) for considering rebooting instances
1220             to be stuck.
1221         :param list instances:
1222             A list of nova.objects.instance.Instance objects that have been
1223             in rebooting state longer than the configured timeout.
1224 
1225         :return: None
1226         """
1227         # TODO(Vek): Need to pass context in for access to auth_token
1228         raise NotImplementedError()
1229 
1230     def host_power_action(self, action):
1231         """Reboots, shuts down or powers up the host.
1232 
1233         :param str action:
1234             The action the host should perform. The valid actions are:
1235             ""startup", "shutdown" and "reboot".
1236 
1237         :return: The result of the power action
1238         :rtype: str
1239         """
1240 
1241         raise NotImplementedError()
1242 
1243     def host_maintenance_mode(self, host, mode):
1244         """Start/Stop host maintenance window.
1245 
1246         On start, it triggers the migration of all instances to other hosts.
1247         Consider the combination with :func:`set_host_enabled`.
1248 
1249         :param str host:
1250             The name of the host whose maintenance mode should be changed.
1251         :param bool mode:
1252             If `True`, go into maintenance mode. If `False`, leave the
1253             maintenance mode.
1254 
1255         :return: "on_maintenance" if switched to maintenance mode or
1256                  "off_maintenance" if maintenance mode got left.
1257         :rtype: str
1258         """
1259 
1260         raise NotImplementedError()
1261 
1262     def set_host_enabled(self, enabled):
1263         """Sets the ability of this host to accept new instances.
1264 
1265         :param bool enabled:
1266             If this is `True`, the host will accept new instances. If it is
1267             `False`, the host won't accept new instances.
1268 
1269         :return: If the host can accept further instances, return "enabled",
1270                  if further instances shouldn't be scheduled to this host,
1271                  return "disabled".
1272         :rtype: str
1273         """
1274         # TODO(Vek): Need to pass context in for access to auth_token
1275         raise NotImplementedError()
1276 
1277     def get_host_uptime(self):
1278         """Returns the result of the time since start up of this hypervisor.
1279 
1280         :return: A text which contains the uptime of this host since the
1281                  last boot.
1282         :rtype: str
1283         """
1284         # TODO(Vek): Need to pass context in for access to auth_token
1285         raise NotImplementedError()
1286 
1287     def plug_vifs(self, instance, network_info):
1288         """Plug virtual interfaces (VIFs) into the given `instance` at
1289         instance boot time.
1290 
1291         The counter action is :func:`unplug_vifs`.
1292 
1293         :param nova.objects.instance.Instance instance:
1294             The instance which gets VIFs plugged.
1295         :param nova.network.model.NetworkInfo network_info:
1296             The object which contains information about the VIFs to plug.
1297 
1298         :return: None
1299         """
1300         # TODO(Vek): Need to pass context in for access to auth_token
1301         raise NotImplementedError()
1302 
1303     def unplug_vifs(self, instance, network_info):
1304         # NOTE(markus_z): 2015-08-18
1305         # The compute manager doesn't use this interface, which seems odd
1306         # since the manager should be the controlling thing here.
1307         """Unplug virtual interfaces (VIFs) from networks.
1308 
1309         The counter action is :func:`plug_vifs`.
1310 
1311         :param nova.objects.instance.Instance instance:
1312             The instance which gets VIFs unplugged.
1313         :param nova.network.model.NetworkInfo network_info:
1314             The object which contains information about the VIFs to unplug.
1315 
1316         :return: None
1317         """
1318         raise NotImplementedError()
1319 
1320     def get_host_cpu_stats(self):
1321         """Get the currently known host CPU stats.
1322 
1323         :returns: a dict containing the CPU stat info, eg:
1324 
1325             | {'kernel': kern,
1326             |  'idle': idle,
1327             |  'user': user,
1328             |  'iowait': wait,
1329             |   'frequency': freq},
1330 
1331                   where kern and user indicate the cumulative CPU time
1332                   (nanoseconds) spent by kernel and user processes
1333                   respectively, idle indicates the cumulative idle CPU time
1334                   (nanoseconds), wait indicates the cumulative I/O wait CPU
1335                   time (nanoseconds), since the host is booting up; freq
1336                   indicates the current CPU frequency (MHz). All values are
1337                   long integers.
1338 
1339         """
1340         raise NotImplementedError()
1341 
1342     def block_stats(self, instance, disk_id):
1343         """Return performance counters associated with the given disk_id on the
1344         given instance.  These are returned as [rd_req, rd_bytes, wr_req,
1345         wr_bytes, errs], where rd indicates read, wr indicates write, req is
1346         the total number of I/O requests made, bytes is the total number of
1347         bytes transferred, and errs is the number of requests held up due to a
1348         full pipeline.
1349 
1350         All counters are long integers.
1351 
1352         This method is optional.  On some platforms (e.g. XenAPI) performance
1353         statistics can be retrieved directly in aggregate form, without Nova
1354         having to do the aggregation.  On those platforms, this method is
1355         unused.
1356 
1357         Note that this function takes an instance ID.
1358         """
1359         raise NotImplementedError()
1360 
1361     def deallocate_networks_on_reschedule(self, instance):
1362         """Does the driver want networks deallocated on reschedule?"""
1363         return False
1364 
1365     # NOTE(vsaienko) This method is deprecated, don't use it!
1366     # TODO(vsaienko) Remove this function in Ocata.
1367     def macs_for_instance(self, instance):
1368         """What MAC addresses must this instance have?
1369 
1370         Some hypervisors (such as bare metal) cannot do freeform virtualization
1371         of MAC addresses. This method allows drivers to return a set of MAC
1372         addresses that the instance is to have. allocate_for_instance will take
1373         this into consideration when provisioning networking for the instance.
1374 
1375         Mapping of MAC addresses to actual networks (or permitting them to be
1376         freeform) is up to the network implementation layer. For instance,
1377         with openflow switches, fixed MAC addresses can still be virtualized
1378         onto any L2 domain, with arbitrary VLANs etc, but regular switches
1379         require pre-configured MAC->network mappings that will match the
1380         actual configuration.
1381 
1382         Most hypervisors can use the default implementation which returns None.
1383         Hypervisors with MAC limits should return a set of MAC addresses, which
1384         will be supplied to the allocate_for_instance call by the compute
1385         manager, and it is up to that call to ensure that all assigned network
1386         details are compatible with the set of MAC addresses.
1387 
1388         This is called during spawn_instance by the compute manager.
1389 
1390         :return: None, or a set of MAC ids (e.g. set(['12:34:56:78:90:ab'])).
1391             None means 'no constraints', a set means 'these and only these
1392             MAC addresses'.
1393         """
1394         return None
1395 
1396     def manage_image_cache(self, context, all_instances):
1397         """Manage the driver's local image cache.
1398 
1399         Some drivers chose to cache images for instances on disk. This method
1400         is an opportunity to do management of that cache which isn't directly
1401         related to other calls into the driver. The prime example is to clean
1402         the cache and remove images which are no longer of interest.
1403 
1404         :param all_instances: nova.objects.instance.InstanceList
1405         """
1406         pass
1407 
1408     def add_to_aggregate(self, context, aggregate, host, **kwargs):
1409         """Add a compute host to an aggregate.
1410 
1411         The counter action to this is :func:`remove_from_aggregate`
1412 
1413         :param nova.context.RequestContext context:
1414             The security context.
1415         :param nova.objects.aggregate.Aggregate aggregate:
1416             The aggregate which should add the given `host`
1417         :param str host:
1418             The name of the host to add to the given `aggregate`.
1419         :param dict kwargs:
1420             A free-form thingy...
1421 
1422         :return: None
1423         """
1424         # NOTE(jogo) Currently only used for XenAPI-Pool
1425         raise NotImplementedError()
1426 
1427     def remove_from_aggregate(self, context, aggregate, host, **kwargs):
1428         """Remove a compute host from an aggregate.
1429 
1430         The counter action to this is :func:`add_to_aggregate`
1431 
1432         :param nova.context.RequestContext context:
1433             The security context.
1434         :param nova.objects.aggregate.Aggregate aggregate:
1435             The aggregate which should remove the given `host`
1436         :param str host:
1437             The name of the host to remove from the given `aggregate`.
1438         :param dict kwargs:
1439             A free-form thingy...
1440 
1441         :return: None
1442         """
1443         raise NotImplementedError()
1444 
1445     def undo_aggregate_operation(self, context, op, aggregate,
1446                                   host, set_error=True):
1447         """Undo for Resource Pools."""
1448         raise NotImplementedError()
1449 
1450     def get_volume_connector(self, instance):
1451         """Get connector information for the instance for attaching to volumes.
1452 
1453         Connector information is a dictionary representing the ip of the
1454         machine that will be making the connection, the name of the iscsi
1455         initiator and the hostname of the machine as follows::
1456 
1457             {
1458                 'ip': ip,
1459                 'initiator': initiator,
1460                 'host': hostname
1461             }
1462 
1463         """
1464         raise NotImplementedError()
1465 
1466     def get_available_nodes(self, refresh=False):
1467         """Returns nodenames of all nodes managed by the compute service.
1468 
1469         This method is for multi compute-nodes support. If a driver supports
1470         multi compute-nodes, this method returns a list of nodenames managed
1471         by the service. Otherwise, this method should return
1472         [hypervisor_hostname].
1473         """
1474         raise NotImplementedError()
1475 
1476     def node_is_available(self, nodename):
1477         """Return whether this compute service manages a particular node."""
1478         if nodename in self.get_available_nodes():
1479             return True
1480         # Refresh and check again.
1481         return nodename in self.get_available_nodes(refresh=True)
1482 
1483     def get_per_instance_usage(self):
1484         """Get information about instance resource usage.
1485 
1486         :returns: dict of  nova uuid => dict of usage info
1487         """
1488         return {}
1489 
1490     def instance_on_disk(self, instance):
1491         """Checks access of instance files on the host.
1492 
1493         :param instance: nova.objects.instance.Instance to lookup
1494 
1495         Returns True if files of an instance with the supplied ID accessible on
1496         the host, False otherwise.
1497 
1498         .. note::
1499             Used in rebuild for HA implementation and required for validation
1500             of access to instance shared disk files
1501         """
1502         return False
1503 
1504     def register_event_listener(self, callback):
1505         """Register a callback to receive events.
1506 
1507         Register a callback to receive asynchronous event
1508         notifications from hypervisors. The callback will
1509         be invoked with a single parameter, which will be
1510         an instance of the nova.virt.event.Event class.
1511         """
1512 
1513         self._compute_event_callback = callback
1514 
1515     def emit_event(self, event):
1516         """Dispatches an event to the compute manager.
1517 
1518         Invokes the event callback registered by the
1519         compute manager to dispatch the event. This
1520         must only be invoked from a green thread.
1521         """
1522 
1523         if not self._compute_event_callback:
1524             LOG.debug("Discarding event %s", six.text_type(event))
1525             return
1526 
1527         if not isinstance(event, virtevent.Event):
1528             raise ValueError(
1529                 _("Event must be an instance of nova.virt.event.Event"))
1530 
1531         try:
1532             LOG.debug("Emitting event %s", six.text_type(event))
1533             self._compute_event_callback(event)
1534         except Exception as ex:
1535             LOG.error("Exception dispatching event %(event)s: %(ex)s",
1536                       {'event': event, 'ex': ex})
1537 
1538     def delete_instance_files(self, instance):
1539         """Delete any lingering instance files for an instance.
1540 
1541         :param instance: nova.objects.instance.Instance
1542         :returns: True if the instance was deleted from disk, False otherwise.
1543         """
1544         return True
1545 
1546     @property
1547     def need_legacy_block_device_info(self):
1548         """Tell the caller if the driver requires legacy block device info.
1549 
1550         Tell the caller whether we expect the legacy format of block
1551         device info to be passed in to methods that expect it.
1552         """
1553         return True
1554 
1555     def volume_snapshot_create(self, context, instance, volume_id,
1556                                create_info):
1557         """Snapshots volumes attached to a specified instance.
1558 
1559         The counter action to this is :func:`volume_snapshot_delete`
1560 
1561         :param nova.context.RequestContext context:
1562             The security context.
1563         :param nova.objects.instance.Instance  instance:
1564             The instance that has the volume attached
1565         :param uuid volume_id:
1566             Volume to be snapshotted
1567         :param create_info: The data needed for nova to be able to attach
1568                to the volume.  This is the same data format returned by
1569                Cinder's initialize_connection() API call.  In the case of
1570                doing a snapshot, it is the image file Cinder expects to be
1571                used as the active disk after the snapshot operation has
1572                completed.  There may be other data included as well that is
1573                needed for creating the snapshot.
1574         """
1575         raise NotImplementedError()
1576 
1577     def volume_snapshot_delete(self, context, instance, volume_id,
1578                                snapshot_id, delete_info):
1579         """Deletes a snapshot of a volume attached to a specified instance.
1580 
1581         The counter action to this is :func:`volume_snapshot_create`
1582 
1583         :param nova.context.RequestContext context:
1584             The security context.
1585         :param nova.objects.instance.Instance instance:
1586             The instance that has the volume attached.
1587         :param uuid volume_id:
1588             Attached volume associated with the snapshot
1589         :param uuid snapshot_id:
1590             The snapshot to delete.
1591         :param dict delete_info:
1592             Volume backend technology specific data needed to be able to
1593             complete the snapshot.  For example, in the case of qcow2 backed
1594             snapshots, this would include the file being merged, and the file
1595             being merged into (if appropriate).
1596 
1597         :return: None
1598         """
1599         raise NotImplementedError()
1600 
1601     def default_root_device_name(self, instance, image_meta, root_bdm):
1602         """Provide a default root device name for the driver.
1603 
1604         :param nova.objects.instance.Instance instance:
1605             The instance to get the root device for.
1606         :param nova.objects.ImageMeta image_meta:
1607             The metadata of the image of the instance.
1608         :param nova.objects.BlockDeviceMapping root_bdm:
1609             The description of the root device.
1610         """
1611         raise NotImplementedError()
1612 
1613     def default_device_names_for_instance(self, instance, root_device_name,
1614                                           *block_device_lists):
1615         """Default the missing device names in the block device mapping."""
1616         raise NotImplementedError()
1617 
1618     def get_device_name_for_instance(self, instance,
1619                                      bdms, block_device_obj):
1620         """Get the next device name based on the block device mapping.
1621 
1622         :param instance: nova.objects.instance.Instance that volume is
1623                          requesting a device name
1624         :param bdms: a nova.objects.BlockDeviceMappingList for the instance
1625         :param block_device_obj: A nova.objects.BlockDeviceMapping instance
1626                                  with all info about the requested block
1627                                  device. device_name does not need to be set,
1628                                  and should be decided by the driver
1629                                  implementation if not set.
1630 
1631         :returns: The chosen device name.
1632         """
1633         raise NotImplementedError()
1634 
1635     def is_supported_fs_format(self, fs_type):
1636         """Check whether the file format is supported by this driver
1637 
1638         :param fs_type: the file system type to be checked,
1639                         the validate values are defined at disk API module.
1640         """
1641         # NOTE(jichenjc): Return False here so that every hypervisor
1642         #                 need to define their supported file system
1643         #                 type and implement this function at their
1644         #                 virt layer.
1645         return False
1646 
1647     def quiesce(self, context, instance, image_meta):
1648         """Quiesce the specified instance to prepare for snapshots.
1649 
1650         If the specified instance doesn't support quiescing,
1651         InstanceQuiesceNotSupported is raised. When it fails to quiesce by
1652         other errors (e.g. agent timeout), NovaException is raised.
1653 
1654         :param context:  request context
1655         :param instance: nova.objects.instance.Instance to be quiesced
1656         :param nova.objects.ImageMeta image_meta:
1657             The metadata of the image of the instance.
1658         """
1659         raise NotImplementedError()
1660 
1661     def unquiesce(self, context, instance, image_meta):
1662         """Unquiesce the specified instance after snapshots.
1663 
1664         If the specified instance doesn't support quiescing,
1665         InstanceQuiesceNotSupported is raised. When it fails to quiesce by
1666         other errors (e.g. agent timeout), NovaException is raised.
1667 
1668         :param context:  request context
1669         :param instance: nova.objects.instance.Instance to be unquiesced
1670         :param nova.objects.ImageMeta image_meta:
1671             The metadata of the image of the instance.
1672         """
1673         raise NotImplementedError()
1674 
1675     def network_binding_host_id(self, context, instance):
1676         """Get host ID to associate with network ports.
1677 
1678         :param context:  request context
1679         :param instance: nova.objects.instance.Instance that the network
1680                          ports will be associated with
1681         :returns: a string representing the host ID
1682         """
1683         return instance.get('host')
1684 
1685 
1686 def load_compute_driver(virtapi, compute_driver=None):
1687     """Load a compute driver module.
1688 
1689     Load the compute driver module specified by the compute_driver
1690     configuration option or, if supplied, the driver name supplied as an
1691     argument.
1692 
1693     Compute drivers constructors take a VirtAPI object as their first object
1694     and this must be supplied.
1695 
1696     :param virtapi: a VirtAPI instance
1697     :param compute_driver: a compute driver name to override the config opt
1698     :returns: a ComputeDriver instance
1699     """
1700     if not compute_driver:
1701         compute_driver = CONF.compute_driver
1702 
1703     if not compute_driver:
1704         LOG.error("Compute driver option required, but not specified")
1705         sys.exit(1)
1706 
1707     LOG.info("Loading compute driver '%s'", compute_driver)
1708     try:
1709         driver = importutils.import_object(
1710             'nova.virt.%s' % compute_driver,
1711             virtapi)
1712         if isinstance(driver, ComputeDriver):
1713             return driver
1714         raise ValueError()
1715     except ImportError:
1716         LOG.exception(_("Unable to load the virtualization driver"))
1717         sys.exit(1)
1718     except ValueError:
1719         LOG.exception("Compute driver '%s' from 'nova.virt' is not of type"
1720                       "'%s'", compute_driver, str(ComputeDriver))
1721         sys.exit(1)
1722 
1723 
1724 def is_xenapi():
1725     return CONF.compute_driver == 'xenapi.XenAPIDriver'
