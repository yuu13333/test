Please review the code below for security defects. You can consider defect types in terms of:
1.CWE-284 (Improper Access Control)
2.CWE-435 (Improper Interaction Between Multiple Entities)
3.CWE-664 (Improper Control of a Resource Through its Lifetime)
4.CWE-682 (Incorrect Calculation)
5.CWE-691 (Insufficient Control Flow Management)
6.CWE-693 (Protection Mechanism Failure)
7.CWE-697 (Incorrect Comparison)
8.CWE-703 (Improper Check or Handling of Exceptional Conditions)
9.CWE-707 (Improper Neutralization)
10.CWE-710 (Improper Adherence to Coding Standards)
If any are found, please describe the security defect in detail and indicate the corresponding line number of code and solution. If none are detected, states: 'No security defects are detected in the code'.

1 #    Licensed under the Apache License, Version 2.0 (the "License"); you may
2 #    not use this file except in compliance with the License. You may obtain
3 #    a copy of the License at
4 #
5 #         http://www.apache.org/licenses/LICENSE-2.0
6 #
7 #    Unless required by applicable law or agreed to in writing, software
8 #    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
9 #    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
10 #    License for the specific language governing permissions and limitations
11 #    under the License.
12 
13 import collections
14 import copy
15 import itertools
16 import random
17 
18 import mock
19 import netaddr
20 from neutron_lib import context
21 from neutron_lib import exceptions as n_exc
22 from neutron_lib.utils import helpers
23 from oslo_db import exception as obj_exc
24 from oslo_db.sqlalchemy import utils as db_utils
25 from oslo_utils import uuidutils
26 from oslo_versionedobjects import base as obj_base
27 from oslo_versionedobjects import exception
28 from oslo_versionedobjects import fields as obj_fields
29 from oslo_versionedobjects import fixture
30 import testtools
31 
32 from neutron.common import constants
33 from neutron.db import _model_query as model_query
34 from neutron.db.models import l3 as l3_model
35 from neutron.db import standard_attr
36 from neutron import objects
37 from neutron.objects import agent
38 from neutron.objects import base
39 from neutron.objects import common_types
40 from neutron.objects.db import api as obj_db_api
41 from neutron.objects import exceptions as o_exc
42 from neutron.objects import flavor
43 from neutron.objects.logapi import event_types
44 from neutron.objects import network as net_obj
45 from neutron.objects import ports
46 from neutron.objects.qos import policy as qos_policy
47 from neutron.objects import rbac_db
48 from neutron.objects import securitygroup
49 from neutron.objects import subnet
50 from neutron.objects import utils as obj_utils
51 from neutron.tests import base as test_base
52 from neutron.tests import tools
53 from neutron.tests.unit.db import test_db_base_plugin_v2
54 
55 
56 SQLALCHEMY_COMMIT = 'sqlalchemy.engine.Connection._commit_impl'
57 OBJECTS_BASE_OBJ_FROM_PRIMITIVE = ('oslo_versionedobjects.base.'
58                                    'VersionedObject.obj_from_primitive')
59 TIMESTAMP_FIELDS = ['created_at', 'updated_at', 'revision_number']
60 
61 
62 class FakeModel(dict):
63     pass
64 
65 
66 class ObjectFieldsModel(dict):
67     pass
68 
69 
70 @obj_base.VersionedObjectRegistry.register_if(False)
71 class FakeSmallNeutronObject(base.NeutronDbObject):
72     # Version 1.0: Initial version
73     VERSION = '1.0'
74 
75     db_model = ObjectFieldsModel
76 
77     primary_keys = ['field1']
78 
79     foreign_keys = {
80         'FakeNeutronObjectCompositePrimaryKeyWithId': {'field1': 'id'},
81         'FakeNeutronDbObject': {'field2': 'id'},
82         'FakeNeutronObjectUniqueKey': {'field3': 'id'},
83     }
84 
85     fields = {
86         'field1': common_types.UUIDField(),
87         'field2': common_types.UUIDField(),
88         'field3': common_types.UUIDField(),
89     }
90 
91 
92 @obj_base.VersionedObjectRegistry.register_if(False)
93 class FakeSmallNeutronObjectWithMultipleParents(base.NeutronDbObject):
94     # Version 1.0: Initial version
95     VERSION = '1.0'
96 
97     db_model = ObjectFieldsModel
98 
99     primary_keys = ['field1', 'field2']
100 
101     foreign_keys = {
102         'FakeParent': {'field1': 'id'},
103         'FakeParent2': {'field2': 'id'},
104     }
105 
106     fields = {
107         'field1': common_types.UUIDField(),
108         'field2': obj_fields.StringField(),
109     }
110 
111 
112 @obj_base.VersionedObjectRegistry.register_if(False)
113 class FakeParent(base.NeutronDbObject):
114     # Version 1.0: Initial version
115     VERSION = '1.0'
116 
117     db_model = ObjectFieldsModel
118 
119     primary_keys = ['field1', 'field2']
120 
121     fields = {
122         'id': common_types.UUIDField(),
123         'children': obj_fields.ListOfObjectsField(
124             'FakeSmallNeutronObjectWithMultipleParents',
125             nullable=True)
126     }
127 
128     synthetic_fields = ['children']
129 
130 
131 @obj_base.VersionedObjectRegistry.register_if(False)
132 class FakeWeirdKeySmallNeutronObject(base.NeutronDbObject):
133     # Version 1.0: Initial version
134     VERSION = '1.0'
135 
136     db_model = ObjectFieldsModel
137 
138     primary_keys = ['field1']
139 
140     foreign_keys = {
141         'FakeNeutronObjectNonStandardPrimaryKey': {'field1': 'weird_key'},
142         'FakeNeutronObjectCompositePrimaryKey': {'field2': 'weird_key'},
143     }
144 
145     fields = {
146         'field1': common_types.UUIDField(),
147         'field2': obj_fields.StringField(),
148     }
149 
150 
151 @obj_base.VersionedObjectRegistry.register_if(False)
152 class FakeNeutronDbObject(base.NeutronDbObject):
153     # Version 1.0: Initial version
154     VERSION = '1.0'
155 
156     db_model = FakeModel
157 
158     fields = {
159         'id': common_types.UUIDField(),
160         'field1': obj_fields.StringField(),
161         'obj_field': obj_fields.ObjectField('FakeSmallNeutronObject',
162                                             nullable=True)
163     }
164 
165     primary_keys = ['id']
166 
167     fields_no_update = ['field1']
168 
169     synthetic_fields = ['obj_field']
170 
171 
172 @obj_base.VersionedObjectRegistry.register_if(False)
173 class FakeNeutronObjectNonStandardPrimaryKey(base.NeutronDbObject):
174     # Version 1.0: Initial version
175     VERSION = '1.0'
176 
177     db_model = FakeModel
178 
179     primary_keys = ['weird_key']
180 
181     fields = {
182         'weird_key': common_types.UUIDField(),
183         'field1': obj_fields.StringField(),
184         'obj_field': obj_fields.ListOfObjectsField(
185             'FakeWeirdKeySmallNeutronObject'),
186         'field2': obj_fields.StringField()
187     }
188 
189     synthetic_fields = ['obj_field', 'field2']
190 
191 
192 @obj_base.VersionedObjectRegistry.register_if(False)
193 class FakeNeutronObjectCompositePrimaryKey(base.NeutronDbObject):
194     # Version 1.0: Initial version
195     VERSION = '1.0'
196 
197     db_model = FakeModel
198 
199     primary_keys = ['weird_key', 'field1']
200 
201     fields = {
202         'weird_key': common_types.UUIDField(),
203         'field1': obj_fields.StringField(),
204         'obj_field': obj_fields.ListOfObjectsField(
205             'FakeWeirdKeySmallNeutronObject')
206     }
207 
208     synthetic_fields = ['obj_field']
209 
210 
211 @obj_base.VersionedObjectRegistry.register_if(False)
212 class FakeNeutronObjectUniqueKey(base.NeutronDbObject):
213     # Version 1.0: Initial version
214     VERSION = '1.0'
215 
216     db_model = FakeModel
217 
218     primary_keys = ['id', 'id2']
219     unique_keys = [['unique_key'], ['id2']]
220 
221     fields = {
222         'id': common_types.UUIDField(),
223         'id2': common_types.UUIDField(),
224         'unique_key': obj_fields.StringField(),
225         'field1': obj_fields.StringField(),
226         'obj_field': obj_fields.ObjectField('FakeSmallNeutronObject',
227                                             nullable=True)
228     }
229 
230     synthetic_fields = ['obj_field']
231 
232 
233 @obj_base.VersionedObjectRegistry.register_if(False)
234 class FakeNeutronObjectRenamedField(base.NeutronDbObject):
235     """
236     Testing renaming the parameter from DB to NeutronDbObject
237     For tests:
238         - db fields: id, field_db, field2
239         - object: id, field_ovo, field2
240     """
241     # Version 1.0: Initial version
242     VERSION = '1.0'
243 
244     db_model = FakeModel
245 
246     primary_keys = ['id']
247 
248     fields = {
249         'id': common_types.UUIDField(),
250         'field_ovo': obj_fields.StringField(),
251         'field2': obj_fields.StringField()
252     }
253 
254     synthetic_fields = ['field2']
255 
256     fields_need_translation = {'field_ovo': 'field_db'}
257 
258 
259 @obj_base.VersionedObjectRegistry.register_if(False)
260 class FakeNeutronObjectCompositePrimaryKeyWithId(base.NeutronDbObject):
261     # Version 1.0: Initial version
262     VERSION = '1.0'
263 
264     db_model = FakeModel
265 
266     primary_keys = ['id', 'field1']
267 
268     fields = {
269         'id': common_types.UUIDField(),
270         'field1': obj_fields.StringField(),
271         'obj_field': obj_fields.ListOfObjectsField('FakeSmallNeutronObject')
272     }
273 
274     synthetic_fields = ['obj_field']
275 
276 
277 @obj_base.VersionedObjectRegistry.register_if(False)
278 class FakeNeutronObjectMultipleForeignKeys(base.NeutronDbObject):
279     # Version 1.0: Initial version
280     VERSION = '1.0'
281 
282     db_model = ObjectFieldsModel
283 
284     foreign_keys = {
285         'FakeNeutronObjectSyntheticField': {'field1': 'id', 'field2': 'id'},
286     }
287 
288     fields = {
289         'field1': common_types.UUIDField(),
290         'field2': common_types.UUIDField(),
291     }
292 
293 
294 @obj_base.VersionedObjectRegistry.register_if(False)
295 class FakeNeutronObjectSyntheticField(base.NeutronDbObject):
296     # Version 1.0: Initial version
297     VERSION = '1.0'
298 
299     db_model = FakeModel
300 
301     fields = {
302         'id': common_types.UUIDField(),
303         'obj_field': obj_fields.ListOfObjectsField(
304             'FakeNeutronObjectMultipleForeignKeys')
305     }
306 
307     synthetic_fields = ['obj_field']
308 
309 
310 @obj_base.VersionedObjectRegistry.register_if(False)
311 class FakeNeutronObjectSyntheticField2(base.NeutronDbObject):
312     # Version 1.0: Initial version
313     VERSION = '1.0'
314 
315     db_model = FakeModel
316 
317     fields = {
318         'id': common_types.UUIDField(),
319         'obj_field': obj_fields.ObjectField('FakeSmallNeutronObject')
320     }
321 
322     synthetic_fields = ['obj_field']
323 
324 
325 @obj_base.VersionedObjectRegistry.register_if(False)
326 class FakeNeutronObjectWithProjectId(base.NeutronDbObject):
327     # Version 1.0: Initial version
328     VERSION = '1.0'
329 
330     db_model = FakeModel
331 
332     fields = {
333         'id': common_types.UUIDField(),
334         'project_id': obj_fields.StringField(),
335         'field2': common_types.UUIDField(),
336     }
337 
338 
339 @obj_base.VersionedObjectRegistry.register_if(False)
340 class FakeNeutronObject(base.NeutronObject):
341     # Version 1.0: Initial version
342     VERSION = '1.0'
343 
344     fields = {
345         'id': common_types.UUIDField(),
346         'project_id': obj_fields.StringField(),
347         'field2': common_types.UUIDField(),
348     }
349 
350     @classmethod
351     def get_object(cls, context, **kwargs):
352         if not hasattr(cls, '_obj'):
353             cls._obj = FakeNeutronObject(id=uuidutils.generate_uuid(),
354                                          project_id='fake-id',
355                                          field2=uuidutils.generate_uuid())
356         return cls._obj
357 
358     @classmethod
359     def get_objects(cls, context, _pager=None, count=1, **kwargs):
360         return [
361             cls.get_object(context, **kwargs)
362             for i in range(count)
363         ]
364 
365 
366 @obj_base.VersionedObjectRegistry.register_if(False)
367 class FakeNeutronObjectDictOfMiscValues(base.NeutronDbObject):
368     # Version 1.0: Initial version
369     VERSION = '1.0'
370 
371     db_model = FakeModel
372 
373     fields = {
374         'id': common_types.UUIDField(),
375         'dict_field': common_types.DictOfMiscValuesField(),
376     }
377 
378 
379 @obj_base.VersionedObjectRegistry.register_if(False)
380 class FakeNeutronObjectListOfDictOfMiscValues(base.NeutronDbObject):
381     # Version 1.0: Initial version
382     VERSION = '1.0'
383 
384     db_model = FakeModel
385 
386     fields = {
387         'id': common_types.UUIDField(),
388         'list_of_dicts_field': common_types.ListOfDictOfMiscValuesField(),
389     }
390 
391 
392 def get_random_dscp_mark():
393     return random.choice(constants.VALID_DSCP_MARKS)
394 
395 
396 def get_list_of_random_networks(num=10):
397     for i in range(5):
398         res = [tools.get_random_ip_network() for i in range(num)]
399         # make sure there are no duplicates
400         if len(set(res)) == num:
401             return res
402     raise Exception('Failed to generate unique networks')
403 
404 
405 def get_random_domain_name():
406     return '.'.join([
407         helpers.get_random_string(62)[:random.choice(range(63))]
408         for i in range(4)
409     ])
410 
411 
412 def get_random_dict_of_strings():
413     return {
414         helpers.get_random_string(10): helpers.get_random_string(10)
415         for i in range(10)
416     }
417 
418 
419 def get_random_dict():
420     return {
421         helpers.get_random_string(6): helpers.get_random_string(6),
422         helpers.get_random_string(6): tools.get_random_boolean(),
423         helpers.get_random_string(6): tools.get_random_integer(),
424         helpers.get_random_string(6): [
425             tools.get_random_integer(),
426             helpers.get_random_string(6),
427             tools.get_random_boolean(),
428         ],
429         helpers.get_random_string(6): {
430             helpers.get_random_string(6): helpers.get_random_string(6)
431         }
432     }
433 
434 
435 def get_random_dicts_list():
436     return [get_random_dict() for _ in range(5)]
437 
438 
439 def get_set_of_random_uuids():
440     return {
441         uuidutils.generate_uuid()
442         for i in range(10)
443     }
444 
445 
446 # NOTE: The keys in this dictionary have alphabetic order.
447 FIELD_TYPE_VALUE_GENERATOR_MAP = {
448     common_types.DictOfMiscValuesField: get_random_dict,
449     common_types.ListOfDictOfMiscValuesField: get_random_dicts_list,
450     common_types.DomainNameField: get_random_domain_name,
451     common_types.DscpMarkField: get_random_dscp_mark,
452     common_types.EtherTypeEnumField: tools.get_random_ether_type,
453     common_types.FlowDirectionEnumField: tools.get_random_flow_direction,
454     common_types.IpamAllocationStatusEnumField: tools.get_random_ipam_status,
455     common_types.IPNetworkField: tools.get_random_ip_network,
456     common_types.IPNetworkPrefixLenField: tools.get_random_prefixlen,
457     common_types.IPV6ModeEnumField: tools.get_random_ipv6_mode,
458     common_types.IPVersionEnumField: tools.get_random_ip_version,
459     common_types.IpProtocolEnumField: tools.get_random_ip_protocol,
460     common_types.ListOfIPNetworksField: get_list_of_random_networks,
461     common_types.MACAddressField: tools.get_random_EUI,
462     common_types.PortBindingStatusEnumField:
463         tools.get_random_port_binding_statuses,
464     common_types.PortRangeField: tools.get_random_port,
465     common_types.PortRangeWith0Field: lambda: tools.get_random_port(0),
466     common_types.SetOfUUIDsField: get_set_of_random_uuids,
467     common_types.UUIDField: uuidutils.generate_uuid,
468     common_types.VlanIdRangeField: tools.get_random_vlan,
469     event_types.SecurityEventField: tools.get_random_security_event,
470     obj_fields.BooleanField: tools.get_random_boolean,
471     obj_fields.DateTimeField: tools.get_random_datetime,
472     obj_fields.DictOfStringsField: get_random_dict_of_strings,
473     obj_fields.IPAddressField: tools.get_random_ip_address,
474     obj_fields.IntegerField: tools.get_random_integer,
475     obj_fields.ListOfObjectsField: lambda: [],
476     obj_fields.ListOfStringsField: tools.get_random_string_list,
477     obj_fields.ObjectField: lambda: None,
478     obj_fields.StringField: lambda: helpers.get_random_string(10),
479 }
480 
481 
482 def get_obj_persistent_fields(obj):
483     return {field: getattr(obj, field) for field in obj.fields
484             if field not in obj.synthetic_fields
485             if field in obj}
486 
487 
488 def get_value(generator, version):
489     if 'version' in generator.__code__.co_varnames:
490         return generator(version=version)
491     return generator()
492 
493 
494 def remove_timestamps_from_fields(obj_fields, cls_fields):
495     obj_fields_result = obj_fields.copy()
496     for ts_field in TIMESTAMP_FIELDS:
497         if ts_field in cls_fields.keys() and cls_fields[ts_field].nullable:
498             obj_fields_result.pop(ts_field)
499     return obj_fields_result
500 
501 
502 def get_non_synthetic_fields(objclass, obj_fields):
503     return {field: value for field, value in obj_fields.items()
504             if not objclass.is_synthetic(field)}
505 
506 
507 class _BaseObjectTestCase(object):
508 
509     _test_class = FakeNeutronDbObject
510 
511     CORE_PLUGIN = 'neutron.db.db_base_plugin_v2.NeutronDbPluginV2'
512 
513     def setUp(self):
514         super(_BaseObjectTestCase, self).setUp()
515         # TODO(ihrachys): revisit plugin setup once we decouple
516         # neutron.objects.db.api from core plugin instance
517         self.setup_coreplugin(self.CORE_PLUGIN)
518         # make sure all objects are loaded and registered in the registry
519         objects.register_objects()
520         self.context = context.get_admin_context()
521         self._unique_tracker = collections.defaultdict(set)
522         self.db_objs = [
523             self._test_class.db_model(**self.get_random_db_fields())
524             for _ in range(3)
525         ]
526 
527         # TODO(ihrachys) remove obj_fields since they duplicate self.objs
528         self.obj_fields = [self._test_class.modify_fields_from_db(db_obj)
529                            for db_obj in self.db_objs]
530         self.objs = [
531             self._test_class(self.context, **fields)
532             for fields in self.obj_fields
533         ]
534 
535         invalid_fields = (
536             set(self._test_class.synthetic_fields).union(set(TIMESTAMP_FIELDS))
537         )
538         valid_field = [f for f in self._test_class.fields
539                        if f not in invalid_fields][0]
540         self.valid_field_filter = {valid_field:
541                                    self.obj_fields[-1][valid_field]}
542         self.obj_registry = self.useFixture(
543             fixture.VersionedObjectRegistryFixture())
544         self.obj_registry.register(FakeSmallNeutronObject)
545         self.obj_registry.register(FakeWeirdKeySmallNeutronObject)
546         self.obj_registry.register(FakeNeutronObjectMultipleForeignKeys)
547         synthetic_obj_fields = self.get_random_db_fields(
548             FakeSmallNeutronObject)
549         self.model_map = {
550             self._test_class.db_model: self.db_objs,
551             ObjectFieldsModel: [ObjectFieldsModel(**synthetic_obj_fields)]}
552 
553     def _get_random_update_fields(self):
554         return self.get_updatable_fields(
555             self.get_random_object_fields(self._test_class))
556 
557     def get_random_object_fields(self, obj_cls=None):
558         obj_cls = obj_cls or self._test_class
559         fields = {}
560         ip_version = tools.get_random_ip_version()
561         for field, field_obj in obj_cls.fields.items():
562             if field not in obj_cls.synthetic_fields:
563                 generator = FIELD_TYPE_VALUE_GENERATOR_MAP[type(field_obj)]
564                 fields[field] = get_value(generator, ip_version)
565         for keys in obj_cls.unique_keys:
566             keytup = tuple(keys)
567             unique_values = tuple(fields[k] for k in keytup)
568             if unique_values in self._unique_tracker[keytup]:
569                 # if you get a recursion depth error here, it means
570                 # your random generator didn't generate unique values
571                 return self.get_random_object_fields(obj_cls)
572             self._unique_tracker[keytup].add(unique_values)
573         return fields
574 
575     def get_random_db_fields(self, obj_cls=None):
576         obj_cls = obj_cls or self._test_class
577         return obj_cls.modify_fields_to_db(
578             self.get_random_object_fields(obj_cls))
579 
580     def update_obj_fields(self, values_dict,
581                           db_objs=None, obj_fields=None, objs=None):
582         '''Update values for test objects with specific values.
583 
584         The default behaviour is using random values for all fields of test
585         objects. Sometimes it's not practical, for example, when some fields,
586         often those referencing other objects, require non-random values (None
587         or UUIDs of valid objects). If that's the case, a test subclass may
588         call the method to override some field values for test objects.
589 
590         Receives a single ``values_dict`` dict argument where keys are names of
591         test class fields, and values are either actual values for the keys, or
592         callables that will be used to generate different values for each test
593         object.
594 
595         Note: if a value is a dict itself, the method will recursively update
596         corresponding embedded objects.
597         '''
598         for k, v in values_dict.items():
599             for db_obj, fields, obj in zip(
600                     db_objs or self.db_objs,
601                     obj_fields or self.obj_fields,
602                     objs or self.objs):
603                 val = v() if callable(v) else v
604                 db_obj_key = obj.fields_need_translation.get(k, k)
605                 if isinstance(val, collections.Mapping):
606                     self.update_obj_fields(
607                         val, db_obj[db_obj_key], fields[k], obj[k])
608                 else:
609                     db_obj[db_obj_key] = val
610                     fields[k] = val
611                     obj[k] = val
612                 for keys in self._test_class.unique_keys:
613                     keytup = tuple(keys)
614                     unique_values = tuple(fields[k] for k in keytup)
615                     if unique_values in self._unique_tracker[keytup]:
616                         return self.update_obj_fields(values_dict)
617             if k in self.valid_field_filter:
618                 self.valid_field_filter[k] = val
619 
620     @classmethod
621     def generate_object_keys(cls, obj_cls, field_names=None):
622         if field_names is None:
623             field_names = obj_cls.primary_keys
624         keys = {}
625         for field in field_names:
626             field_obj = obj_cls.fields[field]
627             generator = FIELD_TYPE_VALUE_GENERATOR_MAP[type(field_obj)]
628             keys[field] = generator()
629         return keys
630 
631     def get_updatable_fields(self, fields):
632         return base.get_updatable_fields(self._test_class, fields)
633 
634     @classmethod
635     def _is_test_class(cls, obj):
636         return isinstance(obj, cls._test_class)
637 
638     def fake_get_objects(self, context, model, **kwargs):
639         return self.model_map[model]
640 
641     def _get_object_synthetic_fields(self, objclass):
642         return [field for field in objclass.synthetic_fields
643                 if objclass.is_object_field(field)]
644 
645     def _get_ovo_object_class(self, objclass, field):
646         try:
647             name = objclass.fields[field].objname
648             return obj_base.VersionedObjectRegistry.obj_classes().get(name)[0]
649         except TypeError:
650             # NOTE(korzen) some synthetic fields are not handled by
651             # this method, for example the ones that have subclasses, see
652             # QosRule
653             return
654 
655 
656 class BaseObjectIfaceTestCase(_BaseObjectTestCase, test_base.BaseTestCase):
657 
658     def setUp(self):
659         super(BaseObjectIfaceTestCase, self).setUp()
660         self.model_map = collections.defaultdict(list)
661         self.model_map[self._test_class.db_model] = self.db_objs
662         self.pager_map = collections.defaultdict(lambda: None)
663         # don't validate refresh and expunge in tests that don't touch database
664         # because otherwise it will fail due to db models not being injected
665         # into active session in the first place
666         mock.patch.object(self.context.session, 'refresh').start()
667         mock.patch.object(self.context.session, 'expunge').start()
668 
669         self.get_objects_mock = mock.patch.object(
670             obj_db_api, 'get_objects',
671             side_effect=self.fake_get_objects).start()
672 
673         self.get_object_mock = mock.patch.object(
674             obj_db_api, 'get_object',
675             side_effect=self.fake_get_object).start()
676 
677         # NOTE(ihrachys): for matters of basic object behaviour validation,
678         # mock out rbac code accessing database. There are separate tests that
679         # cover RBAC, per object type.
680         if getattr(self._test_class, 'rbac_db_model', None):
681             mock.patch.object(
682                 rbac_db.RbacNeutronDbObjectMixin,
683                 'is_shared_with_tenant', return_value=False).start()
684             mock.patch.object(
685                 rbac_db.RbacNeutronDbObjectMixin,
686                 'get_shared_with_tenant').start()
687 
688     def fake_get_object(self, context, model, **kwargs):
689         objs = self.model_map[model]
690         if not objs:
691             return None
692         return [obj for obj in objs if obj['id'] == kwargs['id']][0]
693 
694     def fake_get_objects(self, context, model, **kwargs):
695         return self.model_map[model]
696 
697     # TODO(ihrachys) document the intent of all common test cases in docstrings
698     def test_get_object(self):
699         with mock.patch.object(
700                 obj_db_api, 'get_object',
701                 return_value=self.db_objs[0]) as get_object_mock:
702             with mock.patch.object(obj_db_api, 'get_objects',
703                                    side_effect=self.fake_get_objects):
704                 obj_keys = self.generate_object_keys(self._test_class)
705                 obj = self._test_class.get_object(self.context, **obj_keys)
706                 self.assertTrue(self._is_test_class(obj))
707                 self._check_equal(self.objs[0], obj)
708                 get_object_mock.assert_called_once_with(
709                     self.context, self._test_class.db_model,
710                     **self._test_class.modify_fields_to_db(obj_keys))
711 
712     def test_get_object_missing_object(self):
713         with mock.patch.object(obj_db_api, 'get_object', return_value=None):
714             obj_keys = self.generate_object_keys(self._test_class)
715             obj = self._test_class.get_object(self.context, **obj_keys)
716             self.assertIsNone(obj)
717 
718     def test_get_object_missing_primary_key(self):
719         non_unique_fields = (set(self._test_class.fields.keys()) -
720                              set(self._test_class.primary_keys) -
721                              set(itertools.chain.from_iterable(
722                                  self._test_class.unique_keys)))
723         obj_keys = self.generate_object_keys(self._test_class,
724                                              non_unique_fields)
725         self.assertRaises(o_exc.NeutronPrimaryKeyMissing,
726                           self._test_class.get_object,
727                           self.context, **obj_keys)
728 
729     def test_get_object_unique_key(self):
730         if not self._test_class.unique_keys:
731             self.skipTest('No unique keys found in test class %r' %
732                           self._test_class)
733 
734         for unique_keys in self._test_class.unique_keys:
735             with mock.patch.object(obj_db_api, 'get_object',
736                                    return_value=self.db_objs[0]) \
737                     as get_object_mock:
738                 with mock.patch.object(obj_db_api, 'get_objects',
739                                        side_effect=self.fake_get_objects):
740                     obj_keys = self.generate_object_keys(self._test_class,
741                                                          unique_keys)
742                     obj = self._test_class.get_object(self.context,
743                                                       **obj_keys)
744                     self.assertTrue(self._is_test_class(obj))
745                     self._check_equal(self.objs[0], obj)
746                     get_object_mock.assert_called_once_with(
747                         mock.ANY, self._test_class.db_model,
748                         **self._test_class.modify_fields_to_db(obj_keys))
749 
750     def _get_synthetic_fields_get_objects_calls(self, db_objs):
751         mock_calls = []
752         for db_obj in db_objs:
753             for field in self._test_class.synthetic_fields:
754                 if self._test_class.is_object_field(field):
755                     obj_class = self._get_ovo_object_class(self._test_class,
756                                                            field)
757                     filter_kwargs = {
758                         obj_class.fields_need_translation.get(k, k): db_obj[v]
759                         for k, v in obj_class.foreign_keys.get(
760                             self._test_class.__name__).items()
761                     }
762                     mock_calls.append(
763                         mock.call(
764                             self.context, obj_class.db_model,
765                             _pager=self.pager_map[obj_class.obj_name()],
766                             **filter_kwargs))
767         return mock_calls
768 
769     def test_get_objects(self):
770         '''Test that get_objects fetches data from database.'''
771         with mock.patch.object(
772                 obj_db_api, 'get_objects',
773                 side_effect=self.fake_get_objects) as get_objects_mock:
774             objs = self._test_class.get_objects(self.context)
775             self.assertItemsEqual(
776                 [get_obj_persistent_fields(obj) for obj in self.objs],
777                 [get_obj_persistent_fields(obj) for obj in objs])
778         get_objects_mock.assert_any_call(
779             self.context, self._test_class.db_model,
780             _pager=self.pager_map[self._test_class.obj_name()]
781         )
782 
783     def test_get_objects_valid_fields(self):
784         '''Test that a valid filter does not raise an error.'''
785         with mock.patch.object(
786                 obj_db_api, 'get_objects', side_effect=self.fake_get_objects):
787             self._test_class.get_objects(self.context,
788                                          **self.valid_field_filter)
789 
790     def test_get_objects_mixed_fields(self):
791         synthetic_fields = (
792             set(self._test_class.synthetic_fields) -
793             self._test_class.extra_filter_names
794         )
795         if not synthetic_fields:
796             self.skipTest('No synthetic fields that are not extra filters '
797                           'found in test class %r' %
798                           self._test_class)
799 
800         filters = copy.copy(self.valid_field_filter)
801         filters[synthetic_fields.pop()] = 'xxx'
802 
803         with mock.patch.object(obj_db_api, 'get_objects',
804                                return_value=self.db_objs):
805             self.assertRaises(n_exc.InvalidInput,
806                               self._test_class.get_objects, self.context,
807                               **filters)
808 
809     def test_get_objects_synthetic_fields_not_extra_filters(self):
810         synthetic_fields = (
811             set(self._test_class.synthetic_fields) -
812             self._test_class.extra_filter_names
813         )
814         if not synthetic_fields:
815             self.skipTest('No synthetic fields that are not extra filters '
816                           'found in test class %r' %
817                           self._test_class)
818 
819         with mock.patch.object(obj_db_api, 'get_objects',
820                                side_effect=self.fake_get_objects):
821             self.assertRaises(n_exc.InvalidInput,
822                               self._test_class.get_objects, self.context,
823                               **{synthetic_fields.pop(): 'xxx'})
824 
825     def test_get_objects_invalid_fields(self):
826         with mock.patch.object(obj_db_api, 'get_objects',
827                                side_effect=self.fake_get_objects):
828             self.assertRaises(n_exc.InvalidInput,
829                               self._test_class.get_objects, self.context,
830                               fake_field='xxx')
831 
832     def test_get_objects_without_validate_filters(self):
833         with mock.patch.object(
834                 obj_db_api, 'get_objects',
835                 side_effect=self.fake_get_objects):
836             objs = self._test_class.get_objects(self.context,
837                                                 validate_filters=False,
838                                                 unknown_filter='value')
839             self.assertItemsEqual(
840                 [get_obj_persistent_fields(obj) for obj in self.objs],
841                 [get_obj_persistent_fields(obj) for obj in objs])
842 
843     @mock.patch.object(obj_db_api, 'update_object', return_value={})
844     @mock.patch.object(obj_db_api, 'update_objects', return_value=0)
845     def test_update_objects_valid_fields(self, *mocks):
846         '''Test that a valid filter does not raise an error.'''
847         self._test_class.update_objects(
848             self.context, {},
849             **self.valid_field_filter)
850 
851     def test_update_objects_invalid_fields(self):
852         with mock.patch.object(obj_db_api, 'update_objects'):
853             self.assertRaises(n_exc.InvalidInput,
854                               self._test_class.update_objects,
855                               self.context, {}, fake_field='xxx')
856 
857     @mock.patch.object(obj_db_api, 'update_objects')
858     @mock.patch.object(obj_db_api, 'update_object', return_value={})
859     def test_update_objects_without_validate_filters(self, *mocks):
860             self._test_class.update_objects(
861                 self.context, {'unknown_filter': 'new_value'},
862                 validate_filters=False, unknown_filter='value')
863 
864     def _prep_string_field(self):
865         self.filter_string_field = None
866         # find the first string field to use as string matching filter
867         for field in self.obj_fields[0]:
868             if isinstance(field, obj_fields.StringField):
869                 self.filter_string_field = field
870                 break
871 
872         if self.filter_string_field is None:
873             self.skipTest('There is no string field in this object')
874 
875     def test_get_objects_with_string_matching_filters_contains(self):
876         self._prep_string_field()
877 
878         filter_dict_contains = {
879             self.filter_string_field: obj_utils.StringContains(
880                 "random_thing")}
881 
882         with mock.patch.object(
883                 obj_db_api, 'get_objects',
884                 side_effect=self.fake_get_objects):
885             res = self._test_class.get_objects(self.context,
886                                                **filter_dict_contains)
887             self.assertEqual([], res)
888 
889     def test_get_objects_with_string_matching_filters_starts(self):
890         self._prep_string_field()
891 
892         filter_dict_starts = {
893             self.filter_string_field: obj_utils.StringStarts(
894                 "random_thing")
895         }
896 
897         with mock.patch.object(
898                 obj_db_api, 'get_objects',
899                 side_effect=self.fake_get_objects):
900             res = self._test_class.get_objects(self.context,
901                                                **filter_dict_starts)
902             self.assertEqual([], res)
903 
904     def test_get_objects_with_string_matching_filters_ends(self):
905         self._prep_string_field()
906 
907         filter_dict_ends = {
908             self.filter_string_field: obj_utils.StringEnds(
909                 "random_thing")
910         }
911 
912         with mock.patch.object(
913                 obj_db_api, 'get_objects',
914                 side_effect=self.fake_get_objects):
915             res = self._test_class.get_objects(self.context,
916                                                **filter_dict_ends)
917             self.assertEqual([], res)
918 
919     def test_delete_objects(self):
920         '''Test that delete_objects calls to underlying db_api.'''
921         with mock.patch.object(
922                 obj_db_api, 'delete_objects', return_value=0
923         ) as delete_objects_mock:
924             self.assertEqual(0, self._test_class.delete_objects(self.context))
925         delete_objects_mock.assert_any_call(
926             self.context, self._test_class.db_model)
927 
928     def test_delete_objects_valid_fields(self):
929         '''Test that a valid filter does not raise an error.'''
930         with mock.patch.object(obj_db_api, 'delete_objects', return_value=0):
931             self._test_class.delete_objects(self.context,
932                                             **self.valid_field_filter)
933 
934     def test_delete_objects_invalid_fields(self):
935         with mock.patch.object(obj_db_api, 'delete_objects'):
936             self.assertRaises(n_exc.InvalidInput,
937                               self._test_class.delete_objects, self.context,
938                               fake_field='xxx')
939 
940     def test_delete_objects_without_validate_filters(self):
941         with mock.patch.object(
942                 obj_db_api, 'delete_objects'):
943             self._test_class.delete_objects(self.context,
944                                             validate_filters=False,
945                                             unknown_filter='value')
946 
947     def test_count(self):
948         if not isinstance(self._test_class, base.NeutronDbObject):
949             self.skipTest('Class %s does not inherit from NeutronDbObject' %
950                           self._test_class)
951         expected = 10
952         with mock.patch.object(obj_db_api, 'count', return_value=expected):
953             self.assertEqual(expected, self._test_class.count(self.context))
954 
955     def test_count_invalid_fields(self):
956             self.assertRaises(n_exc.InvalidInput,
957                               self._test_class.count, self.context,
958                               fake_field='xxx')
959 
960     def _check_equal(self, expected, observed):
961         self.assertItemsEqual(get_obj_persistent_fields(expected),
962                               get_obj_persistent_fields(observed))
963 
964     def test_count_validate_filters_false(self):
965         if not isinstance(self._test_class, base.NeutronDbObject):
966             self.skipTest('Class %s does not inherit from NeutronDbObject' %
967                           self._test_class)
968         expected = 10
969         with mock.patch.object(obj_db_api, 'count', return_value=expected):
970             self.assertEqual(expected, self._test_class.count(self.context,
971                 validate_filters=False, fake_field='xxx'))
972 
973     # Adding delete_objects mock because some objects are using delete_objects
974     # while calling create(), Port for example
975     @mock.patch.object(obj_db_api, 'delete_objects')
976     def test_create(self, *mocks):
977         with mock.patch.object(obj_db_api, 'create_object',
978                                return_value=self.db_objs[0]) as create_mock:
979             with mock.patch.object(obj_db_api, 'get_objects',
980                   side_effect=self.fake_get_objects):
981                 obj = self._test_class(self.context, **self.obj_fields[0])
982                 self._check_equal(self.objs[0], obj)
983                 obj.create()
984                 self._check_equal(self.objs[0], obj)
985                 create_mock.assert_called_once_with(
986                     self.context, self._test_class.db_model,
987                     self._test_class.modify_fields_to_db(
988                         get_obj_persistent_fields(self.objs[0])))
989 
990     # Adding delete_objects mock because some objects are using delete_objects
991     # while calling create(), Port for example
992     @mock.patch.object(obj_db_api, 'delete_objects')
993     def test_create_updates_from_db_object(self, *mocks):
994         with mock.patch.object(obj_db_api, 'create_object',
995                                return_value=self.db_objs[0]):
996             with mock.patch.object(obj_db_api, 'get_objects',
997                   side_effect=self.fake_get_objects):
998                 self.objs[1].create()
999                 self._check_equal(self.objs[0], self.objs[1])
1000 
1001     # Adding delete_objects mock because some objects are using delete_objects
1002     # while calling create(), Port for example
1003     @mock.patch.object(obj_db_api, 'delete_objects')
1004     def test_create_duplicates(self, delete_object):
1005         with mock.patch.object(obj_db_api, 'create_object',
1006                                side_effect=obj_exc.DBDuplicateEntry):
1007             obj = self._test_class(self.context, **self.obj_fields[0])
1008             self.assertRaises(o_exc.NeutronDbObjectDuplicateEntry, obj.create)
1009 
1010     def test_update_fields(self):
1011         if not self._test_class.primary_keys:
1012             self.skipTest(
1013                 'Test class %r has no primary keys' % self._test_class)
1014 
1015         with mock.patch.object(obj_base.VersionedObject, 'obj_reset_changes'):
1016             expected = self._test_class(self.context, **self.obj_fields[0])
1017             for key, val in self.obj_fields[1].items():
1018                 if key not in expected.fields_no_update:
1019                     setattr(expected, key, val)
1020             observed = self._test_class(self.context, **self.obj_fields[0])
1021             observed.update_fields(self.obj_fields[1], reset_changes=True)
1022             self.assertEqual(expected, observed)
1023             self.assertTrue(observed.obj_reset_changes.called)
1024 
1025         with mock.patch.object(obj_base.VersionedObject, 'obj_reset_changes'):
1026             obj = self._test_class(self.context, **self.obj_fields[0])
1027             obj.update_fields(self.obj_fields[1])
1028             self.assertFalse(obj.obj_reset_changes.called)
1029 
1030     def test_extra_fields(self):
1031         if not len(self._test_class.obj_extra_fields):
1032             self.skipTest(
1033                 'Test class %r has no obj_extra_fields' % self._test_class)
1034         obj = self._test_class(self.context, **self.obj_fields[0])
1035         for field in self._test_class.obj_extra_fields:
1036             # field is accessible and cannot be set by any value
1037             getattr(obj, field)
1038             self.assertIn(field, obj.to_dict().keys())
1039             self.assertRaises(AttributeError, setattr, obj, field, "1")
1040 
1041     def test_to_dict_makes_primitive_field_value(self):
1042         obj = self._test_class(self.context, **self.obj_fields[0])
1043         dict_ = obj.to_dict()
1044         for k, v in dict_.items():
1045             if k not in obj.fields:
1046                 continue
1047             field = obj.fields[k]
1048             self.assertEqual(v, field.to_primitive(obj, k, getattr(obj, k)))
1049 
1050     def test_to_dict_with_unset_project_id(self):
1051         if 'project_id' not in self._test_class.fields:
1052             self.skipTest(
1053                 'Test class %r has no project_id in fields' % self._test_class)
1054         obj_data = copy.copy(self.obj_fields[0])
1055         obj_data.pop('project_id')
1056         obj = self._test_class(self.context, **obj_data)
1057         dict_ = obj.to_dict()
1058 
1059         self.assertNotIn('project_id', dict_)
1060         self.assertNotIn('tenant_id', dict_)
1061 
1062     def test_fields_no_update(self):
1063         obj = self._test_class(self.context, **self.obj_fields[0])
1064         for field in self._test_class.fields_no_update:
1065             self.assertTrue(hasattr(obj, field))
1066 
1067     def test_get_tenant_id(self):
1068         if not hasattr(self._test_class, 'project_id'):
1069             self.skipTest(
1070                 'Test class %r has no project_id field' % self._test_class)
1071         obj = self._test_class(self.context, **self.obj_fields[0])
1072         project_id = self.obj_fields[0]['project_id']
1073         self.assertEqual(project_id, obj.tenant_id)
1074 
1075     # Adding delete_objects mock because some objects are using delete_objects
1076     # while calling update(), Port for example
1077     @mock.patch.object(obj_db_api, 'delete_objects')
1078     @mock.patch.object(obj_db_api, 'update_object')
1079     def test_update_changes(self, update_mock, del_mock):
1080         fields_to_update = self.get_updatable_fields(
1081             self._test_class.modify_fields_from_db(self.db_objs[0]))
1082         if not fields_to_update:
1083             self.skipTest('No updatable fields found in test class %r' %
1084                           self._test_class)
1085 
1086         with mock.patch.object(base.NeutronDbObject,
1087                                '_get_changed_persistent_fields',
1088                                return_value=fields_to_update):
1089             with mock.patch.object(obj_db_api, 'get_objects',
1090                 side_effect=self.fake_get_objects):
1091                 obj = self._test_class(self.context, **self.obj_fields[0])
1092                 # get new values and fix keys
1093                 update_mock.return_value = self.db_objs[1]
1094                 fixed_keys = self._test_class.modify_fields_to_db(
1095                     obj._get_composite_keys())
1096                 for key, value in fixed_keys.items():
1097                     update_mock.return_value[key] = value
1098                 obj.update()
1099                 update_mock.assert_called_once_with(
1100                     self.context, self._test_class.db_model,
1101                     self._test_class.modify_fields_to_db(fields_to_update),
1102                     **fixed_keys)
1103 
1104     @mock.patch.object(base.NeutronDbObject,
1105                        '_get_changed_persistent_fields',
1106                        return_value={'a': 'a', 'b': 'b', 'c': 'c'})
1107     def test_update_changes_forbidden(self, *mocks):
1108         with mock.patch.object(
1109             self._test_class,
1110             'fields_no_update',
1111             new_callable=mock.PropertyMock(return_value=['a', 'c']),
1112             create=True):
1113             obj = self._test_class(self.context, **self.obj_fields[0])
1114             self.assertRaises(o_exc.NeutronObjectUpdateForbidden, obj.update)
1115 
1116     # Adding delete_objects mock because some objects are using delete_objects
1117     # while calling update(), Port and Network for example
1118     @mock.patch.object(obj_db_api, 'delete_objects')
1119     def test_update_updates_from_db_object(self, *mocks):
1120         with mock.patch.object(obj_db_api, 'update_object',
1121                                return_value=self.db_objs[0]):
1122             with mock.patch.object(obj_db_api, 'get_objects',
1123                   side_effect=self.fake_get_objects):
1124                 obj = self._test_class(self.context, **self.obj_fields[1])
1125                 fields_to_update = self.get_updatable_fields(
1126                     self.obj_fields[1])
1127                 if not fields_to_update:
1128                     self.skipTest('No updatable fields found in test '
1129                                   'class %r' % self._test_class)
1130                 with mock.patch.object(base.NeutronDbObject,
1131                                        '_get_changed_persistent_fields',
1132                                        return_value=fields_to_update):
1133                     with mock.patch.object(
1134                         obj_db_api, 'get_objects',
1135                         side_effect=self.fake_get_objects):
1136                         obj.update()
1137                 self._check_equal(self.objs[0], obj)
1138 
1139     @mock.patch.object(obj_db_api, 'delete_object')
1140     def test_delete(self, delete_mock):
1141         obj = self._test_class(self.context, **self.obj_fields[0])
1142         self._check_equal(self.objs[0], obj)
1143         obj.delete()
1144         self._check_equal(self.objs[0], obj)
1145         delete_mock.assert_called_once_with(
1146             self.context, self._test_class.db_model,
1147             **self._test_class.modify_fields_to_db(obj._get_composite_keys()))
1148 
1149     @mock.patch(OBJECTS_BASE_OBJ_FROM_PRIMITIVE)
1150     def test_clean_obj_from_primitive(self, get_prim_m):
1151         expected_obj = get_prim_m.return_value
1152         observed_obj = self._test_class.clean_obj_from_primitive('foo', 'bar')
1153         self.assertIs(expected_obj, observed_obj)
1154         self.assertTrue(observed_obj.obj_reset_changes.called)
1155 
1156     def test_update_primary_key_forbidden_fail(self):
1157         obj = self._test_class(self.context, **self.obj_fields[0])
1158         obj.obj_reset_changes()
1159 
1160         if not self._test_class.primary_keys:
1161             self.skipTest(
1162                 'All non-updatable fields found in test class %r '
1163                 'are primary keys' % self._test_class)
1164 
1165         for key, val in self.obj_fields[0].items():
1166             if key in self._test_class.primary_keys:
1167                 setattr(obj, key, val)
1168 
1169         self.assertRaises(o_exc.NeutronObjectUpdateForbidden, obj.update)
1170 
1171     def test_to_dict_synthetic_fields(self):
1172         cls_ = self._test_class
1173         object_fields = self._get_object_synthetic_fields(cls_)
1174         if not object_fields:
1175             self.skipTest(
1176                 'No object fields found in test class %r' % cls_)
1177 
1178         for field in object_fields:
1179             obj = cls_(self.context, **self.obj_fields[0])
1180             objclass = self._get_ovo_object_class(cls_, field)
1181             if not objclass:
1182                 continue
1183 
1184             child = objclass(
1185                 self.context, **objclass.modify_fields_from_db(
1186                     self.get_random_db_fields(obj_cls=objclass))
1187             )
1188             child_dict = child.to_dict()
1189             if isinstance(cls_.fields[field], obj_fields.ListOfObjectsField):
1190                 setattr(obj, field, [child])
1191                 dict_ = obj.to_dict()
1192                 self.assertEqual([child_dict], dict_[field])
1193             else:
1194                 setattr(obj, field, child)
1195                 dict_ = obj.to_dict()
1196                 self.assertEqual(child_dict, dict_[field])
1197 
1198     def test_get_objects_pager_is_passed_through(self):
1199         with mock.patch.object(obj_db_api, 'get_objects') as get_objects:
1200             pager = base.Pager()
1201             self._test_class.get_objects(self.context, _pager=pager)
1202             get_objects.assert_called_once_with(
1203                 mock.ANY, self._test_class.db_model, _pager=pager)
1204 
1205 
1206 class BaseDbObjectNonStandardPrimaryKeyTestCase(BaseObjectIfaceTestCase):
1207 
1208     _test_class = FakeNeutronObjectNonStandardPrimaryKey
1209 
1210 
1211 class BaseDbObjectCompositePrimaryKeyTestCase(BaseObjectIfaceTestCase):
1212 
1213     _test_class = FakeNeutronObjectCompositePrimaryKey
1214 
1215 
1216 class BaseDbObjectUniqueKeysTestCase(BaseObjectIfaceTestCase):
1217 
1218     _test_class = FakeNeutronObjectUniqueKey
1219 
1220 
1221 class UniqueKeysTestCase(test_base.BaseTestCase):
1222 
1223     def test_class_creation(self):
1224         m_get_unique_keys = mock.patch.object(db_utils, 'get_unique_keys')
1225         with m_get_unique_keys as get_unique_keys:
1226             get_unique_keys.return_value = [['field1'],
1227                                             ['field2', 'db_field3']]
1228 
1229             @obj_base.VersionedObjectRegistry.register_if(False)
1230             class UniqueKeysTestObject(base.NeutronDbObject):
1231                 # Version 1.0: Initial version
1232                 VERSION = '1.0'
1233 
1234                 db_model = FakeModel
1235 
1236                 primary_keys = ['id']
1237 
1238                 fields = {
1239                     'id': common_types.UUIDField(),
1240                     'field1': common_types.UUIDField(),
1241                     'field2': common_types.UUIDField(),
1242                     'field3': common_types.UUIDField(),
1243                 }
1244 
1245                 fields_need_translation = {'field3': 'db_field3'}
1246         expected = {('field1',), ('field2', 'field3')}
1247         observed = {tuple(sorted(key))
1248                     for key in UniqueKeysTestObject.unique_keys}
1249         self.assertEqual(expected, observed)
1250 
1251 
1252 class NeutronObjectCountTestCase(test_base.BaseTestCase):
1253 
1254     def test_count(self):
1255         expected = 10
1256         self.assertEqual(
1257             expected, FakeNeutronObject.count(None, count=expected))
1258 
1259 
1260 class BaseDbObjectCompositePrimaryKeyWithIdTestCase(BaseObjectIfaceTestCase):
1261 
1262     _test_class = FakeNeutronObjectCompositePrimaryKeyWithId
1263 
1264 
1265 class BaseDbObjectRenamedFieldTestCase(BaseObjectIfaceTestCase):
1266 
1267     _test_class = FakeNeutronObjectRenamedField
1268 
1269 
1270 class BaseObjectIfaceWithProjectIdTestCase(BaseObjectIfaceTestCase):
1271 
1272     _test_class = FakeNeutronObjectWithProjectId
1273 
1274     def test_update_fields_using_tenant_id(self):
1275         obj = self._test_class(self.context, **self.obj_fields[0])
1276         obj.obj_reset_changes()
1277 
1278         tenant_id = obj['tenant_id']
1279         new_obj_fields = dict()
1280         new_obj_fields['tenant_id'] = uuidutils.generate_uuid()
1281         new_obj_fields['field2'] = uuidutils.generate_uuid()
1282 
1283         obj.update_fields(new_obj_fields)
1284         self.assertEqual(set(['field2']), obj.obj_what_changed())
1285         self.assertEqual(tenant_id, obj.project_id)
1286 
1287     def test_tenant_id_filter_added_when_project_id_present(self):
1288         self._test_class.get_objects(
1289             self.context, tenant_id=self.obj_fields[0]['project_id'])
1290 
1291 
1292 class BaseDbObjectMultipleForeignKeysTestCase(_BaseObjectTestCase,
1293                                               test_base.BaseTestCase):
1294 
1295     _test_class = FakeNeutronObjectSyntheticField
1296 
1297     def test_load_synthetic_db_fields_with_multiple_foreign_keys(self):
1298         obj = self._test_class(self.context, **self.obj_fields[0])
1299         self.assertRaises(o_exc.NeutronSyntheticFieldMultipleForeignKeys,
1300                           obj.load_synthetic_db_fields)
1301 
1302 
1303 class BaseDbObjectForeignKeysNotFoundTestCase(_BaseObjectTestCase,
1304                                               test_base.BaseTestCase):
1305 
1306     _test_class = FakeNeutronObjectSyntheticField2
1307 
1308     def test_load_foreign_keys_not_belong_class(self):
1309         obj = self._test_class(self.context, **self.obj_fields[0])
1310         self.assertRaises(o_exc.NeutronSyntheticFieldsForeignKeysNotFound,
1311                           obj.load_synthetic_db_fields)
1312 
1313 
1314 class BaseDbObjectMultipleParentsForForeignKeysTestCase(
1315         _BaseObjectTestCase,
1316         test_base.BaseTestCase):
1317 
1318     _test_class = FakeParent
1319 
1320     def test_load_synthetic_db_fields_with_multiple_parents(self):
1321         child_cls = FakeSmallNeutronObjectWithMultipleParents
1322         self.obj_registry.register(child_cls)
1323         self.obj_registry.register(FakeParent)
1324         obj = self._test_class(self.context, **self.obj_fields[0])
1325         fake_children = [
1326             child_cls(
1327                 self.context, **child_cls.modify_fields_from_db(
1328                     self.get_random_db_fields(obj_cls=child_cls))
1329             )
1330             for _ in range(5)
1331         ]
1332         with mock.patch.object(child_cls, 'get_objects',
1333                                return_value=fake_children) as get_objects:
1334             obj.load_synthetic_db_fields()
1335         get_objects.assert_called_once_with(self.context, field1=obj.id)
1336         self.assertEqual(fake_children, obj.children)
1337 
1338 
1339 class BaseObjectIfaceDictMiscValuesTestCase(_BaseObjectTestCase,
1340                                             test_base.BaseTestCase):
1341 
1342     _test_class = FakeNeutronObjectDictOfMiscValues
1343 
1344     def test_dict_of_misc_values(self):
1345         obj_id = uuidutils.generate_uuid()
1346         float_value = 1.23
1347         misc_list = [True, float_value]
1348         obj_dict = {
1349             'bool': True,
1350             'float': float_value,
1351             'misc_list': misc_list
1352         }
1353         obj = self._test_class(self.context, id=obj_id, dict_field=obj_dict)
1354         self.assertTrue(obj.dict_field['bool'])
1355         self.assertEqual(float_value, obj.dict_field['float'])
1356         self.assertEqual(misc_list, obj.dict_field['misc_list'])
1357 
1358 
1359 class BaseObjectIfaceListDictMiscValuesTestCase(_BaseObjectTestCase,
1360                                                 test_base.BaseTestCase):
1361 
1362     _test_class = FakeNeutronObjectListOfDictOfMiscValues
1363 
1364     def test_list_of_dict_of_misc_values(self):
1365         obj_id = uuidutils.generate_uuid()
1366         float_value = 1.23
1367         misc_list = [True, float_value]
1368         obj_dict = {
1369             'bool': True,
1370             'float': float_value,
1371             'misc_list': misc_list
1372         }
1373         obj = self._test_class(
1374             self.context, id=obj_id, list_of_dicts_field=[obj_dict])
1375         self.assertEqual(1, len(obj.list_of_dicts_field))
1376         self.assertTrue(obj.list_of_dicts_field[0]['bool'])
1377         self.assertEqual(float_value, obj.list_of_dicts_field[0]['float'])
1378         self.assertEqual(misc_list, obj.list_of_dicts_field[0]['misc_list'])
1379 
1380 
1381 class BaseDbObjectTestCase(_BaseObjectTestCase,
1382                            test_db_base_plugin_v2.DbOperationBoundMixin):
1383     def setUp(self):
1384         super(BaseDbObjectTestCase, self).setUp()
1385         synthetic_fields = self._get_object_synthetic_fields(self._test_class)
1386         for synth_field in synthetic_fields:
1387             objclass = self._get_ovo_object_class(self._test_class,
1388                                                   synth_field)
1389             if not objclass:
1390                 continue
1391             for db_obj in self.db_objs:
1392                 objclass_fields = self.get_random_db_fields(objclass)
1393                 if isinstance(self._test_class.fields[synth_field],
1394                               obj_fields.ObjectField):
1395                     db_obj[synth_field] = objclass.db_model(**objclass_fields)
1396                 else:
1397                     db_obj[synth_field] = [
1398                         objclass.db_model(**objclass_fields)
1399                     ]
1400 
1401     def _create_test_network(self, name='test-network1', network_id=None):
1402         network_id = (uuidutils.generate_uuid() if network_id is None
1403                       else network_id)
1404         _network = net_obj.Network(self.context, name=name, id=network_id)
1405         _network.create()
1406         return _network
1407 
1408     def _create_test_network_id(self):
1409         return self._create_test_network(
1410             "test-network-%s" % helpers.get_random_string(4)).id
1411 
1412     def _create_external_network_id(self):
1413         test_network_id = self._create_test_network_id()
1414         ext_net = net_obj.ExternalNetwork(self.context,
1415             network_id=test_network_id)
1416         ext_net.create()
1417         return ext_net.network_id
1418 
1419     def _create_test_fip_id(self):
1420         fake_fip = '172.23.3.0'
1421         ext_net_id = self._create_external_network_id()
1422         # TODO(manjeets) replace this with fip ovo
1423         # once it is implemented
1424         return obj_db_api.create_object(
1425             self.context, l3_model.FloatingIP,
1426             {'floating_ip_address': fake_fip,
1427              'floating_network_id': ext_net_id,
1428              'floating_port_id': self._create_test_port_id(
1429                  network_id=ext_net_id)}).id
1430 
1431     def _create_test_subnet_id(self, network_id=None):
1432         if not network_id:
1433             network_id = self._create_test_network_id()
1434         test_subnet = {
1435             'project_id': uuidutils.generate_uuid(),
1436             'name': 'test-subnet1',
1437             'network_id': network_id,
1438             'ip_version': 4,
1439             'cidr': netaddr.IPNetwork('10.0.0.0/24'),
1440             'gateway_ip': '10.0.0.1',
1441             'enable_dhcp': 1,
1442             'ipv6_ra_mode': None,
1443             'ipv6_address_mode': None
1444         }
1445         subnet_obj = subnet.Subnet(self.context, **test_subnet)
1446         subnet_obj.create()
1447         return subnet_obj.id
1448 
1449     def _create_test_port_id(self, **port_attrs):
1450         return self._create_test_port(**port_attrs)['id']
1451 
1452     def _create_test_port(self, **port_attrs):
1453         if 'network_id' not in port_attrs:
1454             port_attrs['network_id'] = self._create_test_network_id()
1455 
1456         if not hasattr(self, '_mac_address_generator'):
1457             self._mac_address_generator = (
1458                 netaddr.EUI(":".join(["%02x" % i] * 6))
1459                 for i in itertools.count()
1460             )
1461 
1462         if not hasattr(self, '_port_name_generator'):
1463             self._port_name_generator = ("test-port%d" % i
1464                                          for i in itertools.count(1))
1465 
1466         attrs = {'project_id': uuidutils.generate_uuid(),
1467                  'admin_state_up': True,
1468                  'status': 'ACTIVE',
1469                  'device_id': 'fake_device',
1470                  'device_owner': 'fake_owner'}
1471         attrs.update(port_attrs)
1472 
1473         if 'name' not in attrs:
1474             attrs['name'] = next(self._port_name_generator)
1475         if 'mac_address' not in attrs:
1476             attrs['mac_address'] = next(self._mac_address_generator)
1477 
1478         port = ports.Port(self.context, **attrs)
1479         port.create()
1480         return port
1481 
1482     def _create_test_segment_id(self, network_id=None):
1483         attr = self.get_random_object_fields(net_obj.NetworkSegment)
1484         attr['network_id'] = network_id or self._create_test_network_id()
1485         segment = net_obj.NetworkSegment(self.context, **attr)
1486         segment.create()
1487         return segment.id
1488 
1489     def _create_test_router_id(self):
1490         attrs = {
1491             'name': 'test_router',
1492         }
1493         # TODO(sindhu): Replace with the router object once its ready
1494         router = obj_db_api.create_object(
1495             self.context, l3_model.Router, attrs)
1496         return router['id']
1497 
1498     def _create_test_security_group_id(self):
1499         sg_fields = self.get_random_object_fields(securitygroup.SecurityGroup)
1500         _securitygroup = securitygroup.SecurityGroup(
1501             self.context, **sg_fields)
1502         _securitygroup.create()
1503         return _securitygroup.id
1504 
1505     def _create_test_agent_id(self):
1506         attrs = self.get_random_object_fields(obj_cls=agent.Agent)
1507         _agent = agent.Agent(self.context, **attrs)
1508         _agent.create()
1509         return _agent['id']
1510 
1511     def _create_test_standard_attribute_id(self):
1512         attrs = {
1513             'resource_type': helpers.get_random_string(4),
1514             'revision_number': tools.get_random_integer()
1515         }
1516         return obj_db_api.create_object(
1517             self.context,
1518             standard_attr.StandardAttribute, attrs,
1519             populate_id=False)['id']
1520 
1521     def _create_test_flavor_id(self):
1522         attrs = self.get_random_object_fields(obj_cls=flavor.Flavor)
1523         flavor_obj = flavor.Flavor(self.context, **attrs)
1524         flavor_obj.create()
1525         return flavor_obj.id
1526 
1527     def _create_test_service_profile_id(self):
1528         attrs = self.get_random_object_fields(obj_cls=flavor.ServiceProfile)
1529         service_profile_obj = flavor.ServiceProfile(self.context, **attrs)
1530         service_profile_obj.create()
1531         return service_profile_obj.id
1532 
1533     def _create_test_qos_policy(self, **qos_policy_attrs):
1534         _qos_policy = qos_policy.QosPolicy(self.context, **qos_policy_attrs)
1535         _qos_policy.create()
1536         return _qos_policy
1537 
1538     def test_get_standard_attr_id(self):
1539 
1540         if not self._test_class.has_standard_attributes():
1541             self.skipTest(
1542                     'No standard attributes found in test class %r'
1543                     % self._test_class)
1544 
1545         obj = self._make_object(self.obj_fields[0])
1546         obj.create()
1547 
1548         model = self.context.session.query(obj.db_model).filter_by(
1549             **obj._get_composite_keys()).one()
1550 
1551         retrieved_obj = self._test_class.get_object(
1552             self.context, **obj._get_composite_keys())
1553 
1554         self.assertIsNotNone(retrieved_obj.standard_attr_id)
1555         self.assertEqual(
1556             model.standard_attr_id, retrieved_obj.standard_attr_id)
1557 
1558     def _make_object(self, fields):
1559         fields = get_non_synthetic_fields(self._test_class, fields)
1560         return self._test_class(self.context,
1561                                 **remove_timestamps_from_fields(
1562                                     fields, self._test_class.fields))
1563 
1564     def test_downgrade_to_1_0(self):
1565         for obj in self.objs:
1566             try:
1567                 obj.obj_to_primitive(target_version='1.0')
1568             except exception.IncompatibleObjectVersion:
1569                 # the only exception we should allow is IncompatibleVersion
1570                 pass
1571 
1572     def test_get_object_create_update_delete(self):
1573         # Timestamps can't be initialized and multiple objects may use standard
1574         # attributes so we need to remove timestamps when creating objects
1575         obj = self._make_object(self.obj_fields[0])
1576         obj.create()
1577 
1578         new = self._test_class.get_object(self.context,
1579                                           **obj._get_composite_keys())
1580         self.assertEqual(obj, new)
1581 
1582         obj = new
1583 
1584         for key, val in self.get_updatable_fields(self.obj_fields[1]).items():
1585             setattr(obj, key, val)
1586         obj.update()
1587 
1588         new = self._test_class.get_object(self.context,
1589                                           **obj._get_composite_keys())
1590         self.assertEqual(obj, new)
1591 
1592         obj = new
1593         new.delete()
1594 
1595         new = self._test_class.get_object(self.context,
1596                                           **obj._get_composite_keys())
1597         self.assertIsNone(new)
1598 
1599     def test_update_non_existent_object_raises_not_found(self):
1600         obj = self._make_object(self.obj_fields[0])
1601         obj.obj_reset_changes()
1602 
1603         fields_to_update = self.get_updatable_fields(self.obj_fields[0])
1604         if not fields_to_update:
1605             self.skipTest('No updatable fields found in test class %r' %
1606                           self._test_class)
1607         for key, val in fields_to_update.items():
1608             setattr(obj, key, val)
1609 
1610         self.assertRaises(n_exc.ObjectNotFound, obj.update)
1611 
1612     def test_delete_non_existent_object_raises_not_found(self):
1613         obj = self._make_object(self.obj_fields[0])
1614         self.assertRaises(n_exc.ObjectNotFound, obj.delete)
1615 
1616     @mock.patch(SQLALCHEMY_COMMIT)
1617     def test_create_single_transaction(self, mock_commit):
1618         obj = self._make_object(self.obj_fields[0])
1619         obj.create()
1620         self.assertEqual(1, mock_commit.call_count)
1621 
1622     def test_update_single_transaction(self):
1623         obj = self._make_object(self.obj_fields[0])
1624         obj.create()
1625 
1626         fields_to_update = self.get_updatable_fields(self.obj_fields[1])
1627         if not fields_to_update:
1628             self.skipTest('No updatable fields found in test class %r' %
1629                           self._test_class)
1630         for key, val in fields_to_update.items():
1631             setattr(obj, key, val)
1632 
1633         with mock.patch(SQLALCHEMY_COMMIT) as mock_commit:
1634             obj.update()
1635         self.assertEqual(1, mock_commit.call_count)
1636 
1637     def test_delete_single_transaction(self):
1638         obj = self._make_object(self.obj_fields[0])
1639         obj.create()
1640 
1641         with mock.patch(SQLALCHEMY_COMMIT) as mock_commit:
1642             obj.delete()
1643         self.assertEqual(1, mock_commit.call_count)
1644 
1645     @mock.patch(SQLALCHEMY_COMMIT)
1646     def test_get_objects_single_transaction(self, mock_commit):
1647         self._test_class.get_objects(self.context)
1648         self.assertEqual(1, mock_commit.call_count)
1649 
1650     @mock.patch(SQLALCHEMY_COMMIT)
1651     def test_get_object_single_transaction(self, mock_commit):
1652         obj = self._make_object(self.obj_fields[0])
1653         obj.create()
1654 
1655         obj = self._test_class.get_object(self.context,
1656                                           **obj._get_composite_keys())
1657         self.assertEqual(2, mock_commit.call_count)
1658 
1659     def test_get_objects_supports_extra_filtername(self):
1660         self.filtered_args = None
1661 
1662         def foo_filter(query, filters):
1663             self.filtered_args = filters
1664             return query
1665 
1666         self.obj_registry.register(self._test_class)
1667         model_query.register_hook(
1668             self._test_class.db_model,
1669             'foo_filter',
1670             query_hook=None,
1671             filter_hook=None,
1672             result_filters=foo_filter)
1673         base.register_filter_hook_on_model(self._test_class.db_model, 'foo')
1674 
1675         self._test_class.get_objects(self.context, foo=42)
1676         self.assertEqual({'foo': [42]}, self.filtered_args)
1677 
1678     def test_filtering_by_fields(self):
1679         obj = self._make_object(self.obj_fields[0])
1680         obj.create()
1681 
1682         for field in get_obj_persistent_fields(obj):
1683             if not isinstance(obj[field], list):
1684                 filters = {field: [obj[field]]}
1685             else:
1686                 filters = {field: obj[field]}
1687             new = self._test_class.get_objects(self.context, **filters)
1688             self.assertItemsEqual(
1689                 [obj._get_composite_keys()],
1690                 [obj_._get_composite_keys() for obj_ in new],
1691                 'Filtering by %s failed.' % field)
1692 
1693     def _get_non_synth_fields(self, objclass, db_attrs):
1694         fields = objclass.modify_fields_from_db(db_attrs)
1695         fields = remove_timestamps_from_fields(fields, objclass.fields)
1696         fields = get_non_synthetic_fields(objclass, fields)
1697         return fields
1698 
1699     def _create_object_with_synthetic_fields(self, db_obj):
1700         cls_ = self._test_class
1701         object_fields = self._get_object_synthetic_fields(cls_)
1702 
1703         # create base object
1704         obj = cls_(self.context, **self._get_non_synth_fields(cls_, db_obj))
1705         obj.create()
1706 
1707         # create objects that are going to be loaded into the base object
1708         # through synthetic fields
1709         for field in object_fields:
1710             objclass = self._get_ovo_object_class(cls_, field)
1711             if not objclass:
1712                 continue
1713 
1714             # check that the stored database model does not have non-empty
1715             # relationships
1716             dbattr = obj.fields_need_translation.get(field, field)
1717             self.assertFalse(getattr(obj.db_obj, dbattr, None))
1718 
1719             if isinstance(cls_.fields[field], obj_fields.ObjectField):
1720                 objclass_fields = self._get_non_synth_fields(objclass,
1721                                                              db_obj[field])
1722             else:
1723                 objclass_fields = self._get_non_synth_fields(objclass,
1724                                                              db_obj[field][0])
1725 
1726             # make sure children point to the base object
1727             foreign_keys = objclass.foreign_keys.get(obj.__class__.__name__)
1728             for local_field, foreign_key in foreign_keys.items():
1729                 objclass_fields[local_field] = obj.get(foreign_key)
1730 
1731             synth_field_obj = objclass(self.context, **objclass_fields)
1732             synth_field_obj.create()
1733 
1734             # reload the parent object under test
1735             obj = cls_.get_object(self.context, **obj._get_composite_keys())
1736 
1737             # check that the stored database model now has filled relationships
1738             dbattr = obj.fields_need_translation.get(field, field)
1739             self.assertTrue(getattr(obj.db_obj, dbattr, None))
1740 
1741             # reset the object so that we can compare it to other clean objects
1742             obj.obj_reset_changes([field])
1743 
1744         return obj
1745 
1746     def _test_get_with_synthetic_fields(self, getter):
1747         object_fields = self._get_object_synthetic_fields(self._test_class)
1748         if not object_fields:
1749             self.skipTest(
1750                 'No synthetic object fields found '
1751                 'in test class %r' % self._test_class
1752             )
1753         obj = self._create_object_with_synthetic_fields(self.db_objs[0])
1754         listed_obj = getter(self.context, **obj._get_composite_keys())
1755         self.assertTrue(listed_obj)
1756         self.assertEqual(obj, listed_obj)
1757 
1758     def test_get_object_with_synthetic_fields(self):
1759         self._test_get_with_synthetic_fields(self._test_class.get_object)
1760 
1761     def test_get_objects_with_synthetic_fields(self):
1762         def getter(*args, **kwargs):
1763             objs = self._test_class.get_objects(*args, **kwargs)
1764             self.assertEqual(1, len(objs))
1765             return objs[0]
1766 
1767         self._test_get_with_synthetic_fields(getter)
1768 
1769     # NOTE(korzen) _list method is used in neutron.tests.db.unit.db.
1770     # test_db_base_plugin_v2.DbOperationBoundMixin in _list_and_count_queries()
1771     # This is used in test_subnet for asserting that number of queries is
1772     # constant. It can be used also for port and network objects when ready.
1773     def _list(self, resource, neutron_context):
1774         cls_ = resource
1775         return cls_.get_objects(neutron_context)
1776 
1777     def test_get_objects_queries_constant(self):
1778         iter_db_obj = iter(self.db_objs)
1779 
1780         def _create():
1781             return self._create_object_with_synthetic_fields(next(iter_db_obj))
1782 
1783         self._assert_object_list_queries_constant(_create, self._test_class)
1784 
1785     def test_count(self):
1786         for fields in self.obj_fields:
1787             self._make_object(fields).create()
1788         self.assertEqual(
1789             len(self.obj_fields), self._test_class.count(self.context))
1790 
1791     def test_count_validate_filters_false(self):
1792         for fields in self.obj_fields:
1793             self._make_object(fields).create()
1794         self.assertEqual(
1795             len(self.obj_fields), self._test_class.count(self.context,
1796                 validate_filters=False, fake_filter='xxx'))
1797 
1798     def test_count_invalid_filters(self):
1799         for fields in self.obj_fields:
1800             self._make_object(fields).create()
1801         self.assertRaises(n_exc.InvalidInput,
1802                           self._test_class.count, self.context,
1803                           fake_field='xxx')
1804 
1805     def test_objects_exist(self):
1806         for fields in self.obj_fields:
1807             self._make_object(fields).create()
1808         self.assertTrue(self._test_class.objects_exist(self.context))
1809 
1810     def test_objects_exist_false(self):
1811         self.assertFalse(self._test_class.objects_exist(self.context))
1812 
1813     def test_objects_exist_validate_filters(self):
1814         self.assertRaises(n_exc.InvalidInput,
1815                           self._test_class.objects_exist, self.context,
1816                           fake_field='xxx')
1817 
1818     def test_objects_exist_validate_filters_false(self):
1819         for fields in self.obj_fields:
1820             self._make_object(fields).create()
1821         self.assertTrue(self._test_class.objects_exist(
1822             self.context, validate_filters=False, fake_filter='xxx'))
1823 
1824     def test_update_objects(self):
1825         fields_to_update = self.get_updatable_fields(
1826             self.obj_fields[1])
1827         if not fields_to_update:
1828             self.skipTest('No updatable fields found in test '
1829                           'class %r' % self._test_class)
1830         for fields in self.obj_fields:
1831             self._make_object(fields).create()
1832 
1833         objs = self._test_class.get_objects(
1834             self.context, **self.valid_field_filter)
1835         for k, v in self.valid_field_filter.items():
1836             self.assertEqual(v, objs[0][k])
1837 
1838         count = self._test_class.update_objects(
1839             self.context, {}, **self.valid_field_filter)
1840 
1841         # we haven't updated anything, but got the number of matching records
1842         self.assertEqual(len(objs), count)
1843 
1844         # and the request hasn't changed the number of matching records
1845         new_objs = self._test_class.get_objects(
1846             self.context, **self.valid_field_filter)
1847         self.assertEqual(len(objs), len(new_objs))
1848 
1849         # now update an object with new values
1850         new_values = self._get_random_update_fields()
1851         keys = self.objs[0]._get_composite_keys()
1852         count_updated = self._test_class.update_objects(
1853             self.context, new_values, **keys)
1854         self.assertEqual(1, count_updated)
1855 
1856         new_filter = keys.copy()
1857         new_filter.update(new_values)
1858 
1859         # check that we can fetch using new values
1860         new_objs = self._test_class.get_objects(
1861             self.context, **new_filter)
1862         self.assertEqual(1, len(new_objs))
1863 
1864     def test_update_objects_nothing_to_update(self):
1865         fields_to_update = self.get_updatable_fields(
1866             self.obj_fields[1])
1867         if not fields_to_update:
1868             self.skipTest('No updatable fields found in test '
1869                           'class %r' % self._test_class)
1870         self.assertEqual(
1871             0, self._test_class.update_objects(self.context, {}))
1872 
1873     def test_delete_objects(self):
1874         for fields in self.obj_fields:
1875             self._make_object(fields).create()
1876 
1877         objs = self._test_class.get_objects(
1878             self.context, **self.valid_field_filter)
1879         for k, v in self.valid_field_filter.items():
1880             self.assertEqual(v, objs[0][k])
1881 
1882         count = self._test_class.delete_objects(
1883             self.context, **self.valid_field_filter)
1884 
1885         self.assertEqual(len(objs), count)
1886 
1887         new_objs = self._test_class.get_objects(self.context)
1888         self.assertEqual(len(self.obj_fields) - len(objs), len(new_objs))
1889         for obj in new_objs:
1890             for k, v in self.valid_field_filter.items():
1891                 self.assertNotEqual(v, obj[k])
1892 
1893     def test_delete_objects_nothing_to_delete(self):
1894         self.assertEqual(
1895             0, self._test_class.delete_objects(self.context))
1896 
1897     def test_db_obj(self):
1898         obj = self._make_object(self.obj_fields[0])
1899         self.assertIsNone(obj.db_obj)
1900 
1901         obj.create()
1902         self.assertIsNotNone(obj.db_obj)
1903 
1904         fields_to_update = self.get_updatable_fields(self.obj_fields[1])
1905         if fields_to_update:
1906             old_model = copy.deepcopy(obj.db_obj)
1907             for key, val in fields_to_update.items():
1908                 setattr(obj, key, val)
1909             obj.update()
1910             self.assertIsNotNone(obj.db_obj)
1911             self.assertNotEqual(old_model, obj.db_obj)
1912 
1913         obj.delete()
1914         self.assertIsNone(obj.db_obj)
1915 
1916 
1917 class UniqueObjectBase(test_base.BaseTestCase):
1918     def setUp(self):
1919         super(UniqueObjectBase, self).setUp()
1920         obj_registry = self.useFixture(
1921             fixture.VersionedObjectRegistryFixture())
1922         self.db_model = FakeModel
1923 
1924         class RegisteredObject(base.NeutronDbObject):
1925             db_model = self.db_model
1926 
1927         self.registered_object = RegisteredObject
1928         obj_registry.register(self.registered_object)
1929 
1930 
1931 class GetObjectClassByModelTestCase(UniqueObjectBase):
1932     def setUp(self):
1933         super(GetObjectClassByModelTestCase, self).setUp()
1934         self.not_registered_object = FakeSmallNeutronObject
1935 
1936     def test_object_found_by_model(self):
1937         found_obj = base.get_object_class_by_model(
1938             self.registered_object.db_model)
1939         self.assertIs(self.registered_object, found_obj)
1940 
1941     def test_not_registed_object_raises_exception(self):
1942         with testtools.ExpectedException(o_exc.NeutronDbObjectNotFoundByModel):
1943             base.get_object_class_by_model(self.not_registered_object.db_model)
1944 
1945 
1946 class RegisterFilterHookOnModelTestCase(UniqueObjectBase):
1947     def test_filtername_is_added(self):
1948         filter_name = 'foo'
1949         self.assertNotIn(
1950             filter_name, self.registered_object.extra_filter_names)
1951         base.register_filter_hook_on_model(
1952             FakeNeutronDbObject.db_model, filter_name)
1953         self.assertIn(filter_name, self.registered_object.extra_filter_names)
1954 
1955 
1956 class PagerTestCase(test_base.BaseTestCase):
1957     def test_comparison(self):
1958         pager = base.Pager(sorts=[('order', True)])
1959         pager2 = base.Pager(sorts=[('order', True)])
1960         self.assertEqual(pager, pager2)
1961 
1962         pager3 = base.Pager()
1963         self.assertNotEqual(pager, pager3)
1964 
1965 
1966 class OperationOnStringAndJsonTestCase(test_base.BaseTestCase):
1967     def test_load_empty_string_to_json(self):
1968         for field_val in ['', None]:
1969             for default_val in [None, {}]:
1970                 res = base.NeutronDbObject.load_json_from_str(field_val,
1971                                                               default_val)
1972                 self.assertEqual(res, default_val)
1973 
1974     def test_dump_field_to_string(self):
1975         for field_val in [{}, None]:
1976             for default_val in ['', None]:
1977                 res = base.NeutronDbObject.filter_to_json_str(field_val,
1978                                                               default_val)
1979                 self.assertEqual(default_val, res)
