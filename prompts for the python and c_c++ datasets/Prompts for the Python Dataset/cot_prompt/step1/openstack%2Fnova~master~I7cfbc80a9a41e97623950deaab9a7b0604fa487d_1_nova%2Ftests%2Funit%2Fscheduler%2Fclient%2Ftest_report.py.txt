Based on the given code from a commit, please generate supplementary code files according to the commit message.
####commit message
Scheduler set_inventory_for_provider does nested

SchedulerReportClient.set_inventory_for_provider and its SchedulerClient
wrapper now accept a parent_provider_uuid kwarg, which must be specified
for any provider that isn't a root.  If the method winds up creating the
provider, and parent_provider_uuid is None (the default), the provider
is created as a root - this is the previous behavior.  If
parent_provider_uuid is specified, and the method winds up creating the
provider, it is created as a child of the provider indicated.

Change-Id: I7cfbc80a9a41e97623950deaab9a7b0604fa487d
blueprint: nested-resource-providers

####code 
1 #    Licensed under the Apache License, Version 2.0 (the "License"); you may
2 #    not use this file except in compliance with the License. You may obtain
3 #    a copy of the License at
4 #
5 #         http://www.apache.org/licenses/LICENSE-2.0
6 #
7 #    Unless required by applicable law or agreed to in writing, software
8 #    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
9 #    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
10 #    License for the specific language governing permissions and limitations
11 #    under the License.
12 
13 import copy
14 import time
15 
16 from keystoneauth1 import exceptions as ks_exc
17 import mock
18 import six
19 from six.moves.urllib import parse
20 
21 import nova.conf
22 from nova import context
23 from nova import exception
24 from nova import objects
25 from nova.objects import fields
26 from nova.scheduler.client import report
27 from nova.scheduler import utils as scheduler_utils
28 from nova import test
29 from nova.tests import uuidsentinel as uuids
30 
31 CONF = nova.conf.CONF
32 
33 
34 class SafeConnectedTestCase(test.NoDBTestCase):
35     """Test the safe_connect decorator for the scheduler client."""
36 
37     def setUp(self):
38         super(SafeConnectedTestCase, self).setUp()
39         self.context = context.get_admin_context()
40 
41         with mock.patch('keystoneauth1.loading.load_auth_from_conf_options'):
42             self.client = report.SchedulerReportClient()
43 
44     @mock.patch('keystoneauth1.session.Session.request')
45     def test_missing_endpoint(self, req):
46         """Test EndpointNotFound behavior.
47 
48         A missing endpoint entry should not explode.
49         """
50         req.side_effect = ks_exc.EndpointNotFound()
51         self.client._get_resource_provider("fake")
52 
53         # reset the call count to demonstrate that future calls still
54         # work
55         req.reset_mock()
56         self.client._get_resource_provider("fake")
57         self.assertTrue(req.called)
58 
59     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
60                 '_create_client')
61     @mock.patch('keystoneauth1.session.Session.request')
62     def test_missing_endpoint_create_client(self, req, create_client):
63         """Test EndpointNotFound retry behavior.
64 
65         A missing endpoint should cause _create_client to be called.
66         """
67         req.side_effect = ks_exc.EndpointNotFound()
68         self.client._get_resource_provider("fake")
69 
70         # This is the second time _create_client is called, but the first since
71         # the mock was created.
72         self.assertTrue(create_client.called)
73 
74     @mock.patch('keystoneauth1.session.Session.request')
75     def test_missing_auth(self, req):
76         """Test Missing Auth handled correctly.
77 
78         A missing auth configuration should not explode.
79 
80         """
81         req.side_effect = ks_exc.MissingAuthPlugin()
82         self.client._get_resource_provider("fake")
83 
84         # reset the call count to demonstrate that future calls still
85         # work
86         req.reset_mock()
87         self.client._get_resource_provider("fake")
88         self.assertTrue(req.called)
89 
90     @mock.patch('keystoneauth1.session.Session.request')
91     def test_unauthorized(self, req):
92         """Test Unauthorized handled correctly.
93 
94         An unauthorized configuration should not explode.
95 
96         """
97         req.side_effect = ks_exc.Unauthorized()
98         self.client._get_resource_provider("fake")
99 
100         # reset the call count to demonstrate that future calls still
101         # work
102         req.reset_mock()
103         self.client._get_resource_provider("fake")
104         self.assertTrue(req.called)
105 
106     @mock.patch('keystoneauth1.session.Session.request')
107     def test_connect_fail(self, req):
108         """Test Connect Failure handled correctly.
109 
110         If we get a connect failure, this is transient, and we expect
111         that this will end up working correctly later.
112 
113         """
114         req.side_effect = ks_exc.ConnectFailure()
115         self.client._get_resource_provider("fake")
116 
117         # reset the call count to demonstrate that future calls do
118         # work
119         req.reset_mock()
120         self.client._get_resource_provider("fake")
121         self.assertTrue(req.called)
122 
123     @mock.patch.object(report, 'LOG')
124     def test_warning_limit(self, mock_log):
125         # Assert that __init__ initializes _warn_count as we expect
126         self.assertEqual(0, self.client._warn_count)
127         mock_self = mock.MagicMock()
128         mock_self._warn_count = 0
129         for i in range(0, report.WARN_EVERY + 3):
130             report.warn_limit(mock_self, 'warning')
131         mock_log.warning.assert_has_calls([mock.call('warning'),
132                                            mock.call('warning')])
133 
134     @mock.patch('keystoneauth1.session.Session.request')
135     def test_failed_discovery(self, req):
136         """Test DiscoveryFailure behavior.
137 
138         Failed discovery should not blow up.
139         """
140         req.side_effect = ks_exc.DiscoveryFailure()
141         self.client._get_resource_provider("fake")
142 
143         # reset the call count to demonstrate that future calls still
144         # work
145         req.reset_mock()
146         self.client._get_resource_provider("fake")
147         self.assertTrue(req.called)
148 
149 
150 class TestConstructor(test.NoDBTestCase):
151     @mock.patch('keystoneauth1.loading.load_session_from_conf_options')
152     @mock.patch('keystoneauth1.loading.load_auth_from_conf_options')
153     def test_constructor(self, load_auth_mock, load_sess_mock):
154         client = report.SchedulerReportClient()
155 
156         load_auth_mock.assert_called_once_with(CONF, 'placement')
157         load_sess_mock.assert_called_once_with(CONF, 'placement',
158                                               auth=load_auth_mock.return_value)
159         self.assertEqual(['internal', 'public'], client._client.interface)
160         self.assertEqual({'accept': 'application/json'},
161                          client._client.additional_headers)
162 
163     @mock.patch('keystoneauth1.loading.load_session_from_conf_options')
164     @mock.patch('keystoneauth1.loading.load_auth_from_conf_options')
165     def test_constructor_admin_interface(self, load_auth_mock, load_sess_mock):
166         self.flags(valid_interfaces='admin', group='placement')
167         client = report.SchedulerReportClient()
168 
169         load_auth_mock.assert_called_once_with(CONF, 'placement')
170         load_sess_mock.assert_called_once_with(CONF, 'placement',
171                                               auth=load_auth_mock.return_value)
172         self.assertEqual(['admin'], client._client.interface)
173         self.assertEqual({'accept': 'application/json'},
174                          client._client.additional_headers)
175 
176 
177 class SchedulerReportClientTestCase(test.NoDBTestCase):
178 
179     def setUp(self):
180         super(SchedulerReportClientTestCase, self).setUp()
181         self.context = context.get_admin_context()
182         self.ks_adap_mock = mock.Mock()
183         self.compute_node = objects.ComputeNode(
184             uuid=uuids.compute_node,
185             hypervisor_hostname='foo',
186             vcpus=8,
187             cpu_allocation_ratio=16.0,
188             memory_mb=1024,
189             ram_allocation_ratio=1.5,
190             local_gb=10,
191             disk_allocation_ratio=1.0,
192         )
193 
194         with test.nested(
195                 mock.patch('keystoneauth1.adapter.Adapter',
196                            return_value=self.ks_adap_mock),
197                 mock.patch('keystoneauth1.loading.load_auth_from_conf_options')
198         ):
199             self.client = report.SchedulerReportClient()
200 
201     def _init_provider_tree(self, generation_override=None,
202                             resources_override=None):
203         cn = self.compute_node
204         resources = resources_override
205         if resources_override is None:
206             resources = {
207                 'VCPU': {
208                     'total': cn.vcpus,
209                     'reserved': 0,
210                     'min_unit': 1,
211                     'max_unit': cn.vcpus,
212                     'step_size': 1,
213                     'allocation_ratio': cn.cpu_allocation_ratio,
214                 },
215                 'MEMORY_MB': {
216                     'total': cn.memory_mb,
217                     'reserved': 512,
218                     'min_unit': 1,
219                     'max_unit': cn.memory_mb,
220                     'step_size': 1,
221                     'allocation_ratio': cn.ram_allocation_ratio,
222                 },
223                 'DISK_GB': {
224                     'total': cn.local_gb,
225                     'reserved': 0,
226                     'min_unit': 1,
227                     'max_unit': cn.local_gb,
228                     'step_size': 1,
229                     'allocation_ratio': cn.disk_allocation_ratio,
230                 },
231             }
232         generation = generation_override or 1
233         rp = self.client._provider_tree.new_root(
234             cn.hypervisor_hostname,
235             cn.uuid,
236             generation,
237         )
238         rp.update_inventory(resources, generation)
239 
240 
241 class TestPutAllocations(SchedulerReportClientTestCase):
242     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.put')
243     def test_put_allocations(self, mock_put):
244         mock_put.return_value.status_code = 204
245         mock_put.return_value.text = "cool"
246         rp_uuid = mock.sentinel.rp
247         consumer_uuid = mock.sentinel.consumer
248         data = {"MEMORY_MB": 1024}
249         expected_url = "/allocations/%s" % consumer_uuid
250         resp = self.client.put_allocations(rp_uuid, consumer_uuid, data,
251                                            mock.sentinel.project_id,
252                                            mock.sentinel.user_id)
253         self.assertTrue(resp)
254         mock_put.assert_called_once_with(expected_url, mock.ANY, version='1.8')
255 
256     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.put')
257     def test_put_allocations_fail_fallback_succeeds(self, mock_put):
258         not_acceptable = mock.Mock()
259         not_acceptable.status_code = 406
260         not_acceptable.text = 'microversion not supported'
261         ok_request = mock.Mock()
262         ok_request.status_code = 204
263         ok_request.text = 'cool'
264         mock_put.side_effect = [not_acceptable, ok_request]
265         rp_uuid = mock.sentinel.rp
266         consumer_uuid = mock.sentinel.consumer
267         data = {"MEMORY_MB": 1024}
268         expected_url = "/allocations/%s" % consumer_uuid
269         resp = self.client.put_allocations(rp_uuid, consumer_uuid, data,
270                                            mock.sentinel.project_id,
271                                            mock.sentinel.user_id)
272         self.assertTrue(resp)
273         # Should fall back to earlier way if 1.8 fails.
274         call1 = mock.call(expected_url, mock.ANY, version='1.8')
275         call2 = mock.call(expected_url, mock.ANY)
276         self.assertEqual(2, mock_put.call_count)
277         mock_put.assert_has_calls([call1, call2])
278 
279     @mock.patch.object(report.LOG, 'warning')
280     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.put')
281     def test_put_allocations_fail(self, mock_put, mock_warn):
282         mock_put.return_value.status_code = 400
283         mock_put.return_value.text = "not cool"
284         rp_uuid = mock.sentinel.rp
285         consumer_uuid = mock.sentinel.consumer
286         data = {"MEMORY_MB": 1024}
287         expected_url = "/allocations/%s" % consumer_uuid
288         resp = self.client.put_allocations(rp_uuid, consumer_uuid, data,
289                                            mock.sentinel.project_id,
290                                            mock.sentinel.user_id)
291         self.assertFalse(resp)
292         mock_put.assert_called_once_with(expected_url, mock.ANY, version='1.8')
293         log_msg = mock_warn.call_args[0][0]
294         self.assertIn("Unable to submit allocation for instance", log_msg)
295 
296     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.put')
297     def test_put_allocations_retries_conflict(self, mock_put):
298 
299         failed = mock.MagicMock()
300         failed.status_code = 409
301         failed.text = "concurrently updated"
302 
303         succeeded = mock.MagicMock()
304         succeeded.status_code = 204
305 
306         mock_put.side_effect = (failed, succeeded)
307 
308         rp_uuid = mock.sentinel.rp
309         consumer_uuid = mock.sentinel.consumer
310         data = {"MEMORY_MB": 1024}
311         expected_url = "/allocations/%s" % consumer_uuid
312         resp = self.client.put_allocations(rp_uuid, consumer_uuid, data,
313                                            mock.sentinel.project_id,
314                                            mock.sentinel.user_id)
315         self.assertTrue(resp)
316         mock_put.assert_has_calls([
317             mock.call(expected_url, mock.ANY, version='1.8'),
318             mock.call(expected_url, mock.ANY, version='1.8')])
319 
320     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.put')
321     def test_put_allocations_retry_gives_up(self, mock_put):
322 
323         failed = mock.MagicMock()
324         failed.status_code = 409
325         failed.text = "concurrently updated"
326 
327         mock_put.return_value = failed
328 
329         rp_uuid = mock.sentinel.rp
330         consumer_uuid = mock.sentinel.consumer
331         data = {"MEMORY_MB": 1024}
332         expected_url = "/allocations/%s" % consumer_uuid
333         resp = self.client.put_allocations(rp_uuid, consumer_uuid, data,
334                                            mock.sentinel.project_id,
335                                            mock.sentinel.user_id)
336         self.assertFalse(resp)
337         mock_put.assert_has_calls([
338             mock.call(expected_url, mock.ANY, version='1.8'),
339             mock.call(expected_url, mock.ANY, version='1.8'),
340             mock.call(expected_url, mock.ANY, version='1.8')])
341 
342     def test_claim_resources_success(self):
343         get_resp_mock = mock.Mock(status_code=200)
344         get_resp_mock.json.return_value = {
345             'allocations': {},  # build instance, not move
346         }
347         self.ks_adap_mock.get.return_value = get_resp_mock
348         resp_mock = mock.Mock(status_code=204)
349         self.ks_adap_mock.put.return_value = resp_mock
350         consumer_uuid = uuids.consumer_uuid
351         alloc_req = {
352             'allocations': {
353                 'resource_provider': {
354                     'uuid': uuids.cn1,
355                 },
356                 'resources': {
357                     'VCPU': 1,
358                     'MEMORY_MB': 1024,
359                 },
360             },
361         }
362 
363         project_id = uuids.project_id
364         user_id = uuids.user_id
365         res = self.client.claim_resources(consumer_uuid, alloc_req, project_id,
366             user_id)
367 
368         expected_url = "/allocations/%s" % consumer_uuid
369         expected_payload = copy.deepcopy(alloc_req)
370         expected_payload['project_id'] = project_id
371         expected_payload['user_id'] = user_id
372         self.ks_adap_mock.put.assert_called_once_with(
373             expected_url, microversion='1.10', json=expected_payload,
374             raise_exc=False)
375 
376         self.assertTrue(res)
377 
378     def test_claim_resources_success_move_operation_no_shared(self):
379         """Tests that when a move operation is detected (existing allocations
380         for the same instance UUID) that we end up constructing an appropriate
381         allocation that contains the original resources on the source host
382         as well as the resources on the destination host.
383         """
384         get_resp_mock = mock.Mock(status_code=200)
385         get_resp_mock.json.return_value = {
386             'allocations': {
387                 uuids.source: {
388                     'resource_provider_generation': 42,
389                     'resources': {
390                         'VCPU': 1,
391                         'MEMORY_MB': 1024,
392                     },
393                 },
394             },
395         }
396 
397         self.ks_adap_mock.get.return_value = get_resp_mock
398         resp_mock = mock.Mock(status_code=204)
399         self.ks_adap_mock.put.return_value = resp_mock
400         consumer_uuid = uuids.consumer_uuid
401         alloc_req = {
402             'allocations': [
403                 {
404                     'resource_provider': {
405                         'uuid': uuids.destination,
406                     },
407                     'resources': {
408                         'VCPU': 1,
409                         'MEMORY_MB': 1024,
410                     },
411                 },
412             ],
413         }
414 
415         project_id = uuids.project_id
416         user_id = uuids.user_id
417         res = self.client.claim_resources(consumer_uuid, alloc_req, project_id,
418             user_id)
419 
420         expected_url = "/allocations/%s" % consumer_uuid
421         # New allocation should include resources claimed on both the source
422         # and destination hosts
423         expected_payload = {
424             'allocations': [
425                 {
426                     'resource_provider': {
427                         'uuid': uuids.source,
428                     },
429                     'resources': {
430                         'VCPU': 1,
431                         'MEMORY_MB': 1024,
432                     },
433                 },
434                 {
435                     'resource_provider': {
436                         'uuid': uuids.destination,
437                     },
438                     'resources': {
439                         'VCPU': 1,
440                         'MEMORY_MB': 1024,
441                     },
442                 },
443             ],
444         }
445         expected_payload['project_id'] = project_id
446         expected_payload['user_id'] = user_id
447         self.ks_adap_mock.put.assert_called_once_with(
448             expected_url, microversion='1.10', json=mock.ANY,
449             raise_exc=False)
450         # We have to pull the json body from the mock call_args to validate
451         # it separately otherwise hash seed issues get in the way.
452         actual_payload = self.ks_adap_mock.put.call_args[1]['json']
453         sort_by_uuid = lambda x: x['resource_provider']['uuid']
454         expected_allocations = sorted(expected_payload['allocations'],
455                                       key=sort_by_uuid)
456         actual_allocations = sorted(actual_payload['allocations'],
457                                     key=sort_by_uuid)
458         self.assertEqual(expected_allocations, actual_allocations)
459 
460         self.assertTrue(res)
461 
462     def test_claim_resources_success_move_operation_with_shared(self):
463         """Tests that when a move operation is detected (existing allocations
464         for the same instance UUID) that we end up constructing an appropriate
465         allocation that contains the original resources on the source host
466         as well as the resources on the destination host but that when a shared
467         storage provider is claimed against in both the original allocation as
468         well as the new allocation request, we don't double that allocation
469         resource request up.
470         """
471         get_resp_mock = mock.Mock(status_code=200)
472         get_resp_mock.json.return_value = {
473             'allocations': {
474                 uuids.source: {
475                     'resource_provider_generation': 42,
476                     'resources': {
477                         'VCPU': 1,
478                         'MEMORY_MB': 1024,
479                     },
480                 },
481                 uuids.shared_storage: {
482                     'resource_provider_generation': 42,
483                     'resources': {
484                         'DISK_GB': 100,
485                     },
486                 },
487             },
488         }
489 
490         self.ks_adap_mock.get.return_value = get_resp_mock
491         resp_mock = mock.Mock(status_code=204)
492         self.ks_adap_mock.put.return_value = resp_mock
493         consumer_uuid = uuids.consumer_uuid
494         alloc_req = {
495             'allocations': [
496                 {
497                     'resource_provider': {
498                         'uuid': uuids.destination,
499                     },
500                     'resources': {
501                         'VCPU': 1,
502                         'MEMORY_MB': 1024,
503                     },
504                 },
505                 {
506                     'resource_provider': {
507                         'uuid': uuids.shared_storage,
508                     },
509                     'resources': {
510                         'DISK_GB': 100,
511                     },
512                 },
513             ],
514         }
515 
516         project_id = uuids.project_id
517         user_id = uuids.user_id
518         res = self.client.claim_resources(consumer_uuid, alloc_req, project_id,
519             user_id)
520 
521         expected_url = "/allocations/%s" % consumer_uuid
522         # New allocation should include resources claimed on both the source
523         # and destination hosts but not have a doubled-up request for the disk
524         # resources on the shared provider
525         expected_payload = {
526             'allocations': [
527                 {
528                     'resource_provider': {
529                         'uuid': uuids.source,
530                     },
531                     'resources': {
532                         'VCPU': 1,
533                         'MEMORY_MB': 1024,
534                     },
535                 },
536                 {
537                     'resource_provider': {
538                         'uuid': uuids.shared_storage,
539                     },
540                     'resources': {
541                         'DISK_GB': 100,
542                     },
543                 },
544                 {
545                     'resource_provider': {
546                         'uuid': uuids.destination,
547                     },
548                     'resources': {
549                         'VCPU': 1,
550                         'MEMORY_MB': 1024,
551                     },
552                 },
553             ],
554         }
555         expected_payload['project_id'] = project_id
556         expected_payload['user_id'] = user_id
557         self.ks_adap_mock.put.assert_called_once_with(
558             expected_url, microversion='1.10', json=mock.ANY,
559             raise_exc=False)
560         # We have to pull the allocations from the json body from the
561         # mock call_args to validate it separately otherwise hash seed
562         # issues get in the way.
563         actual_payload = self.ks_adap_mock.put.call_args[1]['json']
564         sort_by_uuid = lambda x: x['resource_provider']['uuid']
565         expected_allocations = sorted(expected_payload['allocations'],
566                                       key=sort_by_uuid)
567         actual_allocations = sorted(actual_payload['allocations'],
568                                     key=sort_by_uuid)
569         self.assertEqual(expected_allocations, actual_allocations)
570 
571         self.assertTrue(res)
572 
573     def test_claim_resources_success_resize_to_same_host_no_shared(self):
574         """Tests that when a resize to the same host operation is detected
575         (existing allocations for the same instance UUID and same resource
576         provider) that we end up constructing an appropriate allocation that
577         contains the original resources on the source host as well as the
578         resources on the destination host, which in this case are the same.
579         """
580         get_current_allocations_resp_mock = mock.Mock(status_code=200)
581         get_current_allocations_resp_mock.json.return_value = {
582             'allocations': {
583                 uuids.same_host: {
584                     'resource_provider_generation': 42,
585                     'resources': {
586                         'VCPU': 1,
587                         'MEMORY_MB': 1024,
588                         'DISK_GB': 20
589                     },
590                 },
591             },
592         }
593 
594         self.ks_adap_mock.get.return_value = get_current_allocations_resp_mock
595         put_allocations_resp_mock = mock.Mock(status_code=204)
596         self.ks_adap_mock.put.return_value = put_allocations_resp_mock
597         consumer_uuid = uuids.consumer_uuid
598         # This is the resize-up allocation where VCPU, MEMORY_MB and DISK_GB
599         # are all being increased but on the same host. We also throw a custom
600         # resource class in the new allocation to make sure it's not lost and
601         # that we don't have a KeyError when merging the allocations.
602         alloc_req = {
603             'allocations': [
604                 {
605                     'resource_provider': {
606                         'uuid': uuids.same_host,
607                     },
608                     'resources': {
609                         'VCPU': 2,
610                         'MEMORY_MB': 2048,
611                         'DISK_GB': 40,
612                         'CUSTOM_FOO': 1
613                     },
614                 },
615             ],
616         }
617 
618         project_id = uuids.project_id
619         user_id = uuids.user_id
620         res = self.client.claim_resources(consumer_uuid, alloc_req, project_id,
621             user_id)
622 
623         expected_url = "/allocations/%s" % consumer_uuid
624         # New allocation should include doubled resources claimed on the same
625         # host.
626         expected_payload = {
627             'allocations': [
628                 {
629                     'resource_provider': {
630                         'uuid': uuids.same_host,
631                     },
632                     'resources': {
633                         'VCPU': 3,
634                         'MEMORY_MB': 3072,
635                         'DISK_GB': 60,
636                         'CUSTOM_FOO': 1
637                     },
638                 },
639             ],
640         }
641         expected_payload['project_id'] = project_id
642         expected_payload['user_id'] = user_id
643         self.ks_adap_mock.put.assert_called_once_with(
644             expected_url, microversion='1.10', json=mock.ANY, raise_exc=False)
645         # We have to pull the json body from the mock call_args to validate
646         # it separately otherwise hash seed issues get in the way.
647         actual_payload = self.ks_adap_mock.put.call_args[1]['json']
648         sort_by_uuid = lambda x: x['resource_provider']['uuid']
649         expected_allocations = sorted(expected_payload['allocations'],
650                                       key=sort_by_uuid)
651         actual_allocations = sorted(actual_payload['allocations'],
652                                     key=sort_by_uuid)
653         self.assertEqual(expected_allocations, actual_allocations)
654 
655         self.assertTrue(res)
656 
657     def test_claim_resources_success_resize_to_same_host_with_shared(self):
658         """Tests that when a resize to the same host operation is detected
659         (existing allocations for the same instance UUID and same resource
660         provider) that we end up constructing an appropriate allocation that
661         contains the original resources on the source host as well as the
662         resources on the destination host, which in this case are the same.
663         This test adds the fun wrinkle of throwing a shared storage provider
664         in the mix when doing resize to the same host.
665         """
666         get_current_allocations_resp_mock = mock.Mock(status_code=200)
667         get_current_allocations_resp_mock.json.return_value = {
668             'allocations': {
669                 uuids.same_host: {
670                     'resource_provider_generation': 42,
671                     'resources': {
672                         'VCPU': 1,
673                         'MEMORY_MB': 1024
674                     },
675                 },
676                 uuids.shared_storage: {
677                     'resource_provider_generation': 42,
678                     'resources': {
679                         'DISK_GB': 20,
680                     },
681                 },
682             },
683         }
684 
685         self.ks_adap_mock.get.return_value = get_current_allocations_resp_mock
686         put_allocations_resp_mock = mock.Mock(status_code=204)
687         self.ks_adap_mock.put.return_value = put_allocations_resp_mock
688         consumer_uuid = uuids.consumer_uuid
689         # This is the resize-up allocation where VCPU, MEMORY_MB and DISK_GB
690         # are all being increased but DISK_GB is on a shared storage provider.
691         alloc_req = {
692             'allocations': [
693                 {
694                     'resource_provider': {
695                         'uuid': uuids.same_host,
696                     },
697                     'resources': {
698                         'VCPU': 2,
699                         'MEMORY_MB': 2048
700                     },
701                 },
702                 {
703                     'resource_provider': {
704                         'uuid': uuids.shared_storage,
705                     },
706                     'resources': {
707                         'DISK_GB': 40,
708                     },
709                 },
710             ],
711         }
712 
713         project_id = uuids.project_id
714         user_id = uuids.user_id
715         res = self.client.claim_resources(consumer_uuid, alloc_req, project_id,
716             user_id)
717 
718         expected_url = "/allocations/%s" % consumer_uuid
719         # New allocation should include doubled resources claimed on the same
720         # host.
721         expected_payload = {
722             'allocations': [
723                 {
724                     'resource_provider': {
725                         'uuid': uuids.same_host,
726                     },
727                     'resources': {
728                         'VCPU': 3,
729                         'MEMORY_MB': 3072
730                     },
731                 },
732                 {
733                     'resource_provider': {
734                         'uuid': uuids.shared_storage,
735                     },
736                     'resources': {
737                         'DISK_GB': 60,
738                     },
739                 },
740             ],
741         }
742         expected_payload['project_id'] = project_id
743         expected_payload['user_id'] = user_id
744         self.ks_adap_mock.put.assert_called_once_with(
745             expected_url, microversion='1.10', json=mock.ANY, raise_exc=False)
746         # We have to pull the json body from the mock call_args to validate
747         # it separately otherwise hash seed issues get in the way.
748         actual_payload = self.ks_adap_mock.put.call_args[1]['json']
749         sort_by_uuid = lambda x: x['resource_provider']['uuid']
750         expected_allocations = sorted(expected_payload['allocations'],
751                                       key=sort_by_uuid)
752         actual_allocations = sorted(actual_payload['allocations'],
753                                     key=sort_by_uuid)
754         self.assertEqual(expected_allocations, actual_allocations)
755 
756         self.assertTrue(res)
757 
758     def test_claim_resources_fail_retry_success(self):
759         get_resp_mock = mock.Mock(status_code=200)
760         get_resp_mock.json.return_value = {
761             'allocations': {},  # build instance, not move
762         }
763         self.ks_adap_mock.get.return_value = get_resp_mock
764         resp_mocks = [
765             mock.Mock(
766                 status_code=409,
767                 text='Inventory changed while attempting to allocate: '
768                      'Another thread concurrently updated the data. '
769                      'Please retry your update'),
770             mock.Mock(status_code=204),
771         ]
772         self.ks_adap_mock.put.side_effect = resp_mocks
773         consumer_uuid = uuids.consumer_uuid
774         alloc_req = {
775             'allocations': [
776                 {
777                     'resource_provider': {
778                         'uuid': uuids.cn1,
779                     },
780                     'resources': {
781                         'VCPU': 1,
782                         'MEMORY_MB': 1024,
783                     },
784                 },
785             ],
786         }
787 
788         project_id = uuids.project_id
789         user_id = uuids.user_id
790         res = self.client.claim_resources(consumer_uuid, alloc_req, project_id,
791             user_id)
792 
793         expected_url = "/allocations/%s" % consumer_uuid
794         expected_payload = copy.deepcopy(alloc_req)
795         expected_payload['project_id'] = project_id
796         expected_payload['user_id'] = user_id
797         # We should have exactly two calls to the placement API that look
798         # identical since we're retrying the same HTTP request
799         expected_calls = [
800             mock.call(expected_url, microversion='1.10', json=expected_payload,
801                       raise_exc=False)] * 2
802         self.assertEqual(len(expected_calls),
803                          self.ks_adap_mock.put.call_count)
804         self.ks_adap_mock.put.assert_has_calls(expected_calls)
805 
806         self.assertTrue(res)
807 
808     @mock.patch.object(report.LOG, 'warning')
809     def test_claim_resources_failure(self, mock_log):
810         get_resp_mock = mock.Mock(status_code=200)
811         get_resp_mock.json.return_value = {
812             'allocations': {},  # build instance, not move
813         }
814         self.ks_adap_mock.get.return_value = get_resp_mock
815         resp_mock = mock.Mock(status_code=409, text='not cool')
816         self.ks_adap_mock.put.return_value = resp_mock
817         consumer_uuid = uuids.consumer_uuid
818         alloc_req = {
819             'allocations': [
820                 {
821                     'resource_provider': {
822                         'uuid': uuids.cn1,
823                     },
824                     'resources': {
825                         'VCPU': 1,
826                         'MEMORY_MB': 1024,
827                     },
828                 },
829             ],
830         }
831 
832         project_id = uuids.project_id
833         user_id = uuids.user_id
834         res = self.client.claim_resources(consumer_uuid, alloc_req, project_id,
835             user_id)
836 
837         expected_url = "/allocations/%s" % consumer_uuid
838         expected_payload = copy.deepcopy(alloc_req)
839         expected_payload['project_id'] = project_id
840         expected_payload['user_id'] = user_id
841         self.ks_adap_mock.put.assert_called_once_with(
842             expected_url, microversion='1.10', json=expected_payload,
843             raise_exc=False)
844 
845         self.assertFalse(res)
846         self.assertTrue(mock_log.called)
847 
848     def test_remove_provider_from_inst_alloc_no_shared(self):
849         """Tests that the method which manipulates an existing doubled-up
850         allocation for a move operation to remove the source host results in
851         sending placement the proper payload to PUT
852         /allocations/{consumer_uuid} call.
853         """
854         get_resp_mock = mock.Mock(status_code=200)
855         get_resp_mock.json.return_value = {
856             'allocations': {
857                 uuids.source: {
858                     'resource_provider_generation': 42,
859                     'resources': {
860                         'VCPU': 1,
861                         'MEMORY_MB': 1024,
862                     },
863                 },
864                 uuids.destination: {
865                     'resource_provider_generation': 42,
866                     'resources': {
867                         'VCPU': 1,
868                         'MEMORY_MB': 1024,
869                     },
870                 },
871             },
872         }
873         self.ks_adap_mock.get.return_value = get_resp_mock
874         resp_mock = mock.Mock(status_code=204)
875         self.ks_adap_mock.put.return_value = resp_mock
876         consumer_uuid = uuids.consumer_uuid
877         project_id = uuids.project_id
878         user_id = uuids.user_id
879         res = self.client.remove_provider_from_instance_allocation(
880             consumer_uuid, uuids.source, user_id, project_id, mock.Mock())
881 
882         expected_url = "/allocations/%s" % consumer_uuid
883         # New allocations should only include the destination...
884         expected_payload = {
885             'allocations': [
886                 {
887                     'resource_provider': {
888                         'uuid': uuids.destination,
889                     },
890                     'resources': {
891                         'VCPU': 1,
892                         'MEMORY_MB': 1024,
893                     },
894                 },
895             ],
896         }
897         expected_payload['project_id'] = project_id
898         expected_payload['user_id'] = user_id
899         # We have to pull the json body from the mock call_args to validate
900         # it separately otherwise hash seed issues get in the way.
901         actual_payload = self.ks_adap_mock.put.call_args[1]['json']
902         sort_by_uuid = lambda x: x['resource_provider']['uuid']
903         expected_allocations = sorted(expected_payload['allocations'],
904                                       key=sort_by_uuid)
905         actual_allocations = sorted(actual_payload['allocations'],
906                                     key=sort_by_uuid)
907         self.assertEqual(expected_allocations, actual_allocations)
908         self.ks_adap_mock.put.assert_called_once_with(
909             expected_url, microversion='1.10', json=mock.ANY, raise_exc=False)
910 
911         self.assertTrue(res)
912 
913     def test_remove_provider_from_inst_alloc_with_shared(self):
914         """Tests that the method which manipulates an existing doubled-up
915         allocation with DISK_GB being consumed from a shared storage provider
916         for a move operation to remove the source host results in sending
917         placement the proper payload to PUT /allocations/{consumer_uuid}
918         call.
919         """
920         get_resp_mock = mock.Mock(status_code=200)
921         get_resp_mock.json.return_value = {
922             'allocations': {
923                 uuids.source: {
924                     'resource_provider_generation': 42,
925                     'resources': {
926                         'VCPU': 1,
927                         'MEMORY_MB': 1024,
928                     },
929                 },
930                 uuids.shared_storage: {
931                     'resource_provider_generation': 42,
932                     'resources': {
933                         'DISK_GB': 100,
934                     },
935                 },
936                 uuids.destination: {
937                     'resource_provider_generation': 42,
938                     'resources': {
939                         'VCPU': 1,
940                         'MEMORY_MB': 1024,
941                     },
942                 },
943             },
944         }
945         self.ks_adap_mock.get.return_value = get_resp_mock
946         resp_mock = mock.Mock(status_code=204)
947         self.ks_adap_mock.put.return_value = resp_mock
948         consumer_uuid = uuids.consumer_uuid
949         project_id = uuids.project_id
950         user_id = uuids.user_id
951         res = self.client.remove_provider_from_instance_allocation(
952             consumer_uuid, uuids.source, user_id, project_id, mock.Mock())
953 
954         expected_url = "/allocations/%s" % consumer_uuid
955         # New allocations should only include the destination...
956         expected_payload = {
957             'allocations': [
958                 {
959                     'resource_provider': {
960                         'uuid': uuids.shared_storage,
961                     },
962                     'resources': {
963                         'DISK_GB': 100,
964                     },
965                 },
966                 {
967                     'resource_provider': {
968                         'uuid': uuids.destination,
969                     },
970                     'resources': {
971                         'VCPU': 1,
972                         'MEMORY_MB': 1024,
973                     },
974                 },
975             ],
976         }
977         expected_payload['project_id'] = project_id
978         expected_payload['user_id'] = user_id
979         # We have to pull the json body from the mock call_args to validate
980         # it separately otherwise hash seed issues get in the way.
981         actual_payload = self.ks_adap_mock.put.call_args[1]['json']
982         sort_by_uuid = lambda x: x['resource_provider']['uuid']
983         expected_allocations = sorted(expected_payload['allocations'],
984                                       key=sort_by_uuid)
985         actual_allocations = sorted(actual_payload['allocations'],
986                                     key=sort_by_uuid)
987         self.assertEqual(expected_allocations, actual_allocations)
988         self.ks_adap_mock.put.assert_called_once_with(
989             expected_url, microversion='1.10', json=mock.ANY, raise_exc=False)
990 
991         self.assertTrue(res)
992 
993     def test_remove_provider_from_inst_alloc_no_source(self):
994         """Tests that if remove_provider_from_instance_allocation() fails to
995         find any allocations for the source host, it just returns True and
996         does not attempt to rewrite the allocation for the consumer.
997         """
998         get_resp_mock = mock.Mock(status_code=200)
999         # Act like the allocations already did not include the source host for
1000         # some reason
1001         get_resp_mock.json.return_value = {
1002             'allocations': {
1003                 uuids.shared_storage: {
1004                     'resource_provider_generation': 42,
1005                     'resources': {
1006                         'DISK_GB': 100,
1007                     },
1008                 },
1009                 uuids.destination: {
1010                     'resource_provider_generation': 42,
1011                     'resources': {
1012                         'VCPU': 1,
1013                         'MEMORY_MB': 1024,
1014                     },
1015                 },
1016             },
1017         }
1018         self.ks_adap_mock.get.return_value = get_resp_mock
1019         consumer_uuid = uuids.consumer_uuid
1020         project_id = uuids.project_id
1021         user_id = uuids.user_id
1022         res = self.client.remove_provider_from_instance_allocation(
1023             consumer_uuid, uuids.source, user_id, project_id, mock.Mock())
1024 
1025         self.ks_adap_mock.get.assert_called()
1026         self.ks_adap_mock.put.assert_not_called()
1027 
1028         self.assertTrue(res)
1029 
1030     def test_remove_provider_from_inst_alloc_fail_get_allocs(self):
1031         """Tests that we gracefully exit with False from
1032         remove_provider_from_instance_allocation() if the call to get the
1033         existing allocations fails for some reason
1034         """
1035         get_resp_mock = mock.Mock(status_code=500)
1036         self.ks_adap_mock.get.return_value = get_resp_mock
1037         consumer_uuid = uuids.consumer_uuid
1038         project_id = uuids.project_id
1039         user_id = uuids.user_id
1040         res = self.client.remove_provider_from_instance_allocation(
1041             consumer_uuid, uuids.source, user_id, project_id, mock.Mock())
1042 
1043         self.ks_adap_mock.get.assert_called()
1044         self.ks_adap_mock.put.assert_not_called()
1045 
1046         self.assertFalse(res)
1047 
1048 
1049 class TestProviderOperations(SchedulerReportClientTestCase):
1050     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1051                 '_create_resource_provider')
1052     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1053                 '_get_provider_aggregates')
1054     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1055                 '_get_resource_provider')
1056     def test_ensure_resource_provider_exists_in_cache(self, get_rp_mock,
1057             get_agg_mock, create_rp_mock):
1058         # Override the client object's cache to contain a resource provider
1059         # object for the compute host and check that
1060         # _ensure_resource_provider() doesn't call _get_resource_provider() or
1061         # _create_resource_provider()
1062         cn = self.compute_node
1063         self.client._provider_tree.new_root(
1064             cn.hypervisor_hostname,
1065             cn.uuid,
1066             1,
1067         )
1068 
1069         self.client._ensure_resource_provider(cn.uuid)
1070         get_agg_mock.assert_called_once_with(cn.uuid)
1071         self.assertIn(uuids.compute_node, self.client._provider_aggregate_map)
1072         self.assertEqual(
1073             get_agg_mock.return_value,
1074             self.client._provider_aggregate_map[cn.uuid]
1075         )
1076         self.assertFalse(get_rp_mock.called)
1077         self.assertFalse(create_rp_mock.called)
1078 
1079     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1080                 '_create_resource_provider')
1081     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1082                 '_get_provider_aggregates')
1083     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1084                 '_get_resource_provider')
1085     def test_ensure_resource_provider_get(self, get_rp_mock, get_agg_mock,
1086             create_rp_mock):
1087         # No resource provider exists in the client's cache, so validate that
1088         # if we get the resource provider from the placement API that we don't
1089         # try to create the resource provider.
1090         get_rp_mock.return_value = {
1091             'uuid': uuids.compute_node,
1092             'name': mock.sentinel.name,
1093             'generation': 1,
1094         }
1095 
1096         self.client._ensure_resource_provider(uuids.compute_node)
1097 
1098         get_rp_mock.assert_called_once_with(uuids.compute_node)
1099         self.assertTrue(self.client._provider_tree.exists(uuids.compute_node))
1100         get_agg_mock.assert_called_once_with(uuids.compute_node)
1101         self.assertIn(uuids.compute_node, self.client._provider_aggregate_map)
1102         self.assertEqual(
1103             get_agg_mock.return_value,
1104             self.client._provider_aggregate_map[uuids.compute_node]
1105         )
1106         self.assertTrue(self.client._provider_tree.exists(uuids.compute_node))
1107         self.assertFalse(create_rp_mock.called)
1108 
1109     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1110                 '_create_resource_provider')
1111     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1112                 '_get_provider_aggregates')
1113     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1114                 '_get_resource_provider')
1115     def test_ensure_resource_provider_create_none(self, get_rp_mock,
1116             get_agg_mock, create_rp_mock):
1117         # No resource provider exists in the client's cache, and
1118         # _create_provider returns None, indicating there was an error with the
1119         # create call. Ensure we don't populate the resource provider cache
1120         # with a None value.
1121         get_rp_mock.return_value = None
1122 
1123         # This represents the "weird timing bug" or "intermittent placement API
1124         # snafu" code path.
1125         create_rp_mock.return_value = None
1126         self.assertIsNone(
1127             self.client._ensure_resource_provider(uuids.compute_node))
1128 
1129         get_rp_mock.assert_called_once_with(uuids.compute_node)
1130         create_rp_mock.assert_called_once_with(
1131             uuids.compute_node, uuids.compute_node, parent_provider_uuid=None)
1132         self.assertFalse(self.client._provider_tree.exists(uuids.compute_node))
1133         self.assertFalse(get_agg_mock.called)
1134         self.assertEqual({}, self.client._provider_aggregate_map)
1135 
1136     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1137                 '_create_resource_provider')
1138     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1139                 '_get_provider_aggregates')
1140     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1141                 '_get_resource_provider')
1142     def test_ensure_resource_provider_create(self, get_rp_mock, get_agg_mock,
1143             create_rp_mock):
1144         def validate_ptnode(ptnode):
1145             self.assertEqual(uuids.compute_node, ptnode.uuid)
1146             self.assertEqual('compute-name', ptnode.name)
1147             self.assertEqual(1, ptnode.generation)
1148             self.assertIsNone(ptnode.parent_uuid)
1149         # No resource provider exists in the client's cache and no resource
1150         # provider was returned from the placement API, so verify that in this
1151         # case we try to create the resource provider via the placement API.
1152         get_rp_mock.return_value = None
1153         create_rp_mock.return_value = {
1154             'uuid': uuids.compute_node,
1155             'name': 'compute-name',
1156             'generation': 1,
1157         }
1158         validate_ptnode(
1159             self.client._ensure_resource_provider(uuids.compute_node))
1160 
1161         get_agg_mock.assert_called_once_with(uuids.compute_node)
1162         self.assertIn(uuids.compute_node, self.client._provider_aggregate_map)
1163         self.assertEqual(
1164             get_agg_mock.return_value,
1165             self.client._provider_aggregate_map[uuids.compute_node]
1166         )
1167         get_rp_mock.assert_called_once_with(uuids.compute_node)
1168         create_rp_mock.assert_called_once_with(
1169                 uuids.compute_node,
1170                 uuids.compute_node,  # name param defaults to UUID if None
1171                 parent_provider_uuid=None,
1172         )
1173         self.assertTrue(self.client._provider_tree.exists(uuids.compute_node))
1174 
1175         create_rp_mock.reset_mock()
1176 
1177         # The same ProviderTree node is returned
1178         validate_ptnode(
1179             self.client._ensure_resource_provider(uuids.compute_node,
1180                                                   'compute-name'))
1181 
1182         # Shouldn't be called now that provider is in cache...
1183         self.assertFalse(create_rp_mock.called)
1184 
1185         # Validate the path where we specify a name (don't default to the UUID)
1186         self.client._ensure_resource_provider(uuids.cn2, 'a-name')
1187         create_rp_mock.assert_called_once_with(
1188                 uuids.cn2, 'a-name', parent_provider_uuid=None)
1189 
1190     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1191                 '_refresh_aggregate_map', new=mock.Mock())
1192     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1193                 '_create_resource_provider')
1194     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1195                 '_get_resource_provider')
1196     def test_ensure_resource_provider_tree(self, get_rp_mock, create_rp_mock):
1197         """Test _ensure_resource_provider with a tree of providers."""
1198         def _create_resource_provider(uuid, name, parent_provider_uuid=None):
1199             """Mock side effect for creating the RP with the specified args."""
1200             return {
1201                 'uuid': uuid,
1202                 'name': name,
1203                 'generation': 0,
1204                 'parent_provider_uuid': parent_provider_uuid
1205             }
1206         create_rp_mock.side_effect = _create_resource_provider
1207 
1208         # Not initially in the placement database, so we have to create it.
1209         get_rp_mock.return_value = None
1210 
1211         # Create the root
1212         root = self.client._ensure_resource_provider(uuids.root)
1213         self.assertEqual(uuids.root, root.uuid)
1214         self.assertIsNone(root.parent_uuid)
1215 
1216         # Now create a child
1217         child1 = self.client._ensure_resource_provider(
1218             uuids.child1, name='junior', parent_provider_uuid=uuids.root)
1219         self.assertEqual(uuids.child1, child1.uuid)
1220         self.assertEqual('junior', child1.name)
1221         self.assertEqual(uuids.root, child1.parent_uuid)
1222 
1223         # If we re-ensure the child, we get the object from the tree, not a
1224         # newly-created one - i.e. the early .find() works like it should.
1225         self.assertIs(child1,
1226                       self.client._ensure_resource_provider(uuids.child1))
1227 
1228         # Make sure we can create a grandchild
1229         grandchild = self.client._ensure_resource_provider(
1230             uuids.grandchild, parent_provider_uuid=uuids.child1)
1231         self.assertEqual(uuids.grandchild, grandchild.uuid)
1232         # Name defaulted to UUID
1233         self.assertEqual(uuids.grandchild, grandchild.name)
1234         # Its parent is child1 (not root)
1235         self.assertEqual(uuids.child1, grandchild.parent_uuid)
1236 
1237         # Now create a second child of the root and make sure it doesn't wind
1238         # up in some crazy wrong place like under child1 or grandchild
1239         child2 = self.client._ensure_resource_provider(
1240             uuids.child2, parent_provider_uuid=uuids.root)
1241         self.assertEqual(uuids.root, child2.parent_uuid)
1242 
1243         # At this point we should get all the providers by iterating on root.
1244         self.assertEqual(set([root, child1, child2, grandchild]),
1245                          set([p for p in root]))
1246 
1247     def test_get_allocation_candidates(self):
1248         resp_mock = mock.Mock(status_code=200)
1249         json_data = {
1250             'allocation_requests': mock.sentinel.alloc_reqs,
1251             'provider_summaries': mock.sentinel.p_sums,
1252         }
1253         resources = scheduler_utils.ResourceRequest.from_extra_specs({
1254             'resources:VCPU': '1',
1255             'resources:MEMORY_MB': '1024',
1256             'resources1:DISK_GB': '30',
1257             'trait:CUSTOM_TRAIT1': 'required',
1258             'trait:CUSTOM_TRAIT2': 'preferred',
1259         })
1260 
1261         resp_mock.json.return_value = json_data
1262         self.ks_adap_mock.get.return_value = resp_mock
1263 
1264         alloc_reqs, p_sums = self.client.get_allocation_candidates(resources)
1265 
1266         expected_url = '/allocation_candidates?%s' % parse.urlencode(
1267             {'resources': 'MEMORY_MB:1024,VCPU:1'})
1268         self.ks_adap_mock.get.assert_called_once_with(
1269             expected_url, raise_exc=False, microversion='1.10')
1270         self.assertEqual(mock.sentinel.alloc_reqs, alloc_reqs)
1271         self.assertEqual(mock.sentinel.p_sums, p_sums)
1272 
1273     def test_get_allocation_candidates_not_found(self):
1274         # Ensure _get_resource_provider() just returns None when the placement
1275         # API doesn't find a resource provider matching a UUID
1276         resp_mock = mock.Mock(status_code=404)
1277         self.ks_adap_mock.get.return_value = resp_mock
1278 
1279         resources = scheduler_utils.ResourceRequest.from_extra_specs(
1280             {'resources:MEMORY_MB': '1024'})
1281 
1282         res = self.client.get_allocation_candidates(resources)
1283 
1284         expected_url = '/allocation_candidates?resources=MEMORY_MB%3A1024'
1285         self.ks_adap_mock.get.assert_called_once_with(
1286             expected_url, raise_exc=False, microversion='1.10')
1287         self.assertIsNone(res[0])
1288         self.assertIsNone(res[0])
1289 
1290     def test_get_resource_provider_found(self):
1291         # Ensure _get_resource_provider() returns a dict of resource provider
1292         # if it finds a resource provider record from the placement API
1293         uuid = uuids.compute_node
1294         resp_mock = mock.Mock(status_code=200)
1295         json_data = {
1296             'uuid': uuid,
1297             'name': uuid,
1298             'generation': 42,
1299             'parent_provider_uuid': None,
1300         }
1301         resp_mock.json.return_value = json_data
1302         self.ks_adap_mock.get.return_value = resp_mock
1303 
1304         result = self.client._get_resource_provider(uuid)
1305 
1306         expected_provider_dict = dict(
1307                 uuid=uuid,
1308                 name=uuid,
1309                 generation=42,
1310                 parent_provider_uuid=None,
1311         )
1312         expected_url = '/resource_providers/' + uuid
1313         self.ks_adap_mock.get.assert_called_once_with(
1314             expected_url, raise_exc=False, microversion='1.12')
1315         self.assertEqual(expected_provider_dict, result)
1316 
1317     def test_get_resource_provider_not_found(self):
1318         # Ensure _get_resource_provider() just returns None when the placement
1319         # API doesn't find a resource provider matching a UUID
1320         resp_mock = mock.Mock(status_code=404)
1321         self.ks_adap_mock.get.return_value = resp_mock
1322 
1323         uuid = uuids.compute_node
1324         result = self.client._get_resource_provider(uuid)
1325 
1326         expected_url = '/resource_providers/' + uuid
1327         self.ks_adap_mock.get.assert_called_once_with(
1328             expected_url, raise_exc=False, microversion='1.12')
1329         self.assertIsNone(result)
1330 
1331     @mock.patch.object(report.LOG, 'error')
1332     def test_get_resource_provider_error(self, logging_mock):
1333         # Ensure _get_resource_provider() sets the error flag when trying to
1334         # communicate with the placement API and not getting an error we can
1335         # deal with
1336         resp_mock = mock.Mock(status_code=503)
1337         self.ks_adap_mock.get.return_value = resp_mock
1338         self.ks_adap_mock.get.return_value.headers = {
1339             'openstack-request-id': uuids.request_id}
1340 
1341         uuid = uuids.compute_node
1342         result = self.client._get_resource_provider(uuid)
1343 
1344         expected_url = '/resource_providers/' + uuid
1345         self.ks_adap_mock.get.assert_called_once_with(
1346             expected_url, raise_exc=False, microversion='1.12')
1347         # A 503 Service Unavailable should trigger an error log that
1348         # includes the placement request id and return None
1349         # from _get_resource_provider()
1350         self.assertTrue(logging_mock.called)
1351         self.assertIsNone(result)
1352         self.assertEqual(uuids.request_id,
1353                          logging_mock.call_args[0][1]['placement_req_id'])
1354 
1355     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1356                 '_get_resource_provider')
1357     def test_create_resource_provider(self, get_rp_mock):
1358         """Test that _create_resource_provider() sends a dict of resource
1359         provider information without a parent provider UUID.
1360         """
1361         uuid = uuids.compute_node
1362         name = 'computehost'
1363         resp_mock = mock.Mock(status_code=201)
1364         self.ks_adap_mock.post.return_value = resp_mock
1365         get_rp_mock.return_value = mock.sentinel.get_rp
1366 
1367         self.client._create_resource_provider(uuid, name)
1368 
1369         expected_payload = {
1370             'uuid': uuid,
1371             'name': name,
1372         }
1373 
1374         expected_url = '/resource_providers'
1375         self.ks_adap_mock.post.assert_called_once_with(
1376             expected_url, json=expected_payload, raise_exc=False,
1377             microversion='1.12')
1378 
1379     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1380                 '_get_resource_provider')
1381     def test_create_resource_provider_with_parent(self, get_rp_mock):
1382         """Test that when specifying a parent provider UUID, that the
1383         parent_provider_uuid part of the payload is properly specified.
1384         """
1385         parent_uuid = uuids.parent
1386         uuid = uuids.compute_node
1387         name = 'computehost'
1388         resp_mock = mock.Mock(status_code=201)
1389         self.ks_adap_mock.post.return_value = resp_mock
1390         get_rp_mock.return_value = mock.sentinel.get_rp
1391 
1392         result = self.client._create_resource_provider(
1393             uuid,
1394             name,
1395             parent_provider_uuid=parent_uuid,
1396         )
1397 
1398         expected_payload = {
1399             'uuid': uuid,
1400             'name': name,
1401             'parent_provider_uuid': parent_uuid,
1402         }
1403         expected_provider_dict = dict(
1404             uuid=uuid,
1405             name=name,
1406             generation=0,
1407             parent_provider_uuid=parent_uuid,
1408         )
1409         expected_url = '/resource_providers'
1410         self.ks_adap_mock.post.assert_called_once_with(
1411             expected_url, json=expected_payload, raise_exc=False,
1412             microversion='1.12')
1413         self.assertEqual(expected_provider_dict, result)
1414 
1415     @mock.patch.object(report.LOG, 'info')
1416     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1417                 '_get_resource_provider')
1418     def test_create_resource_provider_concurrent_create(self, get_rp_mock,
1419                                                         logging_mock):
1420         # Ensure _create_resource_provider() returns a dict of resource
1421         # provider gotten from _get_resource_provider() if the call to create
1422         # the resource provider in the placement API returned a 409 Conflict,
1423         # indicating another thread concurrently created the resource provider
1424         # record.
1425         uuid = uuids.compute_node
1426         name = 'computehost'
1427         resp_mock = mock.Mock(status_code=409)
1428         self.ks_adap_mock.post.return_value = resp_mock
1429         self.ks_adap_mock.post.return_value.headers = {
1430             'openstack-request-id': uuids.request_id}
1431 
1432         get_rp_mock.return_value = mock.sentinel.get_rp
1433 
1434         result = self.client._create_resource_provider(uuid, name)
1435 
1436         expected_payload = {
1437             'uuid': uuid,
1438             'name': name,
1439         }
1440         expected_url = '/resource_providers'
1441         self.ks_adap_mock.post.assert_called_once_with(
1442             expected_url, json=expected_payload, raise_exc=False,
1443             microversion='1.12')
1444         self.assertEqual(mock.sentinel.get_rp, result)
1445         # The 409 response will produce a message to the info log.
1446         self.assertTrue(logging_mock.called)
1447         self.assertEqual(uuids.request_id,
1448                         logging_mock.call_args[0][1]['placement_req_id'])
1449 
1450     @mock.patch.object(report.LOG, 'error')
1451     def test_create_resource_provider_error(self, logging_mock):
1452         # Ensure _create_resource_provider() sets the error flag when trying to
1453         # communicate with the placement API and not getting an error we can
1454         # deal with
1455         uuid = uuids.compute_node
1456         name = 'computehost'
1457         resp_mock = mock.Mock(status_code=503)
1458         self.ks_adap_mock.post.return_value = resp_mock
1459         self.ks_adap_mock.post.return_value.headers = {
1460             'x-openstack-request-id': uuids.request_id}
1461 
1462         result = self.client._create_resource_provider(uuid, name)
1463 
1464         expected_payload = {
1465             'uuid': uuid,
1466             'name': name,
1467         }
1468         expected_url = '/resource_providers'
1469         self.ks_adap_mock.post.assert_called_once_with(
1470             expected_url, json=expected_payload, raise_exc=False,
1471             microversion='1.12')
1472         # A 503 Service Unavailable should log an error that
1473         # includes the placement request id and
1474         # _create_resource_provider() should return None
1475         self.assertTrue(logging_mock.called)
1476         self.assertEqual(uuids.request_id,
1477                         logging_mock.call_args[0][1]['placement_req_id'])
1478         self.assertFalse(result)
1479 
1480 
1481 class TestAggregates(SchedulerReportClientTestCase):
1482     def test_get_provider_aggregates_found(self):
1483         """Test that when the placement API returns a list of aggregate UUIDs,
1484         that we cache that aggregate information in the appropriate map.
1485         """
1486         uuid = uuids.compute_node
1487         resp_mock = mock.Mock(status_code=200)
1488         json_data = {
1489             'aggregates': [
1490                 uuids.agg1,
1491                 uuids.agg2,
1492             ],
1493         }
1494         resp_mock.json.return_value = json_data
1495         self.ks_adap_mock.get.return_value = resp_mock
1496 
1497         result = self.client._get_provider_aggregates(uuid)
1498 
1499         expected = set([
1500             uuids.agg1,
1501             uuids.agg2,
1502         ])
1503         expected_url = '/resource_providers/' + uuid + '/aggregates'
1504         self.ks_adap_mock.get.assert_called_once_with(
1505             expected_url, raise_exc=False, microversion='1.1')
1506         self.assertEqual(expected, result)
1507 
1508     @mock.patch.object(report.LOG, 'warning')
1509     def test_get_provider_aggregates_not_found(self, log_mock):
1510         """Test that when the placement API returns a 404 when looking up a
1511         provider's aggregates, that we simply return None and log a warning
1512         (since _get_provider_aggregates() should be called after
1513         _ensure_resource_provider()).
1514         """
1515         uuid = uuids.compute_node
1516         resp_mock = mock.Mock(status_code=404)
1517         self.ks_adap_mock.get.return_value = resp_mock
1518         self.ks_adap_mock.get.return_value.headers = {
1519             'x-openstack-request-id': uuids.request_id}
1520 
1521         result = self.client._get_provider_aggregates(uuid)
1522 
1523         expected_url = '/resource_providers/' + uuid + '/aggregates'
1524         self.ks_adap_mock.get.assert_called_once_with(
1525             expected_url, raise_exc=False, microversion='1.1')
1526         self.assertTrue(log_mock.called)
1527         self.assertEqual(uuids.request_id,
1528                         log_mock.call_args[0][1]['placement_req_id'])
1529         self.assertIsNone(result)
1530 
1531     @mock.patch.object(report.LOG, 'error')
1532     def test_get_provider_aggregates_bad_request(self, log_mock):
1533         """Test that when the placement API returns a 400 when looking up a
1534         provider's aggregates, that we simply return None and log an error.
1535         """
1536         uuid = uuids.compute_node
1537         resp_mock = mock.Mock(status_code=400)
1538         self.ks_adap_mock.get.return_value = resp_mock
1539         self.ks_adap_mock.get.return_value.headers = {
1540             'x-openstack-request-id': uuids.request_id}
1541 
1542         result = self.client._get_provider_aggregates(uuid)
1543 
1544         expected_url = '/resource_providers/' + uuid + '/aggregates'
1545         self.ks_adap_mock.get.assert_called_once_with(
1546             expected_url, raise_exc=False, microversion='1.1')
1547         self.assertTrue(log_mock.called)
1548         self.assertEqual(uuids.request_id,
1549                         log_mock.call_args[0][1]['placement_req_id'])
1550         self.assertIsNone(result)
1551 
1552     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1553                 '_get_provider_aggregates')
1554     def test_refresh_aggregate_map_no_last(self, mock_get):
1555         """Test that refresh aggregate map is called when the map is
1556         stale.
1557         """
1558         uuid = uuids.compute_node
1559         self.client._refresh_aggregate_map(uuid)
1560         mock_get.assert_called_once_with(uuid)
1561         self.assertIn(uuid, self.client.aggregate_refresh_time)
1562 
1563     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1564                 '_get_provider_aggregates')
1565     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1566                 '_aggregate_map_stale')
1567     def test_refresh_aggregate_map_not_stale(self, mock_stale, mock_get):
1568         """Test that refresh aggregate map is not called when the map is
1569         not stale.
1570         """
1571         mock_stale.return_value = False
1572         uuid = uuids.compute_node
1573         self.client._refresh_aggregate_map(uuid)
1574         mock_get.assert_not_called()
1575         self.assertFalse(self.client.aggregate_refresh_time)
1576 
1577     @mock.patch.object(report.LOG, 'debug')
1578     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1579                 '_get_provider_aggregates')
1580     def test_refresh_aggregate_map_time(self, mock_get, log_mock):
1581         """Test that refresh aggregate map is called when the map is
1582         stale.
1583         """
1584         uuid = uuids.compute_node
1585         mock_get.return_value = set([])
1586 
1587         # Called a first time because aggregate_refresh_time is empty.
1588         now = time.time()
1589         self.client._refresh_aggregate_map(uuid)
1590         mock_get.assert_called_once_with(uuid)
1591         log_mock.assert_called_once_with(
1592                 'Refreshing aggregate associations for resource '
1593                 'provider %s, aggregates: %s', uuid, 'None')
1594         self.assertIn(uuid, self.client.aggregate_refresh_time)
1595 
1596         # Clear call count.
1597         mock_get.reset_mock()
1598 
1599         with mock.patch('time.time') as mock_future:
1600             # Not called a second time because not enough time has passed.
1601             mock_future.return_value = now + report.AGGREGATE_REFRESH / 2
1602             self.client._refresh_aggregate_map(uuid)
1603             mock_get.assert_not_called()
1604 
1605             # Called because time has passed.
1606             mock_future.return_value = now + report.AGGREGATE_REFRESH + 1
1607             self.client._refresh_aggregate_map(uuid)
1608             mock_get.assert_called_once_with(uuid)
1609 
1610 
1611 class TestComputeNodeToInventoryDict(test.NoDBTestCase):
1612     def test_compute_node_inventory(self):
1613         uuid = uuids.compute_node
1614         name = 'computehost'
1615         compute_node = objects.ComputeNode(uuid=uuid,
1616                                            hypervisor_hostname=name,
1617                                            vcpus=2,
1618                                            cpu_allocation_ratio=16.0,
1619                                            memory_mb=1024,
1620                                            ram_allocation_ratio=1.5,
1621                                            local_gb=10,
1622                                            disk_allocation_ratio=1.0)
1623 
1624         self.flags(reserved_host_memory_mb=1000)
1625         self.flags(reserved_host_disk_mb=200)
1626         self.flags(reserved_host_cpus=1)
1627 
1628         result = report._compute_node_to_inventory_dict(compute_node)
1629 
1630         expected = {
1631             'VCPU': {
1632                 'total': compute_node.vcpus,
1633                 'reserved': CONF.reserved_host_cpus,
1634                 'min_unit': 1,
1635                 'max_unit': compute_node.vcpus,
1636                 'step_size': 1,
1637                 'allocation_ratio': compute_node.cpu_allocation_ratio,
1638             },
1639             'MEMORY_MB': {
1640                 'total': compute_node.memory_mb,
1641                 'reserved': CONF.reserved_host_memory_mb,
1642                 'min_unit': 1,
1643                 'max_unit': compute_node.memory_mb,
1644                 'step_size': 1,
1645                 'allocation_ratio': compute_node.ram_allocation_ratio,
1646             },
1647             'DISK_GB': {
1648                 'total': compute_node.local_gb,
1649                 'reserved': 1,  # this is ceil(1000/1024)
1650                 'min_unit': 1,
1651                 'max_unit': compute_node.local_gb,
1652                 'step_size': 1,
1653                 'allocation_ratio': compute_node.disk_allocation_ratio,
1654             },
1655         }
1656         self.assertEqual(expected, result)
1657 
1658     def test_compute_node_inventory_empty(self):
1659         uuid = uuids.compute_node
1660         name = 'computehost'
1661         compute_node = objects.ComputeNode(uuid=uuid,
1662                                            hypervisor_hostname=name,
1663                                            vcpus=0,
1664                                            cpu_allocation_ratio=16.0,
1665                                            memory_mb=0,
1666                                            ram_allocation_ratio=1.5,
1667                                            local_gb=0,
1668                                            disk_allocation_ratio=1.0)
1669         result = report._compute_node_to_inventory_dict(compute_node)
1670         self.assertEqual({}, result)
1671 
1672 
1673 class TestInventory(SchedulerReportClientTestCase):
1674     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1675                 '_ensure_resource_provider')
1676     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1677                 '_delete_inventory')
1678     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1679                 '_update_inventory')
1680     def test_update_compute_node(self, mock_ui, mock_delete, mock_erp):
1681         cn = self.compute_node
1682         self.client.update_compute_node(cn)
1683         mock_erp.assert_called_once_with(cn.uuid, cn.hypervisor_hostname)
1684         expected_inv_data = {
1685             'VCPU': {
1686                 'total': 8,
1687                 'reserved': CONF.reserved_host_cpus,
1688                 'min_unit': 1,
1689                 'max_unit': 8,
1690                 'step_size': 1,
1691                 'allocation_ratio': 16.0,
1692             },
1693             'MEMORY_MB': {
1694                 'total': 1024,
1695                 'reserved': 512,
1696                 'min_unit': 1,
1697                 'max_unit': 1024,
1698                 'step_size': 1,
1699                 'allocation_ratio': 1.5,
1700             },
1701             'DISK_GB': {
1702                 'total': 10,
1703                 'reserved': 0,
1704                 'min_unit': 1,
1705                 'max_unit': 10,
1706                 'step_size': 1,
1707                 'allocation_ratio': 1.0,
1708             },
1709         }
1710         mock_ui.assert_called_once_with(
1711             cn.uuid,
1712             expected_inv_data,
1713         )
1714         self.assertFalse(mock_delete.called)
1715 
1716     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1717                 '_ensure_resource_provider')
1718     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1719                 '_delete_inventory')
1720     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1721                 '_update_inventory')
1722     def test_update_compute_node_no_inv(self, mock_ui, mock_delete,
1723             mock_erp):
1724         """Ensure that if there are no inventory records, that we call
1725         _delete_inventory() instead of _update_inventory().
1726         """
1727         cn = self.compute_node
1728         cn.vcpus = 0
1729         cn.memory_mb = 0
1730         cn.local_gb = 0
1731         self.client.update_compute_node(cn)
1732         mock_erp.assert_called_once_with(cn.uuid, cn.hypervisor_hostname)
1733         mock_delete.assert_called_once_with(cn.uuid)
1734         self.assertFalse(mock_ui.called)
1735 
1736     @mock.patch.object(report.LOG, 'info')
1737     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1738                 'put')
1739     @mock.patch.object(report.LOG, 'info')
1740     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1741                 'delete')
1742     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1743                 'get')
1744     def test_delete_inventory(self, mock_get, mock_delete, mock_debug,
1745                               mock_put, mock_info):
1746         cn = self.compute_node
1747         # Make sure the resource provider exists for preventing to call the API
1748         self._init_provider_tree()
1749 
1750         mock_get.return_value.json.return_value = {
1751             'resource_provider_generation': 1,
1752             'inventories': {
1753                 'VCPU': {'total': 16},
1754             }
1755         }
1756         mock_delete.return_value.status_code = 204
1757         mock_delete.return_value.headers = {'openstack-request-id':
1758                                             uuids.request_id}
1759         result = self.client._delete_inventory(cn.uuid)
1760         self.assertIsNone(result)
1761         self.assertFalse(mock_put.called)
1762         self.assertEqual(uuids.request_id,
1763                          mock_info.call_args[0][1]['placement_req_id'])
1764 
1765     @mock.patch('nova.scheduler.client.report._extract_inventory_in_use')
1766     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1767                 'delete')
1768     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1769                 'get')
1770     def test_delete_inventory_already_no_inventory(self, mock_get, mock_delete,
1771             mock_extract):
1772         cn = self.compute_node
1773         # Make sure the resource provider exists for preventing to call the API
1774         self._init_provider_tree()
1775 
1776         mock_get.return_value.json.return_value = {
1777             'resource_provider_generation': 1,
1778             'inventories': {
1779             }
1780         }
1781         result = self.client._delete_inventory(cn.uuid)
1782         self.assertIsNone(result)
1783         self.assertFalse(mock_delete.called)
1784         self.assertFalse(mock_extract.called)
1785         rp = self.client._provider_tree.find(cn.uuid)
1786         self.assertEqual(1, rp.generation)
1787 
1788     @mock.patch.object(report.LOG, 'info')
1789     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1790                 'put')
1791     @mock.patch.object(report.LOG, 'debug')
1792     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1793                 'delete')
1794     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1795                 'get')
1796     def test_delete_inventory_put(self, mock_get, mock_delete, mock_debug,
1797                                   mock_put, mock_info):
1798         cn = self.compute_node
1799         # Make sure the resource provider exists for preventing to call the API
1800         self._init_provider_tree()
1801 
1802         mock_get.return_value.json.return_value = {
1803             'resource_provider_generation': 1,
1804             'inventories': {
1805                 'DISK_GB': {'total': 10},
1806             }
1807         }
1808         mock_delete.return_value.status_code = 406
1809         mock_put.return_value.status_code = 200
1810         mock_put.return_value.json.return_value = {
1811             'resource_provider_generation': 44,
1812             'inventories': {
1813             }
1814         }
1815         mock_put.return_value.headers = {'openstack-request-id':
1816                                          uuids.request_id}
1817         result = self.client._delete_inventory(cn.uuid)
1818         self.assertIsNone(result)
1819         self.assertTrue(mock_debug.called)
1820         self.assertTrue(mock_put.called)
1821         self.assertTrue(mock_info.called)
1822         self.assertEqual(uuids.request_id,
1823                          mock_info.call_args[0][1]['placement_req_id'])
1824         rp = self.client._provider_tree.find(cn.uuid)
1825         self.assertEqual(44, rp.generation)
1826 
1827     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1828                 'put')
1829     @mock.patch.object(report.LOG, 'debug')
1830     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1831                 'delete')
1832     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1833                 'get')
1834     def test_delete_inventory_put_failover(self, mock_get, mock_delete,
1835                                            mock_debug, mock_put):
1836         cn = self.compute_node
1837         # Make sure the resource provider exists for preventing to call the API
1838         self._init_provider_tree()
1839 
1840         mock_get.return_value.json.return_value = {
1841             'resource_provider_generation': 42,
1842             'inventories': {
1843                 'DISK_GB': {'total': 10},
1844             }
1845         }
1846         mock_delete.return_value.status_code = 406
1847         mock_put.return_value.status_code = 200
1848         self.client._delete_inventory(cn.uuid)
1849         self.assertTrue(mock_debug.called)
1850         exp_url = '/resource_providers/%s/inventories' % cn.uuid
1851         payload = {
1852             'resource_provider_generation': 42,
1853             'inventories': {},
1854         }
1855         mock_put.assert_called_once_with(exp_url, payload)
1856 
1857     @mock.patch.object(report.LOG, 'error')
1858     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1859                 'put')
1860     @mock.patch.object(report.LOG, 'debug')
1861     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1862                 'delete')
1863     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1864                 'get')
1865     def test_delete_inventory_put_failover_in_use(self, mock_get, mock_delete,
1866                                                   mock_debug, mock_put,
1867                                                   mock_error):
1868         cn = self.compute_node
1869         # Make sure the resource provider exists for preventing to call the API
1870         self._init_provider_tree()
1871 
1872         mock_get.return_value.json.return_value = {
1873             'resource_provider_generation': 42,
1874             'inventories': {
1875                 'DISK_GB': {'total': 10},
1876             }
1877         }
1878         mock_delete.return_value.status_code = 406
1879         mock_put.return_value.status_code = 409
1880         mock_put.return_value.text = (
1881             'There was a *fake* failure: inventory in use'
1882         )
1883         mock_put.return_value.json.return_value = {
1884             'resource_provider_generation': 44,
1885             'inventories': {
1886             }
1887         }
1888         mock_put.return_value.headers = {'openstack-request-id':
1889                                          uuids.request_id}
1890         self.client._delete_inventory(cn.uuid)
1891         self.assertTrue(mock_debug.called)
1892         rp = self.client._provider_tree.find(cn.uuid)
1893         exp_url = '/resource_providers/%s/inventories' % cn.uuid
1894         payload = {
1895             'resource_provider_generation': rp.generation,
1896             'inventories': {},
1897         }
1898         mock_put.assert_called_once_with(exp_url, payload)
1899         self.assertTrue(mock_error.called)
1900         self.assertEqual(uuids.request_id,
1901                          mock_error.call_args[0][1]['placement_req_id'])
1902 
1903     @mock.patch.object(report.LOG, 'warning')
1904     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1905                 'delete')
1906     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1907                 'get')
1908     def test_delete_inventory_inventory_in_use(self, mock_get, mock_delete,
1909             mock_warn):
1910         cn = self.compute_node
1911         # Make sure the resource provider exists for preventing to call the API
1912         self._init_provider_tree()
1913 
1914         mock_get.return_value.json.return_value = {
1915             'resource_provider_generation': 1,
1916             'inventories': {
1917                 'VCPU': {'total': 16},
1918                 'MEMORY_MB': {'total': 1024},
1919                 'DISK_GB': {'total': 10},
1920             }
1921         }
1922         mock_delete.return_value.status_code = 409
1923         mock_delete.return_value.headers = {'openstack-request-id':
1924                                          uuids.request_id}
1925         rc_str = "VCPU, MEMORY_MB"
1926         in_use_exc = exception.InventoryInUse(
1927             resource_classes=rc_str,
1928             resource_provider=cn.uuid,
1929         )
1930         fault_text = """
1931 409 Conflict
1932 
1933 There was a conflict when trying to complete your request.
1934 
1935  update conflict: %s
1936  """ % six.text_type(in_use_exc)
1937         mock_delete.return_value.text = fault_text
1938         mock_delete.return_value.json.return_value = {
1939             'resource_provider_generation': 44,
1940             'inventories': {
1941             }
1942         }
1943         result = self.client._delete_inventory(cn.uuid)
1944         self.assertIsNone(result)
1945         self.assertTrue(mock_warn.called)
1946         self.assertEqual(uuids.request_id,
1947                          mock_warn.call_args[0][1]['placement_req_id'])
1948 
1949     @mock.patch.object(report.LOG, 'debug')
1950     @mock.patch.object(report.LOG, 'info')
1951     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1952                 'delete')
1953     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1954                 'get')
1955     def test_delete_inventory_inventory_404(self, mock_get, mock_delete,
1956                                             mock_info, mock_debug):
1957         """Test that when we attempt to delete all the inventory for a resource
1958         provider but another thread has already deleted that resource provider,
1959         that we simply remove the resource provider from our local cache and
1960         return.
1961         """
1962         cn = self.compute_node
1963         # Make sure the resource provider exists for preventing to call the API
1964         self._init_provider_tree()
1965 
1966         mock_get.return_value.json.return_value = {
1967             'resource_provider_generation': 1,
1968             'inventories': {
1969                 'VCPU': {'total': 16},
1970                 'MEMORY_MB': {'total': 1024},
1971                 'DISK_GB': {'total': 10},
1972             }
1973         }
1974         mock_delete.return_value.status_code = 404
1975         mock_delete.return_value.headers = {'openstack-request-id':
1976                                             uuids.request_id}
1977         result = self.client._delete_inventory(cn.uuid)
1978         self.assertIsNone(result)
1979         self.assertRaises(ValueError, self.client._provider_tree.find, cn.uuid)
1980         self.assertTrue(mock_debug.called)
1981         self.assertIn('deleted by another thread', mock_debug.call_args[0][0])
1982         self.assertEqual(uuids.request_id,
1983                          mock_debug.call_args[0][1]['placement_req_id'])
1984 
1985     @mock.patch.object(report.LOG, 'error')
1986     @mock.patch.object(report.LOG, 'warning')
1987     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1988                 'delete')
1989     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
1990                 'get')
1991     def test_delete_inventory_inventory_error(self, mock_get, mock_delete,
1992             mock_warn, mock_error):
1993         cn = self.compute_node
1994         # Make sure the resource provider exists for preventing to call the API
1995         self._init_provider_tree()
1996 
1997         mock_get.return_value.json.return_value = {
1998             'resource_provider_generation': 1,
1999             'inventories': {
2000                 'VCPU': {'total': 16},
2001                 'MEMORY_MB': {'total': 1024},
2002                 'DISK_GB': {'total': 10},
2003             }
2004         }
2005         mock_delete.return_value.status_code = 409
2006         mock_delete.return_value.text = (
2007             'There was a failure'
2008         )
2009         mock_delete.return_value.json.return_value = {
2010             'resource_provider_generation': 44,
2011             'inventories': {
2012             }
2013         }
2014         mock_delete.return_value.headers = {'openstack-request-id':
2015                                          uuids.request_id}
2016         result = self.client._delete_inventory(cn.uuid)
2017         self.assertIsNone(result)
2018         self.assertFalse(mock_warn.called)
2019         self.assertTrue(mock_error.called)
2020         self.assertEqual(uuids.request_id,
2021                          mock_error.call_args[0][1]['placement_req_id'])
2022 
2023     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2024                 'get')
2025     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2026                 'put')
2027     def test_update_inventory_initial_empty(self, mock_put, mock_get):
2028         # Ensure _update_inventory() returns a list of Inventories objects
2029         # after creating or updating the existing values
2030         uuid = uuids.compute_node
2031         compute_node = self.compute_node
2032         # Make sure the resource provider exists for preventing to call the API
2033         self._init_provider_tree(resources_override={})
2034 
2035         mock_get.return_value.json.return_value = {
2036             'resource_provider_generation': 43,
2037             'inventories': {
2038                 'VCPU': {'total': 16},
2039                 'MEMORY_MB': {'total': 1024},
2040                 'DISK_GB': {'total': 10},
2041             }
2042         }
2043         mock_put.return_value.status_code = 200
2044         mock_put.return_value.json.return_value = {
2045             'resource_provider_generation': 44,
2046             'inventories': {
2047                 'VCPU': {'total': 16},
2048                 'MEMORY_MB': {'total': 1024},
2049                 'DISK_GB': {'total': 10},
2050             }
2051         }
2052 
2053         inv_data = report._compute_node_to_inventory_dict(compute_node)
2054         result = self.client._update_inventory_attempt(
2055             compute_node.uuid, inv_data
2056         )
2057         self.assertTrue(result)
2058 
2059         exp_url = '/resource_providers/%s/inventories' % uuid
2060         mock_get.assert_called_once_with(exp_url)
2061         # Updated with the new inventory from the PUT call
2062         rp = self.client._provider_tree.find(uuid)
2063         self.assertEqual(44, rp.generation)
2064         expected = {
2065             # Called with the newly-found generation from the existing
2066             # inventory
2067             'resource_provider_generation': 43,
2068             'inventories': {
2069                 'VCPU': {
2070                     'total': 8,
2071                     'reserved': CONF.reserved_host_cpus,
2072                     'min_unit': 1,
2073                     'max_unit': compute_node.vcpus,
2074                     'step_size': 1,
2075                     'allocation_ratio': compute_node.cpu_allocation_ratio,
2076                 },
2077                 'MEMORY_MB': {
2078                     'total': 1024,
2079                     'reserved': CONF.reserved_host_memory_mb,
2080                     'min_unit': 1,
2081                     'max_unit': compute_node.memory_mb,
2082                     'step_size': 1,
2083                     'allocation_ratio': compute_node.ram_allocation_ratio,
2084                 },
2085                 'DISK_GB': {
2086                     'total': 10,
2087                     'reserved': CONF.reserved_host_disk_mb * 1024,
2088                     'min_unit': 1,
2089                     'max_unit': compute_node.local_gb,
2090                     'step_size': 1,
2091                     'allocation_ratio': compute_node.disk_allocation_ratio,
2092                 },
2093             }
2094         }
2095         mock_put.assert_called_once_with(exp_url, expected)
2096 
2097     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2098                 'get')
2099     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2100                 'put')
2101     def test_update_inventory(self, mock_put, mock_get):
2102         # Ensure _update_inventory() returns a list of Inventories objects
2103         # after creating or updating the existing values
2104         uuid = uuids.compute_node
2105         compute_node = self.compute_node
2106         # Make sure the resource provider exists for preventing to call the API
2107         self._init_provider_tree()
2108         new_vcpus_total = 240
2109 
2110         mock_get.return_value.json.return_value = {
2111             'resource_provider_generation': 43,
2112             'inventories': {
2113                 'VCPU': {'total': 16},
2114                 'MEMORY_MB': {'total': 1024},
2115                 'DISK_GB': {'total': 10},
2116             }
2117         }
2118         mock_put.return_value.status_code = 200
2119         mock_put.return_value.json.return_value = {
2120             'resource_provider_generation': 44,
2121             'inventories': {
2122                 'VCPU': {'total': new_vcpus_total},
2123                 'MEMORY_MB': {'total': 1024},
2124                 'DISK_GB': {'total': 10},
2125             }
2126         }
2127 
2128         inv_data = report._compute_node_to_inventory_dict(compute_node)
2129         # Make a change to trigger the update...
2130         inv_data['VCPU']['total'] = new_vcpus_total
2131         result = self.client._update_inventory_attempt(
2132             compute_node.uuid, inv_data
2133         )
2134         self.assertTrue(result)
2135 
2136         exp_url = '/resource_providers/%s/inventories' % uuid
2137         mock_get.assert_called_once_with(exp_url)
2138         # Updated with the new inventory from the PUT call
2139         rp = self.client._provider_tree.find(uuid)
2140         self.assertEqual(44, rp.generation)
2141         expected = {
2142             # Called with the newly-found generation from the existing
2143             # inventory
2144             'resource_provider_generation': 43,
2145             'inventories': {
2146                 'VCPU': {
2147                     'total': new_vcpus_total,
2148                     'reserved': 0,
2149                     'min_unit': 1,
2150                     'max_unit': compute_node.vcpus,
2151                     'step_size': 1,
2152                     'allocation_ratio': compute_node.cpu_allocation_ratio,
2153                 },
2154                 'MEMORY_MB': {
2155                     'total': 1024,
2156                     'reserved': CONF.reserved_host_memory_mb,
2157                     'min_unit': 1,
2158                     'max_unit': compute_node.memory_mb,
2159                     'step_size': 1,
2160                     'allocation_ratio': compute_node.ram_allocation_ratio,
2161                 },
2162                 'DISK_GB': {
2163                     'total': 10,
2164                     'reserved': CONF.reserved_host_disk_mb * 1024,
2165                     'min_unit': 1,
2166                     'max_unit': compute_node.local_gb,
2167                     'step_size': 1,
2168                     'allocation_ratio': compute_node.disk_allocation_ratio,
2169                 },
2170             }
2171         }
2172         mock_put.assert_called_once_with(exp_url, expected)
2173 
2174     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2175                 'get')
2176     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2177                 'put')
2178     def test_update_inventory_no_update(self, mock_put, mock_get):
2179         """Simulate situation where scheduler client is first starting up and
2180         ends up loading information from the placement API via a GET against
2181         the resource provider's inventory but has no local cached inventory
2182         information for a resource provider.
2183         """
2184         uuid = uuids.compute_node
2185         compute_node = self.compute_node
2186         # Make sure the resource provider exists for preventing to call the API
2187         self._init_provider_tree(generation_override=42, resources_override={})
2188         mock_get.return_value.json.return_value = {
2189             'resource_provider_generation': 43,
2190             'inventories': {
2191                 'VCPU': {
2192                     'total': 8,
2193                     'reserved': CONF.reserved_host_cpus,
2194                     'min_unit': 1,
2195                     'max_unit': compute_node.vcpus,
2196                     'step_size': 1,
2197                     'allocation_ratio': compute_node.cpu_allocation_ratio,
2198                 },
2199                 'MEMORY_MB': {
2200                     'total': 1024,
2201                     'reserved': CONF.reserved_host_memory_mb,
2202                     'min_unit': 1,
2203                     'max_unit': compute_node.memory_mb,
2204                     'step_size': 1,
2205                     'allocation_ratio': compute_node.ram_allocation_ratio,
2206                 },
2207                 'DISK_GB': {
2208                     'total': 10,
2209                     'reserved': CONF.reserved_host_disk_mb * 1024,
2210                     'min_unit': 1,
2211                     'max_unit': compute_node.local_gb,
2212                     'step_size': 1,
2213                     'allocation_ratio': compute_node.disk_allocation_ratio,
2214                 },
2215             }
2216         }
2217         inv_data = report._compute_node_to_inventory_dict(compute_node)
2218         result = self.client._update_inventory_attempt(
2219             compute_node.uuid, inv_data
2220         )
2221         self.assertTrue(result)
2222         exp_url = '/resource_providers/%s/inventories' % uuid
2223         mock_get.assert_called_once_with(exp_url)
2224         # No update so put should not be called
2225         self.assertFalse(mock_put.called)
2226         # Make sure we updated the generation from the inventory records
2227         rp = self.client._provider_tree.find(compute_node.uuid)
2228         self.assertEqual(43, rp.generation)
2229 
2230     @mock.patch.object(report.LOG, 'info')
2231     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2232                 '_get_inventory')
2233     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2234                 'put')
2235     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2236                 '_ensure_resource_provider')
2237     def test_update_inventory_concurrent_update(self, mock_ensure,
2238                                                 mock_put, mock_get, mock_info):
2239         # Ensure _update_inventory() returns a list of Inventories objects
2240         # after creating or updating the existing values
2241         uuid = uuids.compute_node
2242         compute_node = self.compute_node
2243         # Make sure the resource provider exists for preventing to call the API
2244         self.client._provider_tree.new_root(
2245             compute_node.hypervisor_hostname,
2246             compute_node.uuid,
2247             42,
2248         )
2249 
2250         mock_get.return_value = {
2251             'resource_provider_generation': 42,
2252             'inventories': {},
2253         }
2254         mock_put.return_value.status_code = 409
2255         mock_put.return_value.text = 'Does not match inventory in use'
2256         mock_put.return_value.headers = {'x-openstack-request-id':
2257                                          uuids.request_id}
2258 
2259         inv_data = report._compute_node_to_inventory_dict(compute_node)
2260         result = self.client._update_inventory_attempt(
2261             compute_node.uuid, inv_data
2262         )
2263         self.assertFalse(result)
2264 
2265         # Invalidated the cache
2266         self.assertFalse(self.client._provider_tree.exists(uuid))
2267         # Refreshed our resource provider
2268         mock_ensure.assert_called_once_with(uuid)
2269         # Logged the request id in the log message
2270         self.assertEqual(uuids.request_id,
2271                          mock_info.call_args[0][1]['placement_req_id'])
2272 
2273     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2274                 '_get_inventory')
2275     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2276                 'put')
2277     def test_update_inventory_inventory_in_use(self, mock_put, mock_get):
2278         # Ensure _update_inventory() returns a list of Inventories objects
2279         # after creating or updating the existing values
2280         uuid = uuids.compute_node
2281         compute_node = self.compute_node
2282         # Make sure the resource provider exists for preventing to call the API
2283         self.client._provider_tree.new_root(
2284             compute_node.hypervisor_hostname,
2285             compute_node.uuid,
2286             42,
2287         )
2288 
2289         mock_get.return_value = {
2290             'resource_provider_generation': 42,
2291             'inventories': {},
2292         }
2293         mock_put.return_value.status_code = 409
2294         mock_put.return_value.text = (
2295             "update conflict: Inventory for VCPU on "
2296             "resource provider 123 in use"
2297         )
2298 
2299         inv_data = report._compute_node_to_inventory_dict(compute_node)
2300         self.assertRaises(
2301             exception.InventoryInUse,
2302             self.client._update_inventory_attempt,
2303             compute_node.uuid,
2304             inv_data,
2305         )
2306 
2307         # Did NOT invalidate the cache
2308         self.assertIsNotNone(self.client._provider_tree.find(uuid))
2309 
2310     @mock.patch.object(report.LOG, 'info')
2311     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2312                 '_get_inventory')
2313     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2314                 'put')
2315     def test_update_inventory_unknown_response(self, mock_put, mock_get,
2316                                                mock_info):
2317         # Ensure _update_inventory() returns a list of Inventories objects
2318         # after creating or updating the existing values
2319         uuid = uuids.compute_node
2320         compute_node = self.compute_node
2321         # Make sure the resource provider exists for preventing to call the API
2322         self.client._provider_tree.new_root(
2323             compute_node.hypervisor_hostname,
2324             compute_node.uuid,
2325             42,
2326         )
2327 
2328         mock_get.return_value = {
2329             'resource_provider_generation': 42,
2330             'inventories': {},
2331         }
2332         mock_put.return_value.status_code = 234
2333         mock_put.return_value.headers = {'openstack-request-id':
2334                                          uuids.request_id}
2335 
2336         inv_data = report._compute_node_to_inventory_dict(compute_node)
2337         result = self.client._update_inventory_attempt(
2338             compute_node.uuid, inv_data
2339         )
2340         self.assertFalse(result)
2341 
2342         # No cache invalidation
2343         self.assertTrue(self.client._provider_tree.exists(uuid))
2344 
2345     @mock.patch.object(report.LOG, 'warning')
2346     @mock.patch.object(report.LOG, 'debug')
2347     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2348                 '_get_inventory')
2349     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2350                 'put')
2351     def test_update_inventory_failed(self, mock_put, mock_get,
2352                                      mock_debug, mock_warn):
2353         # Ensure _update_inventory() returns a list of Inventories objects
2354         # after creating or updating the existing values
2355         uuid = uuids.compute_node
2356         compute_node = self.compute_node
2357         # Make sure the resource provider exists for preventing to call the API
2358         self.client._provider_tree.new_root(
2359             compute_node.hypervisor_hostname,
2360             compute_node.uuid,
2361             42,
2362         )
2363 
2364         mock_get.return_value = {
2365             'resource_provider_generation': 42,
2366             'inventories': {},
2367         }
2368         try:
2369             mock_put.return_value.__nonzero__.return_value = False
2370         except AttributeError:
2371             # Thanks py3
2372             mock_put.return_value.__bool__.return_value = False
2373         mock_put.return_value.headers = {'openstack-request-id':
2374                                          uuids.request_id}
2375 
2376         inv_data = report._compute_node_to_inventory_dict(compute_node)
2377         result = self.client._update_inventory_attempt(
2378             compute_node.uuid, inv_data
2379         )
2380         self.assertFalse(result)
2381 
2382         # No cache invalidation
2383         self.assertTrue(self.client._provider_tree.exists(uuid))
2384         # Logged the request id in the log messages
2385         self.assertEqual(uuids.request_id,
2386                          mock_debug.call_args[0][1]['placement_req_id'])
2387         self.assertEqual(uuids.request_id,
2388                          mock_warn.call_args[0][1]['placement_req_id'])
2389 
2390     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2391                 '_ensure_resource_provider')
2392     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2393                 '_update_inventory_attempt')
2394     @mock.patch('time.sleep')
2395     def test_update_inventory_fails_and_then_succeeds(self, mock_sleep,
2396                                                       mock_update,
2397                                                       mock_ensure):
2398         # Ensure _update_inventory() fails if we have a conflict when updating
2399         # but retries correctly.
2400         cn = self.compute_node
2401         mock_update.side_effect = (False, True)
2402 
2403         self.client._provider_tree.new_root(
2404             cn.hypervisor_hostname,
2405             cn.uuid,
2406             42,
2407         )
2408         result = self.client._update_inventory(
2409             cn.uuid, mock.sentinel.inv_data
2410         )
2411         self.assertTrue(result)
2412 
2413         # Only slept once
2414         mock_sleep.assert_called_once_with(1)
2415 
2416     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2417                 '_ensure_resource_provider')
2418     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2419                 '_update_inventory_attempt')
2420     @mock.patch('time.sleep')
2421     def test_update_inventory_never_succeeds(self, mock_sleep,
2422                                              mock_update,
2423                                              mock_ensure):
2424         # but retries correctly.
2425         cn = self.compute_node
2426         mock_update.side_effect = (False, False, False)
2427 
2428         self.client._provider_tree.new_root(
2429             cn.hypervisor_hostname,
2430             cn.uuid,
2431             42,
2432         )
2433         result = self.client._update_inventory(
2434             cn.uuid, mock.sentinel.inv_data
2435         )
2436         self.assertFalse(result)
2437 
2438         # Slept three times
2439         mock_sleep.assert_has_calls([mock.call(1), mock.call(1), mock.call(1)])
2440 
2441         # Three attempts to update
2442         mock_update.assert_has_calls([
2443             mock.call(cn.uuid, mock.sentinel.inv_data),
2444             mock.call(cn.uuid, mock.sentinel.inv_data),
2445             mock.call(cn.uuid, mock.sentinel.inv_data),
2446         ])
2447 
2448         # Slept three times
2449         mock_sleep.assert_has_calls([mock.call(1), mock.call(1), mock.call(1)])
2450 
2451     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2452                 '_update_inventory')
2453     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2454                 '_delete_inventory')
2455     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2456                 '_ensure_resource_class')
2457     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2458                 '_get_or_create_resource_class')
2459     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2460                 '_ensure_resource_provider')
2461     def test_set_inventory_for_provider_no_custom(self, mock_erp, mock_gocr,
2462             mock_erc, mock_del, mock_upd):
2463         """Tests that inventory records of all standard resource classes are
2464         passed to the report client's _update_inventory() method.
2465         """
2466         inv_data = {
2467             'VCPU': {
2468                 'total': 24,
2469                 'reserved': 0,
2470                 'min_unit': 1,
2471                 'max_unit': 24,
2472                 'step_size': 1,
2473                 'allocation_ratio': 1.0,
2474             },
2475             'MEMORY_MB': {
2476                 'total': 1024,
2477                 'reserved': 0,
2478                 'min_unit': 1,
2479                 'max_unit': 1024,
2480                 'step_size': 1,
2481                 'allocation_ratio': 1.0,
2482             },
2483             'DISK_GB': {
2484                 'total': 100,
2485                 'reserved': 0,
2486                 'min_unit': 1,
2487                 'max_unit': 100,
2488                 'step_size': 1,
2489                 'allocation_ratio': 1.0,
2490             },
2491         }
2492         self.client.set_inventory_for_provider(
2493             mock.sentinel.rp_uuid,
2494             mock.sentinel.rp_name,
2495             inv_data,
2496         )
2497         mock_erp.assert_called_once_with(
2498             mock.sentinel.rp_uuid,
2499             mock.sentinel.rp_name,
2500             parent_provider_uuid=None,
2501         )
2502         # No custom resource classes to ensure...
2503         self.assertFalse(mock_erc.called)
2504         self.assertFalse(mock_gocr.called)
2505         mock_upd.assert_called_once_with(
2506             mock.sentinel.rp_uuid,
2507             inv_data,
2508         )
2509         self.assertFalse(mock_del.called)
2510 
2511     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2512                 '_update_inventory')
2513     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2514                 '_delete_inventory')
2515     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2516                 '_ensure_resource_class')
2517     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2518                 '_get_or_create_resource_class')
2519     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2520                 '_ensure_resource_provider')
2521     def test_set_inventory_for_provider_no_inv(self, mock_erp, mock_gocr,
2522             mock_erc, mock_del, mock_upd):
2523         """Tests that passing empty set of inventory records triggers a delete
2524         of inventory for the provider.
2525         """
2526         inv_data = {}
2527         self.client.set_inventory_for_provider(
2528             mock.sentinel.rp_uuid,
2529             mock.sentinel.rp_name,
2530             inv_data,
2531         )
2532         mock_erp.assert_called_once_with(
2533             mock.sentinel.rp_uuid,
2534             mock.sentinel.rp_name,
2535             parent_provider_uuid=None,
2536         )
2537         self.assertFalse(mock_gocr.called)
2538         self.assertFalse(mock_erc.called)
2539         self.assertFalse(mock_upd.called)
2540         mock_del.assert_called_once_with(mock.sentinel.rp_uuid)
2541 
2542     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2543                 '_update_inventory')
2544     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2545                 '_delete_inventory')
2546     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2547                 '_ensure_resource_class')
2548     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2549                 '_get_or_create_resource_class')
2550     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2551                 '_ensure_resource_provider')
2552     def test_set_inventory_for_provider_with_custom(self, mock_erp,
2553             mock_gocr, mock_erc, mock_del, mock_upd):
2554         """Tests that inventory records that include a custom resource class
2555         are passed to the report client's _update_inventory() method and that
2556         the custom resource class is auto-created.
2557         """
2558         inv_data = {
2559             'VCPU': {
2560                 'total': 24,
2561                 'reserved': 0,
2562                 'min_unit': 1,
2563                 'max_unit': 24,
2564                 'step_size': 1,
2565                 'allocation_ratio': 1.0,
2566             },
2567             'MEMORY_MB': {
2568                 'total': 1024,
2569                 'reserved': 0,
2570                 'min_unit': 1,
2571                 'max_unit': 1024,
2572                 'step_size': 1,
2573                 'allocation_ratio': 1.0,
2574             },
2575             'DISK_GB': {
2576                 'total': 100,
2577                 'reserved': 0,
2578                 'min_unit': 1,
2579                 'max_unit': 100,
2580                 'step_size': 1,
2581                 'allocation_ratio': 1.0,
2582             },
2583             'CUSTOM_IRON_SILVER': {
2584                 'total': 1,
2585                 'reserved': 0,
2586                 'min_unit': 1,
2587                 'max_unit': 1,
2588                 'step_size': 1,
2589                 'allocation_ratio': 1.0,
2590             }
2591 
2592         }
2593         self.client.set_inventory_for_provider(
2594             mock.sentinel.rp_uuid,
2595             mock.sentinel.rp_name,
2596             inv_data,
2597         )
2598         mock_erp.assert_called_once_with(
2599             mock.sentinel.rp_uuid,
2600             mock.sentinel.rp_name,
2601             parent_provider_uuid=None,
2602         )
2603         mock_erc.assert_called_once_with('CUSTOM_IRON_SILVER')
2604         mock_upd.assert_called_once_with(
2605             mock.sentinel.rp_uuid,
2606             inv_data,
2607         )
2608         self.assertFalse(mock_gocr.called)
2609         self.assertFalse(mock_del.called)
2610 
2611     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2612                 '_delete_inventory', new=mock.Mock())
2613     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2614                 '_ensure_resource_class', new=mock.Mock())
2615     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2616                 '_ensure_resource_provider')
2617     def test_set_inventory_for_provider_with_parent(self, mock_erp):
2618         """Ensure parent UUID is sent through."""
2619         self.client.set_inventory_for_provider(
2620             uuids.child, 'junior', {}, parent_provider_uuid=uuids.parent)
2621         mock_erp.assert_called_once_with(
2622             uuids.child, 'junior', parent_provider_uuid=uuids.parent)
2623 
2624     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2625                 'put')
2626     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2627                 '_get_or_create_resource_class')
2628     def test_ensure_resource_class_microversion_failover(self, mock_gocr,
2629                                                          mock_put):
2630         mock_put.return_value.status_code = 406
2631         self.client._ensure_resource_class('CUSTOM_IRON_SILVER')
2632         mock_gocr.assert_called_once_with('CUSTOM_IRON_SILVER')
2633 
2634 
2635 class TestAllocations(SchedulerReportClientTestCase):
2636 
2637     @mock.patch('nova.compute.utils.is_volume_backed_instance')
2638     def test_instance_to_allocations_dict(self, mock_vbi):
2639         mock_vbi.return_value = False
2640         inst = objects.Instance(
2641             uuid=uuids.inst,
2642             flavor=objects.Flavor(root_gb=10,
2643                                   swap=1023,
2644                                   ephemeral_gb=100,
2645                                   memory_mb=1024,
2646                                   vcpus=2,
2647                                   extra_specs={}))
2648         result = report._instance_to_allocations_dict(inst)
2649         expected = {
2650             'MEMORY_MB': 1024,
2651             'VCPU': 2,
2652             'DISK_GB': 111,
2653         }
2654         self.assertEqual(expected, result)
2655 
2656     @mock.patch('nova.compute.utils.is_volume_backed_instance')
2657     def test_instance_to_allocations_dict_overrides(self, mock_vbi):
2658         """Test that resource overrides in an instance's flavor extra_specs
2659         are reported to placement.
2660         """
2661 
2662         mock_vbi.return_value = False
2663         specs = {
2664             'resources:CUSTOM_DAN': '123',
2665             'resources:%s' % fields.ResourceClass.VCPU: '4',
2666             'resources:NOTATHING': '456',
2667             'resources:NOTEVENANUMBER': 'catfood',
2668             'resources:': '7',
2669             'resources:ferret:weasel': 'smelly',
2670             'foo': 'bar',
2671         }
2672         inst = objects.Instance(
2673             uuid=uuids.inst,
2674             flavor=objects.Flavor(root_gb=10,
2675                                   swap=1023,
2676                                   ephemeral_gb=100,
2677                                   memory_mb=1024,
2678                                   vcpus=2,
2679                                   extra_specs=specs))
2680         result = report._instance_to_allocations_dict(inst)
2681         expected = {
2682             'MEMORY_MB': 1024,
2683             'VCPU': 4,
2684             'DISK_GB': 111,
2685             'CUSTOM_DAN': 123,
2686         }
2687         self.assertEqual(expected, result)
2688 
2689     @mock.patch('nova.compute.utils.is_volume_backed_instance')
2690     def test_instance_to_allocations_dict_boot_from_volume(self, mock_vbi):
2691         mock_vbi.return_value = True
2692         inst = objects.Instance(
2693             uuid=uuids.inst,
2694             flavor=objects.Flavor(root_gb=10,
2695                                   swap=1,
2696                                   ephemeral_gb=100,
2697                                   memory_mb=1024,
2698                                   vcpus=2,
2699                                   extra_specs={}))
2700         result = report._instance_to_allocations_dict(inst)
2701         expected = {
2702             'MEMORY_MB': 1024,
2703             'VCPU': 2,
2704             'DISK_GB': 101,
2705         }
2706         self.assertEqual(expected, result)
2707 
2708     @mock.patch('nova.compute.utils.is_volume_backed_instance')
2709     def test_instance_to_allocations_dict_zero_disk(self, mock_vbi):
2710         mock_vbi.return_value = True
2711         inst = objects.Instance(
2712             uuid=uuids.inst,
2713             flavor=objects.Flavor(root_gb=10,
2714                                   swap=0,
2715                                   ephemeral_gb=0,
2716                                   memory_mb=1024,
2717                                   vcpus=2,
2718                                   extra_specs={}))
2719         result = report._instance_to_allocations_dict(inst)
2720         expected = {
2721             'MEMORY_MB': 1024,
2722             'VCPU': 2,
2723         }
2724         self.assertEqual(expected, result)
2725 
2726     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2727                 'put')
2728     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2729                 'get')
2730     @mock.patch('nova.scheduler.client.report.'
2731                 '_instance_to_allocations_dict')
2732     def test_update_instance_allocation_new(self, mock_a, mock_get,
2733                                             mock_put):
2734         cn = objects.ComputeNode(uuid=uuids.cn)
2735         inst = objects.Instance(uuid=uuids.inst, project_id=uuids.project,
2736                                 user_id=uuids.user)
2737         mock_get.return_value.json.return_value = {'allocations': {}}
2738         expected = {
2739             'allocations': [
2740                 {'resource_provider': {'uuid': cn.uuid},
2741                  'resources': mock_a.return_value}],
2742             'project_id': inst.project_id,
2743             'user_id': inst.user_id,
2744         }
2745         self.client.update_instance_allocation(cn, inst, 1)
2746         mock_put.assert_called_once_with(
2747             '/allocations/%s' % inst.uuid,
2748             expected, version='1.8')
2749         self.assertTrue(mock_get.called)
2750 
2751     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2752                 'put')
2753     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2754                 'get')
2755     @mock.patch('nova.scheduler.client.report.'
2756                 '_instance_to_allocations_dict')
2757     def test_update_instance_allocation_existing(self, mock_a, mock_get,
2758                                                  mock_put):
2759         cn = objects.ComputeNode(uuid=uuids.cn)
2760         inst = objects.Instance(uuid=uuids.inst)
2761         mock_get.return_value.json.return_value = {'allocations': {
2762             cn.uuid: {
2763                 'generation': 2,
2764                 'resources': {
2765                     'DISK_GB': 123,
2766                     'MEMORY_MB': 456,
2767                 }
2768             }}
2769         }
2770         mock_a.return_value = {
2771             'DISK_GB': 123,
2772             'MEMORY_MB': 456,
2773         }
2774         self.client.update_instance_allocation(cn, inst, 1)
2775         self.assertFalse(mock_put.called)
2776         mock_get.assert_called_once_with(
2777             '/allocations/%s' % inst.uuid)
2778 
2779     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2780                 'get')
2781     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2782                 'put')
2783     @mock.patch('nova.scheduler.client.report.'
2784                 '_instance_to_allocations_dict')
2785     @mock.patch.object(report.LOG, 'warning')
2786     def test_update_instance_allocation_new_failed(self, mock_warn, mock_a,
2787                                                    mock_put, mock_get):
2788         cn = objects.ComputeNode(uuid=uuids.cn)
2789         inst = objects.Instance(uuid=uuids.inst, project_id=uuids.project,
2790                                 user_id=uuids.user)
2791         try:
2792             mock_put.return_value.__nonzero__.return_value = False
2793         except AttributeError:
2794             # NOTE(danms): LOL @ py3
2795             mock_put.return_value.__bool__.return_value = False
2796         self.client.update_instance_allocation(cn, inst, 1)
2797         self.assertTrue(mock_warn.called)
2798 
2799     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2800                 'delete')
2801     def test_update_instance_allocation_delete(self, mock_delete):
2802         cn = objects.ComputeNode(uuid=uuids.cn)
2803         inst = objects.Instance(uuid=uuids.inst)
2804         self.client.update_instance_allocation(cn, inst, -1)
2805         mock_delete.assert_called_once_with(
2806             '/allocations/%s' % inst.uuid)
2807 
2808     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2809                 'delete')
2810     @mock.patch.object(report.LOG, 'warning')
2811     def test_update_instance_allocation_delete_failed(self, mock_warn,
2812                                                       mock_delete):
2813         cn = objects.ComputeNode(uuid=uuids.cn)
2814         inst = objects.Instance(uuid=uuids.inst)
2815         try:
2816             mock_delete.return_value.__nonzero__.return_value = False
2817         except AttributeError:
2818             # NOTE(danms): LOL @ py3
2819             mock_delete.return_value.__bool__.return_value = False
2820         self.client.update_instance_allocation(cn, inst, -1)
2821         self.assertTrue(mock_warn.called)
2822 
2823     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2824                 'delete')
2825     @mock.patch('nova.scheduler.client.report.LOG')
2826     def test_delete_allocation_for_instance_ignore_404(self, mock_log,
2827                                                        mock_delete):
2828         """Tests that we don't log a warning on a 404 response when trying to
2829         delete an allocation record.
2830         """
2831         mock_response = mock.MagicMock(status_code=404)
2832         try:
2833             mock_response.__nonzero__.return_value = False
2834         except AttributeError:
2835             # py3 uses __bool__
2836             mock_response.__bool__.return_value = False
2837         mock_delete.return_value = mock_response
2838         self.client.delete_allocation_for_instance(uuids.rp_uuid)
2839         # make sure we didn't screw up the logic or the mock
2840         mock_log.info.assert_not_called()
2841         # make sure warning wasn't called for the 404
2842         mock_log.warning.assert_not_called()
2843 
2844     @mock.patch("nova.scheduler.client.report.SchedulerReportClient."
2845                 "delete")
2846     @mock.patch("nova.scheduler.client.report.SchedulerReportClient."
2847                 "delete_allocation_for_instance")
2848     @mock.patch("nova.objects.InstanceList.get_by_host_and_node")
2849     def test_delete_resource_provider_cascade(self, mock_by_host,
2850             mock_del_alloc, mock_delete):
2851         self.client._provider_tree.new_root(uuids.cn, uuids.cn, 1)
2852         cn = objects.ComputeNode(uuid=uuids.cn, host="fake_host",
2853                 hypervisor_hostname="fake_hostname", )
2854         inst1 = objects.Instance(uuid=uuids.inst1)
2855         inst2 = objects.Instance(uuid=uuids.inst2)
2856         mock_by_host.return_value = objects.InstanceList(
2857                 objects=[inst1, inst2])
2858         resp_mock = mock.Mock(status_code=204)
2859         mock_delete.return_value = resp_mock
2860         self.client.delete_resource_provider(self.context, cn, cascade=True)
2861         self.assertEqual(2, mock_del_alloc.call_count)
2862         exp_url = "/resource_providers/%s" % uuids.cn
2863         mock_delete.assert_called_once_with(exp_url)
2864         self.assertFalse(self.client._provider_tree.exists(uuids.cn))
2865 
2866     @mock.patch("nova.scheduler.client.report.SchedulerReportClient."
2867                 "delete")
2868     @mock.patch("nova.scheduler.client.report.SchedulerReportClient."
2869                 "delete_allocation_for_instance")
2870     @mock.patch("nova.objects.InstanceList.get_by_host_and_node")
2871     def test_delete_resource_provider_no_cascade(self, mock_by_host,
2872             mock_del_alloc, mock_delete):
2873         self.client._provider_tree.new_root(uuids.cn, uuids.cn, 1)
2874         self.client._provider_aggregate_map[uuids.cn] = mock.Mock()
2875         cn = objects.ComputeNode(uuid=uuids.cn, host="fake_host",
2876                 hypervisor_hostname="fake_hostname", )
2877         inst1 = objects.Instance(uuid=uuids.inst1)
2878         inst2 = objects.Instance(uuid=uuids.inst2)
2879         mock_by_host.return_value = objects.InstanceList(
2880                 objects=[inst1, inst2])
2881         resp_mock = mock.Mock(status_code=204)
2882         mock_delete.return_value = resp_mock
2883         self.client.delete_resource_provider(self.context, cn)
2884         mock_del_alloc.assert_not_called()
2885         exp_url = "/resource_providers/%s" % uuids.cn
2886         mock_delete.assert_called_once_with(exp_url)
2887         self.assertNotIn(uuids.cn, self.client._provider_aggregate_map)
2888 
2889     @mock.patch("nova.scheduler.client.report.SchedulerReportClient."
2890                 "delete")
2891     @mock.patch('nova.scheduler.client.report.LOG')
2892     def test_delete_resource_provider_log_calls(self, mock_log, mock_delete):
2893         # First, check a successful call
2894         self.client._provider_tree.new_root(uuids.cn, uuids.cn, 1)
2895         cn = objects.ComputeNode(uuid=uuids.cn, host="fake_host",
2896                 hypervisor_hostname="fake_hostname", )
2897         resp_mock = mock.MagicMock(status_code=204)
2898         try:
2899             resp_mock.__nonzero__.return_value = True
2900         except AttributeError:
2901             # py3 uses __bool__
2902             resp_mock.__bool__.return_value = True
2903         mock_delete.return_value = resp_mock
2904         self.client.delete_resource_provider(self.context, cn)
2905         # With a 204, only the info should be called
2906         self.assertEqual(1, mock_log.info.call_count)
2907         self.assertEqual(0, mock_log.warning.call_count)
2908 
2909         # Now check a 404 response
2910         mock_log.reset_mock()
2911         resp_mock.status_code = 404
2912         try:
2913             resp_mock.__nonzero__.return_value = False
2914         except AttributeError:
2915             # py3 uses __bool__
2916             resp_mock.__bool__.return_value = False
2917         self.client.delete_resource_provider(self.context, cn)
2918         # With a 404, neither log message should be called
2919         self.assertEqual(0, mock_log.info.call_count)
2920         self.assertEqual(0, mock_log.warning.call_count)
2921 
2922         # Finally, check a 409 response
2923         mock_log.reset_mock()
2924         resp_mock.status_code = 409
2925         self.client.delete_resource_provider(self.context, cn)
2926         # With a 409, only the warning should be called
2927         self.assertEqual(0, mock_log.info.call_count)
2928         self.assertEqual(1, mock_log.warning.call_count)
2929 
2930 
2931 class TestResourceClass(SchedulerReportClientTestCase):
2932 
2933     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2934                 '_create_resource_class')
2935     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.get')
2936     def test_get_or_create_existing(self, mock_get, mock_crc):
2937         resp_mock = mock.Mock(status_code=200)
2938         mock_get.return_value = resp_mock
2939         rc_name = 'CUSTOM_FOO'
2940         result = self.client._get_or_create_resource_class(rc_name)
2941         mock_get.assert_called_once_with(
2942             '/resource_classes/' + rc_name,
2943             version="1.2",
2944         )
2945         self.assertFalse(mock_crc.called)
2946         self.assertEqual(rc_name, result)
2947 
2948     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2949                 '_create_resource_class')
2950     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.get')
2951     def test_get_or_create_not_existing(self, mock_get, mock_crc):
2952         resp_mock = mock.Mock(status_code=404)
2953         mock_get.return_value = resp_mock
2954         rc_name = 'CUSTOM_FOO'
2955         result = self.client._get_or_create_resource_class(rc_name)
2956         mock_get.assert_called_once_with(
2957             '/resource_classes/' + rc_name,
2958             version="1.2",
2959         )
2960         mock_crc.assert_called_once_with(rc_name)
2961         self.assertEqual(rc_name, result)
2962 
2963     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.'
2964                 '_create_resource_class')
2965     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.get')
2966     def test_get_or_create_bad_get(self, mock_get, mock_crc):
2967         resp_mock = mock.Mock(status_code=500, text='server error')
2968         mock_get.return_value = resp_mock
2969         rc_name = 'CUSTOM_FOO'
2970         result = self.client._get_or_create_resource_class(rc_name)
2971         mock_get.assert_called_once_with(
2972             '/resource_classes/' + rc_name,
2973             version="1.2",
2974         )
2975         self.assertFalse(mock_crc.called)
2976         self.assertIsNone(result)
2977 
2978     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.post')
2979     def test_create_resource_class(self, mock_post):
2980         resp_mock = mock.Mock(status_code=201)
2981         mock_post.return_value = resp_mock
2982         rc_name = 'CUSTOM_FOO'
2983         result = self.client._create_resource_class(rc_name)
2984         mock_post.assert_called_once_with(
2985             '/resource_classes',
2986             {'name': rc_name},
2987             version="1.2",
2988         )
2989         self.assertIsNone(result)
2990 
2991     @mock.patch('nova.scheduler.client.report.LOG.info')
2992     @mock.patch('nova.scheduler.client.report.SchedulerReportClient.post')
2993     def test_create_resource_class_concurrent_write(self, mock_post, mock_log):
2994         resp_mock = mock.Mock(status_code=409)
2995         mock_post.return_value = resp_mock
2996         rc_name = 'CUSTOM_FOO'
2997         result = self.client._create_resource_class(rc_name)
2998         mock_post.assert_called_once_with(
2999             '/resource_classes',
3000             {'name': rc_name},
3001             version="1.2",
3002         )
3003         self.assertIsNone(result)
3004         self.assertIn('Another thread already', mock_log.call_args[0][0])
